import{_ as a,Q as e,S as t,a9 as d}from"./framework-d7e1aa10.js";const s={},n=d(`<h1 id="jvm-参数" tabindex="-1"><a class="header-anchor" href="#jvm-参数" aria-hidden="true">#</a> JVM 参数</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>JVM 参数选项类型：</p><ol><li><code>-</code> 标准参数选项：稳定的参数，后续版本基本不会变化，但是使用的较少</li><li><code>-X</code> 参数选项：非标准参数，较为稳定，但是后续可能小概率变更，使用 <code>java -X</code> 可以查看该类型的所有参数选项，使用的也比较少</li><li><code>-XX</code> 参数选项：非标准化参数，实验性参数不稳定，变动比较大，但是使用的最多；分为布尔型格式和非布尔型格式，前者表示开启与否，后者需要指定具体的值</li></ol><p>补充：</p><ol><li>Hotspot JVM 有两种模式：server 和 client，前者对服务器配置要求比较高，后者较低，通过标准参数选项 <code>-server</code> 和 <code>-client</code> 开启</li><li>参数有三种设置方式： <ol><li><code>-&lt;type&gt;:+&lt;option&gt;</code></li><li><code>-&lt;type&gt;:&lt;option&gt;&lt;size&gt;</code></li><li><code>-&lt;type&gt;:&lt;option&gt;=&lt;size&gt;</code></li></ol></li></ol><h2 id="按类型分类" tabindex="-1"><a class="header-anchor" href="#按类型分类" aria-hidden="true">#</a> 按类型分类</h2><h3 id="标准参数" tabindex="-1"><a class="header-anchor" href="#标准参数" aria-hidden="true">#</a> 标准参数</h3><blockquote><p>命令行中输入：<code>java -help</code> 查看</p></blockquote><div class="table-wrapper"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-d32</code></td><td>使用 32 位数据模型 (如果可用)</td></tr><tr><td>2</td><td><code>-d64</code></td><td>使用 64 位数据模型 (如果可用)</td></tr><tr><td>3</td><td><code>-server</code></td><td>选择 server 模式（默认）</td></tr><tr><td>4</td><td><code>-client</code></td><td>选择 client 模式</td></tr><tr><td>5</td><td><code>-cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</code><br><code>-classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</code></td><td>用 <code>;</code> 分隔目录，设置 JAR 档案 和 ZIP 档案列表, 用于搜索类文件</td></tr><tr><td>6</td><td><code>-D&lt;名称&gt;=&lt;值&gt;</code></td><td>设置系统属性</td></tr><tr><td>7</td><td><code>-verbose:[class/gc/jni]</code></td><td>启用详细输出</td></tr><tr><td>8</td><td><code>-version</code></td><td>输出产品版本并退出</td></tr><tr><td>9</td><td><code>-version:&lt;值&gt;</code></td><td>警告: 此功能已过时，将在未来发行版中删除，需要指定的版本才能运行</td></tr><tr><td>10</td><td><code>-showversion</code></td><td>输出产品版本并继续</td></tr><tr><td>11</td><td><code>-jre-restrict-search / -no-jre-restrict-search</code></td><td>警告: 此功能已过时，将在未来发行版中删除，在版本搜索中包括/排除用户专用 JRE</td></tr><tr><td>12</td><td><code>-? -help</code></td><td>输出此帮助消息</td></tr><tr><td>13</td><td><code>-X</code></td><td>输出非标准选项的帮助</td></tr><tr><td>14</td><td><code>-ea[:&lt;packagename&gt;.../:&lt;classname&gt;]</code><br><code>-enableassertions[:&lt;packagename&gt;.../:&lt;classname&gt;]</code></td><td>按指定的粒度启用断言</td></tr><tr><td>15</td><td><code>-da[:&lt;packagename&gt;.../:&lt;classname&gt;]</code><br><code>-disableassertions[:&lt;packagename&gt;.../:&lt;classname&gt;]</code></td><td>禁用具有指定粒度的断言</td></tr><tr><td>16</td><td><code>-esa / -enablesystemassertions</code></td><td>启用系统断言</td></tr><tr><td>17</td><td><code>-dsa / -disablesystemassertions</code></td><td>禁用系统断言</td></tr><tr><td>18</td><td><code>-agentlib:&lt;libname&gt;[=&lt;选项&gt;]</code></td><td>加载本机代理库 <code>&lt;libname&gt;</code>，例如 <code>-agentlib:hprof</code>，另请参阅 <code>-agentlib:jdwp=help</code> 和 <code>-agentlib:hprof=help</code></td></tr><tr><td>19</td><td><code>-agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</code></td><td>按完整路径名加载本机代理库</td></tr><tr><td>20</td><td><code>-javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</code></td><td>加载 Java 编程语言代理，请参阅 <code>java.lang.instrument</code></td></tr><tr><td>21</td><td><code>-splash:&lt;imagepath&gt;</code></td><td>使用指定的图像显示启动屏幕</td></tr></tbody></table></div><h3 id="非标准-x-参数" tabindex="-1"><a class="header-anchor" href="#非标准-x-参数" aria-hidden="true">#</a> 非标准 -X 参数</h3><blockquote><p>命令行中输入：<code>java -X</code> 查看</p></blockquote><div class="table-wrapper"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-Xint</code></td><td>禁用 JIT，所有字节码都被解释执行，该模式速度最慢</td></tr><tr><td>2</td><td><code>-Xcomp</code></td><td>所有字节码第一次使用就被编译成本地代码，然后再执行</td></tr><tr><td>3</td><td><code>-Xmixed</code></td><td>混合模式，也是默认模式，让 JIT 根据程序运行情况具体选择</td></tr><tr><td>4</td><td><code>-Xms</code></td><td>堆最小值</td></tr><tr><td>5</td><td><code>-Xmx</code></td><td>堆最大值，通常 <code>-Xms</code> 和 <code>-Xmx</code>大小相同，这样就不会动态扩容</td></tr><tr><td>6</td><td><code>-Xmn</code></td><td>新生代大小</td></tr><tr><td>7</td><td><code>-Xss</code></td><td>每个线程池的堆栈大小。在jdk5以上的版本，每个线程堆栈大小为1m，jdk5以前的版本是每个线程池大小为256k。一般在相同物理内存下，如果减少－xss值会产生更大的线程数，但不同的操作系统对进程内线程数是有限制的，是不能无限生成</td></tr><tr><td>8</td><td><code>-Xbootclasspath:&lt;用; 分隔的目录和 zip/jar 文件&gt;</code></td><td>设置搜索路径以引导类和资源</td></tr><tr><td>9</td><td><code>-Xbootclasspath/a:&lt;用 ;分隔的目录和 zip/jar 文件&gt;</code></td><td>附加在引导类路径末尾</td></tr><tr><td>10</td><td><code>-Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</code></td><td>置于引导类路径之前</td></tr><tr><td>11</td><td><code>-Xdiag</code></td><td>显示附加诊断消息</td></tr><tr><td>12</td><td><code>-Xnoclassgc</code></td><td>禁用类垃圾收集</td></tr><tr><td>13</td><td><code>-Xincgc</code></td><td>启用增量垃圾收集</td></tr><tr><td>14</td><td><code>-Xloggc:&lt;file&gt;</code></td><td>将 GC 状态记录在文件中 (带时间戳)</td></tr><tr><td>15</td><td><code>-Xbatch</code></td><td>禁用后台编译</td></tr><tr><td>16</td><td><code>-Xms&lt;size&gt;</code></td><td>设置初始 Java 堆大小</td></tr><tr><td>17</td><td><code>-Xmx&lt;size&gt;</code></td><td>设置最大 Java 堆大小</td></tr><tr><td>18</td><td><code>-Xss&lt;size&gt;</code></td><td>设置 Java 线程堆栈大小</td></tr><tr><td>19</td><td><code>-Xprof</code></td><td>输出 cpu 配置文件数据</td></tr><tr><td>20</td><td><code>-Xfuture</code></td><td>启用最严格的检查, 预期将来的默认值</td></tr><tr><td>21</td><td><code>-Xrs</code></td><td>减少 Java/VM 对操作系统信号的使用</td></tr><tr><td>22</td><td><code>-Xcheck:jni</code></td><td>对 JNI 函数执行其他检查</td></tr><tr><td>23</td><td><code>-Xshare:off</code></td><td>不尝试使用共享类数据</td></tr><tr><td>24</td><td><code>-Xshare:auto</code></td><td>在可能的情况下使用共享类数据 (默认)</td></tr><tr><td>25</td><td><code>-Xshare:on</code></td><td>要求使用共享类数据, 否则将失败</td></tr><tr><td>26</td><td><code>-XshowSettings</code></td><td>显示所有设置并继续</td></tr><tr><td>27</td><td><code>-XshowSettings:all</code></td><td>显示所有设置并继续</td></tr><tr><td>28</td><td><code>-XshowSettings:vm</code></td><td>显示所有与 vm 相关的设置并继续</td></tr><tr><td>29</td><td><code>-XshowSettings:properties</code></td><td>显示所有属性设置并继续</td></tr><tr><td>30</td><td><code>-XshowSettings:locale</code></td><td>显示所有与区域设置相关的设置并继续</td></tr></tbody></table></div><h3 id="非标准-xx-参数" tabindex="-1"><a class="header-anchor" href="#非标准-xx-参数" aria-hidden="true">#</a> 非标准 -XX 参数</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 打印参数</span>
<span class="token parameter variable">-XX:+PrintCommandLineFlags</span> 程序运行时JVM默认设置或用户手动设置的XX选项
<span class="token parameter variable">-XX:+PrintFlagsInitial</span> 打印所有XX选项的默认值
<span class="token parameter variable">-XX:+PrintFlagsFinal</span> 打印所有XX选项的实际值
<span class="token parameter variable">-XX:+PrintVMOptions</span> 打印JVM的参数

<span class="token comment"># 栈</span>
<span class="token parameter variable">-Xss128k</span> <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token parameter variable">-XX:ThreadStackSize</span><span class="token operator">=</span>128k 设置线程栈的大小为128K

<span class="token comment"># 堆</span>
<span class="token parameter variable">-Xms2048m</span> <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span>2048m 设置JVM初始堆内存为2048M
<span class="token parameter variable">-Xmx2048m</span> <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span>2048m 设置JVM最大堆内存为2048M
<span class="token parameter variable">-Xmn2g</span> <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span>2g <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span>2g 设置年轻代大小为2G
<span class="token parameter variable">-XX:SurvivorRatio</span><span class="token operator">=</span><span class="token number">8</span> 设置Eden区与Survivor区的比值，默认为8
<span class="token parameter variable">-XX:NewRatio</span><span class="token operator">=</span><span class="token number">2</span> 设置老年代与年轻代的比例，默认为2
<span class="token parameter variable">-XX:+UseAdaptiveSizePolicy</span> 设置大小比例自适应，默认开启
<span class="token parameter variable">-XX:PretenureSizeThreadshold</span><span class="token operator">=</span><span class="token number">1024</span> 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效
<span class="token parameter variable">-XX:MaxTenuringThreshold</span><span class="token operator">=</span><span class="token number">15</span> 设置新生代晋升老年代的年龄限制，默认为15
<span class="token parameter variable">-XX:TargetSurvivorRatio</span> 设置MinorGC结束后Survivor区占用空间的期望比例

<span class="token comment"># 方法区</span>
<span class="token parameter variable">-XX:MetaspaceSize</span> / <span class="token parameter variable">-XX:PermSize</span><span class="token operator">=</span>256m 设置元空间/永久代初始值为256M
<span class="token parameter variable">-XX:MaxMetaspaceSize</span> / <span class="token parameter variable">-XX:MaxPermSize</span><span class="token operator">=</span>256m 设置元空间/永久代最大值为256M
<span class="token parameter variable">-XX:+UseCompressedOops</span> 使用压缩对象
<span class="token parameter variable">-XX:+UseCompressedClassPointers</span> 使用压缩类指针
<span class="token parameter variable">-XX:CompressedClassSpaceSize</span> 设置Klass Metaspace的大小，默认1G

<span class="token comment"># 直接内存</span>
<span class="token parameter variable">-XX:MaxDirectMemorySize</span> 指定DirectMemory容量，默认等于Java堆最大值

<span class="token comment"># GC 信息</span>
<span class="token parameter variable">-XX:+HeapDumpOnOutMemoryError</span> 内存出现OOM时生成Heap转储文件，两者互斥
<span class="token parameter variable">-XX:+HeapDumpBeforeFullGC</span> 出现FullGC时生成Heap转储文件，两者互斥
<span class="token parameter variable">-XX:HeapDumpPath</span><span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">&gt;</span> 指定heap转储文件的存储路径，默认当前目录
<span class="token parameter variable">-XX:OnOutOfMemoryError</span><span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">&gt;</span> 指定可行性程序或脚本的路径，当发生OOM时执行脚本

<span class="token comment"># Serial回收器</span>
<span class="token parameter variable">-XX:+UseSerialGC</span>  年轻代使用Serial GC， 老年代使用Serial Old GC

<span class="token comment"># ParNew回收器</span>
<span class="token parameter variable">-XX:+UseParNewGC</span>  年轻代使用ParNew GC
<span class="token parameter variable">-XX:ParallelGCThreads</span>  设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能
	
<span class="token comment"># Parallel回收器</span>
<span class="token parameter variable">-XX:+UseParallelGC</span>  年轻代使用 Parallel Scavenge GC，互相激活
<span class="token parameter variable">-XX:+UseParallelOldGC</span>  老年代使用 Parallel Old GC，互相激活
<span class="token parameter variable">-XX:MaxGCPauseMillis</span>  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。
	为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数
	对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量
	所以服务器端适合Parallel，进行控制。该参数使用需谨慎。
<span class="token parameter variable">-XX:GCTimeRatio</span>  垃圾收集时间占总时间的比例（1 / <span class="token punctuation">(</span>N＋1<span class="token punctuation">)</span>），用于衡量吞吐量的大小
	取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。
	与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。
<span class="token parameter variable">-XX:+UseAdaptiveSizePolicy</span>  设置Parallel Scavenge收集器具有自适应调节策略。
	在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。
	在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。
		
<span class="token comment"># CMS回收器</span>
<span class="token parameter variable">-XX:+UseConcMarkSweepGC</span>  年轻代使用CMS GC。
	开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合
<span class="token parameter variable">-XX:CMSInitiatingOccupanyFraction</span>  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。
	如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。
	反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。
	因此通过该选项便可以有效降低Fu1l GC的执行次数。
<span class="token parameter variable">-XX:+UseCMSInitiatingOccupancyOnly</span>  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动
<span class="token parameter variable">-XX:+UseCMSCompactAtFullCollection</span>  用于指定在执行完Full GC后对内存空间进行压缩整理
	以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
<span class="token parameter variable">-XX:CMSFullGCsBeforeCompaction</span>  设置在执行多少次Full GC后对内存空间进行压缩整理。
<span class="token parameter variable">-XX:ParallelCMSThreads</span>  设置CMS的线程数量。
	CMS 默认启动的线程数是<span class="token punctuation">(</span>ParallelGCThreads＋3<span class="token punctuation">)</span>/4，ParallelGCThreads 是年轻代并行收集器的线程数。
	当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。
<span class="token parameter variable">-XX:ConcGCThreads</span>  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的
<span class="token parameter variable">-XX:+CMSScavengeBeforeRemark</span>  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度
<span class="token parameter variable">-XX:+CMSClassUnloadingEnable</span>  如果有的话，启用回收Perm 区（JDK8之前）
<span class="token parameter variable">-XX:+CMSParallelInitialEnabled</span>  用于开启CMS initial-mark阶段采用多线程的方式进行标记
	用于提高标记速度，在Java8开始已经默认开启
<span class="token parameter variable">-XX:+CMSParallelRemarkEnabled</span>  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启
<span class="token parameter variable">-XX:+ExplicitGCInvokesConcurrent</span>
<span class="token parameter variable">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span>
	这两个参数用户指定hotspot虚拟在执行System.gc<span class="token punctuation">(</span><span class="token punctuation">)</span>时使用CMS周期
<span class="token parameter variable">-XX:+CMSPrecleaningEnabled</span>  指定CMS是否需要进行Pre cleaning阶段

<span class="token comment"># G1回收器</span>
<span class="token parameter variable">-XX:+UseG1GC</span> 手动指定使用G1收集器执行内存回收任务。
<span class="token parameter variable">-XX:G1HeapRegionSize</span> 设置每个Region的大小。
	值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。
<span class="token parameter variable">-XX:MaxGCPauseMillis</span>  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms
<span class="token parameter variable">-XX:ParallelGCThread</span>  设置STW时GC线程数的值。最多设置为8
<span class="token parameter variable">-XX:ConcGCThreads</span>  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。
<span class="token parameter variable">-XX:InitiatingHeapOccupancyPercent</span> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。
<span class="token parameter variable">-XX:G1NewSizePercent</span>  新生代占用整个堆内存的最小百分比（默认5％）
<span class="token parameter variable">-XX:G1MaxNewSizePercent</span>  新生代占用整个堆内存的最大百分比（默认60％）
<span class="token parameter variable">-XX:G1ReservePercent</span><span class="token operator">=</span><span class="token number">10</span>  保留内存区域，防止 to space（Survivor中的to区）溢出

<span class="token comment"># 日志</span>
<span class="token parameter variable">-XX:+PrintGC</span> <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token parameter variable">-verbose:gc</span>  打印简要日志信息
<span class="token parameter variable">-XX:+PrintGCDetails</span>            打印详细日志信息
<span class="token parameter variable">-XX:+PrintGCTimeStamps</span>  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用
<span class="token parameter variable">-XX:+PrintGCDateStamps</span>  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用
<span class="token parameter variable">-XX:+PrintHeapAtGC</span>  打印GC前后的堆信息，如下图
-Xloggc:<span class="token operator">&lt;</span>file<span class="token operator">&gt;</span> 输出GC导指定路径下的文件中
<span class="token parameter variable">-XX:+TraceClassLoading</span>  监控类的加载
<span class="token parameter variable">-XX:+PrintGCApplicationStoppedTime</span>  打印GC时线程的停顿时间
<span class="token parameter variable">-XX:+PrintGCApplicationConcurrentTime</span>  打印垃圾收集之前应用未中断的执行时间
<span class="token parameter variable">-XX:+PrintReferenceGC</span> 打印回收了多少种不同引用类型的引用
<span class="token parameter variable">-XX:+PrintTenuringDistribution</span>  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布
<span class="token parameter variable">-XX:+UseGCLogFileRotation</span> 启用GC日志文件的自动转储
<span class="token parameter variable">-XX:NumberOfGCLogFiles</span><span class="token operator">=</span><span class="token number">1</span>  设置GC日志文件的循环数目
<span class="token parameter variable">-XX:GCLogFileSize</span><span class="token operator">=</span>1M  设置GC日志文件的大小

<span class="token comment"># 其他</span>
<span class="token parameter variable">-XX:+DisableExplicitGC</span>  禁用hotspot执行System.gc<span class="token punctuation">(</span><span class="token punctuation">)</span>，默认禁用
<span class="token parameter variable">-XX:ReservedCodeCacheSize</span><span class="token operator">=</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span><span class="token punctuation">[</span>g<span class="token operator">|</span>m<span class="token operator">|</span>k<span class="token punctuation">]</span>、-XX:InitialCodeCacheSize<span class="token operator">=</span><span class="token operator">&lt;</span>n<span class="token operator">&gt;</span><span class="token punctuation">[</span>g<span class="token operator">|</span>m<span class="token operator">|</span>k<span class="token punctuation">]</span>  指定代码缓存的大小
<span class="token parameter variable">-XX:+UseCodeCacheFlushing</span>  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况
<span class="token parameter variable">-XX:+DoEscapeAnalysis</span>  开启逃逸分析
<span class="token parameter variable">-XX:+UseBiasedLocking</span>  开启偏向锁
<span class="token parameter variable">-XX:+UseLargePages</span>  开启使用大页面
<span class="token parameter variable">-XX:+PrintTLAB</span>  打印TLAB的使用情况
<span class="token parameter variable">-XX:TLABSize</span>  设置TLAB大小
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="按功能分类" tabindex="-1"><a class="header-anchor" href="#按功能分类" aria-hidden="true">#</a> 按功能分类</h2><h3 id="内存设置" tabindex="-1"><a class="header-anchor" href="#内存设置" aria-hidden="true">#</a> 内存设置</h3><div class="table-wrapper"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-Xms</code></td><td>堆最小值</td></tr><tr><td>2</td><td><code>-Xmx</code></td><td>堆最大值，通常 <code>-Xms</code> 和 <code>-Xmx</code>大小相同，这样就不会动态扩容</td></tr><tr><td>3</td><td><code>-Xmn</code></td><td>新生代大小</td></tr><tr><td>4</td><td><code>-Xss</code></td><td>每个线程池的堆栈大小。在jdk5以上的版本，每个线程堆栈大小为1m，jdk5以前的版本是每个线程池大小为256k。一般在相同物理内存下，如果减少－xss值会产生更大的线程数，但不同的操作系统对进程内线程数是有限制的，是不能无限生成</td></tr><tr><td>5</td><td><code>-XX:NewRatio</code></td><td>设置新生代与老年代比值，-XX:NewRatio = 4 表示新生代与老年代所占比例为 1 : 4 ，新生代占比整个堆的五分之一。如果设置了 <code>-Xmn</code> 的情况下，该参数是不需要在设置的</td></tr><tr><td>6</td><td><code>-XX:MaxTenuringThreshold</code></td><td>新生代对象的存活次数，默认为 15</td></tr><tr><td>7</td><td><code>-XX:SurvivorRatio</code></td><td>存活区与伊甸园区的比例，默认为 2 : 8</td></tr><tr><td>8</td><td><code>-XX:MaxMetaspaceSize</code></td><td>元数据区大小。<code>PermSize</code> 和 <code>MaxPermSize</code> （永久代）已经不能使用了，在 JDK8 中配置这两个参数将会发出警告。</td></tr></tbody></table></div><p>补充说明：</p><ol><li>Xmn用于设置新生代的大小。过小会增加Minor GC频率，过大会减小老年代的大小。一般设为整个堆空间的1/4或1/3.</li><li>XX:SurvivorRatio用于设置新生代中survivor空间(from/to)和eden空间的大小比例； XX:TargetSurvivorRatio表示，当经历Minor GC后，survivor空间占有量(百分比)超过它的时候，就会压缩进入老年代(当然，如果survivor空间不够，则直接进入老年代)。默认值为50%。</li><li>为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生的大对象直接进入老年代。因为新生对象大部分都是短期的，这就造成了老年代的内存浪费，并且回收代价也高(Full GC发生在老年代和方法区Perm).</li><li>当Xms=Xmx，可以使得堆相对稳定，避免不停震荡</li><li>一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少<strong>动态类</strong>的产生。</li></ol><h3 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理" aria-hidden="true">#</a> 错误处理</h3><div class="table-wrapper"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-XX:+HeapDumpOutofMemoryErorr</code></td><td>当发生 OOM 时会自动 dump 堆栈到文件中</td></tr><tr><td>2</td><td><code>-XX:HeapDumpPath</code></td><td>指定 dump 文件的保存路径</td></tr><tr><td>3</td><td><code>-XX:-UseGCOverheadLimit</code></td><td>会将 OutOfMemoryError: GC overhead limit exceeded 延迟到 OutOfMemoryError: Java heap space</td></tr><tr><td>4</td><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>在 OutOfMemoryError 后获取一份 HPROF 二进制 Heap Dump 文件</td></tr><tr><td>5</td><td><code>-XX:+HeapDumpOnCtrlBreak</code></td><td>Ctrl + Break 组合键即可获取一份 Heap Dump</td></tr><tr><td>6</td><td><code>-agentlib:hprof=heap=dump,format=b</code></td><td>在程序执行结束时或受到 SIGOUT 信号时生成 Dump 文件</td></tr></tbody></table></div><p>OOM：</p><ol><li>java.lang.OutOfMemoryError: Metaspace</li><li>OutOfMemoryError: GC overhead limit exceeded</li><li>OutOfMemoryError: Java heap space</li></ol><h3 id="垃圾收集" tabindex="-1"><a class="header-anchor" href="#垃圾收集" aria-hidden="true">#</a> 垃圾收集</h3><div class="table-wrapper"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-XX:+PrintGC</code></td><td>输出 GC 日志</td></tr><tr><td>2</td><td><code>-XX:+PrintGCDetails</code></td><td>打印 GC 详细日志</td></tr><tr><td>3</td><td><code>-XX:+PrintGCTimeStamps</code></td><td>输出 GC 的时间戳（以基准时间的形式）</td></tr><tr><td>4</td><td><code>-XX:+PrintGCDateStamps</code></td><td>输出 GC 的时间戳（以日期的形式）</td></tr><tr><td>5</td><td><code>-XX:+PrintHeapAtGC</code></td><td>在进行 GC 的前后打印出堆的信息</td></tr><tr><td>6</td><td><code>-Xloggc:../logs/gc.log</code></td><td>日志文件的输出路径</td></tr><tr><td>7</td><td><code>-XX:+PrintCommandLineFlags</code></td><td>查看垃圾回收器</td></tr><tr><td>8</td><td><code>-XX:+UseSerialGC</code></td><td>使用 Serial GC 和 Serial Old GC</td></tr><tr><td>9</td><td><code>-XX:+UseParNewGC</code></td><td>使用 ParNew GC</td></tr><tr><td>10</td><td><code>-XX:+UseParallelGC</code></td><td>使用 Parallel GC 和 Parallel Old GC</td></tr><tr><td>11</td><td><code>-XX:ParallelGCThreads</code></td><td>使用多线程垃圾收集器时指定最大线程数，默认为 CPU 核数</td></tr><tr><td>12</td><td><code>-XX:MaxGCPauseMillis</code></td><td>设置垃圾回收的暂停时间，该参数会影响吞吐量，要谨慎修改</td></tr><tr><td>13</td><td><code>-XX:GCTimeRatio</code></td><td>垃圾收集时间占总时间的比例，默认 99，表示垃圾收集时间不大于 1 %，计算为 1 / (1 + N)，此处 N = 99，得出 1 %</td></tr><tr><td>14</td><td><code>-XX:+UseConcMarkSwapGC</code></td><td>使用 CMS GC 和 ParNew GC，某些情况下 CMS GC 无法工作会使用 Serial Old GC</td></tr><tr><td>15</td><td><code>-XX:ParallelCMSThreads</code></td><td>使用 CMS 时的线程数量限制</td></tr><tr><td>16</td><td><code>-XX:+UseCMSCompactAtFullCollection</code></td><td>使用 CMS 时，进行完 Full GC 后进行内存碎片整理</td></tr><tr><td>17</td><td><code>-XX:CMSFullGCsBeforeCompaction</code></td><td>使用 CMS 时，设置在多少次 Full GC 后进行内存碎片的整理</td></tr><tr><td>18</td><td><code>-XX:CMSInitiatingOccupanyFraction</code></td><td>设置堆内存使用率的阈值，超过就进行 CMS GC 的垃圾收集，JDK 6 之后默认为 92%</td></tr><tr><td>19</td><td><code>-XX:+UseG1GC</code></td><td>使用 G1 垃圾回收器</td></tr><tr><td>20</td><td><code>-XX:G1HeapRegionSize</code></td><td>使用 G1 GC 时设置 Region 大小，每个 Region 范围为 1MB ~ 32MB（ 2 的幂），分为 2048 个 Region，对应的堆内存为 2GB ~ 64 GB，Region 的大小默认为堆内存的 1/2000</td></tr><tr><td>21</td><td><code>-XX:ConcGCThreads</code></td><td>设置并发标记的线程数，一般为 <code>ParallelGCThreads</code> 的 1/4</td></tr><tr><td>22</td><td><code>-XX:InitiatingHeapOccupancyPercent</code></td><td>设置并发线程 GC 发生时堆内存的阈值，即超过该阈值就进行 GC</td></tr></tbody></table></div><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><div class="table-wrapper"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-XX:+PrintFlagsInitial</code></td><td>查看所有 JVM 启动参数的初始值</td></tr><tr><td>2</td><td><code>-XX:+PrintFlagsFinal</code></td><td>查看所有 JVM 参数的最终值</td></tr><tr><td>3</td><td><code>-XX:+PrintCommandLineFlags</code></td><td>查看已经被 JVM 或者用户设置过的详细的带有 <code>XX</code> 的参数和值</td></tr></tbody></table></div>`,28),r=[n];function l(i,o){return e(),t("div",null,r)}const p=a(s,[["render",l],["__file","Y-JVM参数.html.vue"]]);export{p as default};
