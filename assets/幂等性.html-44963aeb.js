import{_ as n,Q as o,S as r,U as e,W as a,X as t,a8 as l,a9 as s,H as c}from"./framework-d7e1aa10.js";const d={},h=e("h1",{id:"幂等性",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#幂等性","aria-hidden":"true"},"#"),l(" 幂等性")],-1),_={class:"table-of-contents"},p=s('<h2 id="什么是幂等性" tabindex="-1"><a class="header-anchor" href="#什么是幂等性" aria-hidden="true">#</a> 什么是幂等性？</h2><div class="hint-container info"><p class="hint-container-title">说明</p><p>幂等性是指一个操作或请求可以被执行多次，但仍然产生相同的结果，而不会引起不必要的副作用或状态变化。</p></div><p>如果一个操作或请求是幂等的，那么它的结果不会随着它被多次执行而变化。这是非常重要的，因为在分布式系统和网络通信中，重复的请求和操作是很常见的情况。如果一个操作不是幂等的，那么重复执行可能会导致数据的损坏或者不一致，因为状态会被多次修改。</p><p>一些常见的幂等操作包括读取数据、删除数据、更新数据和向队列中添加消息等。在设计分布式系统和网络协议时，通常需要考虑如何实现幂等性，以确保系统的正确性和可靠性。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>接口幂等和防止重复提交严格来说不是同一件事</p><p>幂等一般是指在已经发生了多次提交的情况下，避免重复提交有副作用</p><p>防止重复提交是直接组织用户多次提交</p></div><p>有些情况下是无法阻止重复提交的，比如：</p><ol><li>接口超时充实</li><li>消息队列中的消息重复消费</li><li>网络不稳定请求重发</li></ol><h2 id="保证幂等性的接口" tabindex="-1"><a class="header-anchor" href="#保证幂等性的接口" aria-hidden="true">#</a> 保证幂等性的接口</h2><ol><li>Select 操作：GET、HEAD、OPTIONS 都具有幂等性</li><li>DELETE 操作：删除一次和多次最终结果是一样的，但是影响的行数可能不一样，需要注意保持幂等性</li><li>ADD / EDIT 操作：根据具体情况而定</li></ol><h2 id="实现幂等性的方法" tabindex="-1"><a class="header-anchor" href="#实现幂等性的方法" aria-hidden="true">#</a> 实现幂等性的方法</h2><ol><li>悲观锁：数据库中使用 <code>for update</code>，但是一般不适用，效率太低</li><li>唯一标识符：针对 <strong>插入操作</strong>，为每个请求生成一个唯一的标识符（例如UUID），并将该标识符与请求一起发送。接收方可以根据标识符判断该请求是否已经处理过，如果已经处理过，则可以直接返回处理结果，避免重复执行。</li><li>去重表：本质上也是唯一索引，这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。</li><li>版本号（乐观锁）：对于可变资源，可以引入版本号的概念。每次更新资源时，都需要指定版本号，如果版本号与当前版本不一致，则说明该请求已经处理过，可以直接返回处理结果。</li><li>Token：使用Token来保证请求的唯一性，每次请求时需要携带Token，服务端会验证Token的有效性，防止重复请求。</li><li>分布式锁：分布式锁实现幂等性的逻辑是，在每次执行方法之前判断，是否可以获取到分布式锁，如果可以，则表示为第一次执行方法，否则直接舍弃请求即可。需要注意的是分布式锁的key必须为业务的唯一标识，通常用redis分布式锁或者zookeeper来实现分布式锁。</li></ol>',11);function u(f,k){const i=c("router-link");return o(),r("div",null,[h,e("nav",_,[e("ul",null,[e("li",null,[a(i,{to:"#幂等性"},{default:t(()=>[l("幂等性")]),_:1}),e("ul",null,[e("li",null,[a(i,{to:"#什么是幂等性"},{default:t(()=>[l("什么是幂等性？")]),_:1})]),e("li",null,[a(i,{to:"#保证幂等性的接口"},{default:t(()=>[l("保证幂等性的接口")]),_:1})]),e("li",null,[a(i,{to:"#实现幂等性的方法"},{default:t(()=>[l("实现幂等性的方法")]),_:1})])])])])]),p])}const T=n(d,[["render",u],["__file","幂等性.html.vue"]]);export{T as default};
