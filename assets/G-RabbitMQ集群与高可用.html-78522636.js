import{_ as r,Q as s,S as d,U as i,W as l,X as t,a8 as a,a9 as h,H as o}from"./framework-d7e1aa10.js";const b={},u=i("h1",{id:"rabbitmq-集群和高可用",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#rabbitmq-集群和高可用","aria-hidden":"true"},"#"),a(" RabbitMQ 集群和高可用")],-1),p=i("div",{class:"hint-container info"},[i("p",{class:"hint-container-title"},"RabbitMQ 集群"),i("p",null,"RabbitMQ 集群是一组运行了 RabbitMQ 节点的机器，它们在逻辑上组成一个单一的逻辑 Broker。集群中的每个节点都有相同的队列、交换器、绑定和用户，它们使用 Erlang 分布式机制通信。RabbitMQ 集群的好处是可以通过添加节点来增加负载能力和高可用性。")],-1),c={class:"table-of-contents"},M=h('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><h3 id="何如实现高可用" tabindex="-1"><a class="header-anchor" href="#何如实现高可用" aria-hidden="true">#</a> 何如实现高可用？</h3><div class="hint-container info"><p class="hint-container-title">说明</p><p>RabbitMQ 是基于主从（非分布式）做高可用性的，有三种模式：</p><ol><li>单机模式</li><li>普通集群模式</li><li>镜像集群模式</li></ol></div><p>普通集群模式：</p><ol><li><p>意思就是在多台机器上启动多个 RabbitMQ 实例，每台机器启动一个</p></li><li><p>创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）</p></li><li><p>消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来</p></li><li><p>要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈</p></li><li><p>如果存放数据的 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据</p></li><li><p>该方案实际上没有保证高可用性，主要是提高了「吞吐量」</p></li></ol><p>镜像集群模式：</p><ol><li>RabbitMQ 高可用性是通过镜像队列（Mirrored Queue）来实现的</li><li>镜像队列是指队列的所有数据都会被复制到其他节点上，从而实现数据的备份和冗余</li><li>当主节点出现故障时，备份节点可以接管并继续提供服务，从而实现高可用性</li></ol><h3 id="实现一般步骤" tabindex="-1"><a class="header-anchor" href="#实现一般步骤" aria-hidden="true">#</a> 实现一般步骤</h3><p>RabbitMQ 集群和高可用性的实现可以通过以下步骤来完成：</p><ol><li>安装 RabbitMQ。可以在多个节点上安装 RabbitMQ，然后在其中一个节点上启动 RabbitMQ，其他节点将自动加入集群。</li><li>配置节点。每个节点都需要配置主机名、IP 地址、Erlang Cookie 等信息。这些配置将用于节点之间的通信和识别。</li><li>启动 RabbitMQ 节点。在所有节点上启动 RabbitMQ。</li><li>设置镜像队列。创建镜像队列时需要指定队列的名称、持久性和其他参数。队列将自动复制到其他节点上。</li><li>测试镜像队列。可以发送和接收消息以测试镜像队列是否正常工作。</li><li>配置负载均衡。可以使用负载均衡器将流量分配到多个节点上，从而增加负载能力和高可用性。</li></ol><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h3><p>RabbitMQ 集群和高可用性的优点包括：</p><ol><li>集群可以通过添加节点来增加负载能力和高可用性。</li><li>镜像队列可以确保数据的冗余和备份，从而提高可靠性。</li><li>负载均衡可以平衡流量，并将请求分配到多个节点上，从而提高性能和可用性。</li><li>RabbitMQ 的集群和高可用性功能都是开源的，可以免费使用和定制。</li></ol><p>RabbitMQ 集群和高可用性的缺点包括：</p><ol><li>集群和镜像队列需要消耗更多的资源和带宽。</li><li>集群配置和维护比单个节点更复杂。</li><li>RabbitMQ 集群和高可用性只提供了一定程度的可靠性，无法保证 100% 的可用性。</li></ol><h2 id="镜像队列" tabindex="-1"><a class="header-anchor" href="#镜像队列" aria-hidden="true">#</a> 镜像队列</h2><div class="hint-container info"><p class="hint-container-title">镜像队列</p><p>RabbitMQ中的镜像队列是为了提高队列的可用性而设计的。当一个队列被声明为镜像队列时，队列会在多个节点（即镜像节点）之间进行复制，从而保证即使某个节点宕机，也能够保证队列的数据不会丢失。</p></div><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//rabbitmq/20230310/镜像队列.png" alt="RabbitMQ 镜像队列" tabindex="0" loading="lazy"><figcaption>RabbitMQ 镜像队列</figcaption></figure><ol><li>每个镜像队列有一个主节点和多个镜像节点，每个节点都有一个或多个队列副本。</li><li>生产者将消息发送到主节点，主节点将消息复制到所有的镜像节点上的队列副本中。</li><li>消费者可以从任意一个镜像节点上的队列副本中消费消息。</li><li>当主节点宕机时，集群会自动从剩余的镜像节点中选择一个新的主节点。</li><li>当镜像节点宕机时，它上面的队列副本会自动被删除，集群会自动将其从镜像队列的备选节点列表中删除，避免消费者从已经失效的节点上读取消息。</li><li>每个镜像队列的所有节点都应该使用相同的配置，如队列名称、路由键、队列属性等。</li></ol><p><strong>注意点：</strong></p><ol><li>使用镜像队列还需要考虑队列的新增节点、节点失效、选举机制、故障恢复、消息同步等</li><li>镜像队列不可以作为负载均衡使用，因为所有操作在每个节点上都会重复一遍</li></ol><h3 id="gm-模块" tabindex="-1"><a class="header-anchor" href="#gm-模块" aria-hidden="true">#</a> GM 模块</h3><div class="hint-container info"><p class="hint-container-title">GM</p><p>RabbitMQ 的 GM 模块指的是 &quot;Gossip-based Membership&quot;（基于 Gossip 协议的成员管理），它是 RabbitMQ 中集群成员管理的核心组件之一。在 RabbitMQ 集群中，每个节点都需要知道当前集群中的所有节点信息，包括节点的名称、IP 地址、状态等。这些信息的维护和更新需要一个高效、可靠的成员管理系统。</p></div><p><strong>大致流程：</strong></p><p>GM模块实现的一种可靠的组播通讯协议，该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到。它的实现大致如下：</p><p>将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上；当有节点失效时，相邻的节点会接管保证本次广播的消息会复制到所有的节点。在master节点和slave节点上的这些gm形成一个group，group（gm_group）的信息会记录在mnesia中。不同的镜像队列形成不同的group。消息从master节点对于的gm发出后，顺着链表依次传送到所有的节点，由于所有节点组成一个循环链表，master节点对应的gm最终会收到自己发送的消息，这个时候master节点就知道消息已经复制到所有的slave节点了。</p><p><strong>补充：</strong></p><ol><li>GM 模块使用了 Gossip 协议来管理集群的成员。Gossip 协议是一种去中心化的成员管理协议，其核心思想是：每个节点定期随机选择另一个节点并与其进行信息交换，从而逐渐将集群中的所有节点信息传递给所有节点。每个节点通过自己所接收到的其他节点的信息来更新自己的视图，保证视图的一致性。</li><li>在 RabbitMQ 集群中，每个节点都运行一个 GM 模块，GM 模块负责维护节点信息和群集状态。当一个节点启动时，它会通过 GM 模块向集群中的其他节点发送一个 &quot;Hello&quot; 消息，表示自己的加入。其他节点接收到 &quot;Hello&quot; 消息后，将自己的节点信息发送给新加入的节点，并将新节点加入到自己的成员列表中。新节点接收到其他节点的信息后，也会将其加入到自己的成员列表中。这样，新节点就完成了对群集的加入。</li><li>在集群中，如果有节点失效，其他节点会定期发送 &quot;Ping&quot; 消息来检测失效节点。如果在一定时间内没有收到失效节点的响应，则认为该节点已经失效，并将其从成员列表中移除。同时，如果节点发现自己与其他节点的连接出现问题，也会将对应的节点从成员列表中移除。</li><li>GM 模块的使用可以保证 RabbitMQ 集群的可靠性和高可用性，可以有效地解决因节点故障或网络问题导致的集群不可用问题。</li></ol><h2 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h2><h3 id="新增节点" tabindex="-1"><a class="header-anchor" href="#新增节点" aria-hidden="true">#</a> 新增节点</h3><p>如果需要新增节点，可以通过 RabbitMQ 的 Cluster Federation 插件来实现。首先需要在新增节点上安装 Cluster Federation 插件，然后在 RabbitMQ 集群中创建一个 upstream 集群，并将其与新增节点关联。这样一来，当消息发布到 upstream 集群中的某个节点时，会自动将其同步到新增的节点上。</p><h3 id="节点失效" tabindex="-1"><a class="header-anchor" href="#节点失效" aria-hidden="true">#</a> 节点失效</h3><p>当节点失效时，RabbitMQ 镜像队列的机制会自动将该节点上的消息同步到其他节点上，以保证消息不会丢失。同时，如果该节点上的队列已经被声明为镜像队列，那么镜像队列中的副本也会自动被选为主节点，以保证消息能够正常消费。</p><h3 id="选举机制" tabindex="-1"><a class="header-anchor" href="#选举机制" aria-hidden="true">#</a> 选举机制</h3><p>RabbitMQ 镜像队列的选举机制是通过心跳机制来实现的。当一个节点发现另一个节点失效时，会通过心跳机制来判断该节点是否真的失效。如果该节点确实已经失效，那么就会将该节点上的消息同步到其他节点上，并选举一个新的节点作为主节点。</p><h3 id="故障恢复" tabindex="-1"><a class="header-anchor" href="#故障恢复" aria-hidden="true">#</a> 故障恢复</h3><p>如果某个节点在一段时间内无法恢复正常工作，那么 RabbitMQ 镜像队列会自动将该节点上的消息同步到其他节点上。当该节点重新启动后，会自动从其他节点上同步最新的消息，以恢复正常工作。</p><h3 id="消息同步" tabindex="-1"><a class="header-anchor" href="#消息同步" aria-hidden="true">#</a> 消息同步</h3><p>RabbitMQ 镜像队列的消息同步机制是通过 AMQP 协议来实现的。当消息发布到一个节点上时，会自动将该消息同步到其他节点上，以保证消息不会丢失。当消费者订阅一个队列时，会自动从主节点上获取该队列中的消息，而其他节点上的消息仅作为副本备份。</p><h3 id="amqp-与-gossip" tabindex="-1"><a class="header-anchor" href="#amqp-与-gossip" aria-hidden="true">#</a> AMQP 与 Gossip</h3><ol><li><p>AMQP（Advanced Message Queuing Protocol）是一种网络协议，用于在分布式系统中 <strong>传输消息</strong>。RabbitMQ是AMQP的一个实现。</p></li><li><p>而Gossip协议是一个用于在分布式系统中 <strong>传播状态更新</strong> 的协议。GM模块使用的就是Gossip协议来实现 <strong>消息同步机制</strong>。</p></li></ol><p>因此，AMQP和Gossip是两种不同的协议，它们之间没有包含关系。在RabbitMQ中，AMQP协议主要用于客户端和Broker之间的通信，而GM模块使用的Gossip协议则主要用于在Broker之间同步消息状态。</p><h2 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h2>',43),_={class:"hint-container info"},f=i("p",{class:"hint-container-title"},"相关文章（转）",-1),Q={href:"https://blog.csdn.net/u013256816/article/details/71097186",target:"_blank",rel:"noopener noreferrer"},g={href:"https://cloud.tencent.com/developer/article/1754922",target:"_blank",rel:"noopener noreferrer"};function R(m,G){const e=o("router-link"),n=o("ExternalLinkIcon");return s(),d("div",null,[u,p,i("nav",c,[i("ul",null,[i("li",null,[l(e,{to:"#rabbitmq-集群和高可用"},{default:t(()=>[a("RabbitMQ 集群和高可用")]),_:1}),i("ul",null,[i("li",null,[l(e,{to:"#前言"},{default:t(()=>[a("前言")]),_:1}),i("ul",null,[i("li",null,[l(e,{to:"#何如实现高可用"},{default:t(()=>[a("何如实现高可用？")]),_:1})]),i("li",null,[l(e,{to:"#实现一般步骤"},{default:t(()=>[a("实现一般步骤")]),_:1})]),i("li",null,[l(e,{to:"#优缺点"},{default:t(()=>[a("优缺点")]),_:1})])])]),i("li",null,[l(e,{to:"#镜像队列"},{default:t(()=>[a("镜像队列")]),_:1}),i("ul",null,[i("li",null,[l(e,{to:"#gm-模块"},{default:t(()=>[a("GM 模块")]),_:1})])])]),i("li",null,[l(e,{to:"#注意点"},{default:t(()=>[a("注意点")]),_:1}),i("ul",null,[i("li",null,[l(e,{to:"#新增节点"},{default:t(()=>[a("新增节点")]),_:1})]),i("li",null,[l(e,{to:"#节点失效"},{default:t(()=>[a("节点失效")]),_:1})]),i("li",null,[l(e,{to:"#选举机制"},{default:t(()=>[a("选举机制")]),_:1})]),i("li",null,[l(e,{to:"#故障恢复"},{default:t(()=>[a("故障恢复")]),_:1})]),i("li",null,[l(e,{to:"#消息同步"},{default:t(()=>[a("消息同步")]),_:1})]),i("li",null,[l(e,{to:"#amqp-与-gossip"},{default:t(()=>[a("AMQP 与 Gossip")]),_:1})])])]),i("li",null,[l(e,{to:"#补充"},{default:t(()=>[a("补充")]),_:1})])])])])]),M,i("div",_,[f,i("p",null,[i("a",Q,[a("RabbitMQ之镜像队列 – CSDN 朱小厮 原创"),l(n)])]),i("p",null,[i("a",g,[a("搭建高可用/高可靠的RabbitMQ镜像队列集群架构 – 腾讯云开发者社区 端碗吹水"),l(n)])])])])}const x=r(b,[["render",R],["__file","G-RabbitMQ集群与高可用.html.vue"]]);export{x as default};
