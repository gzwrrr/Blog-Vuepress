import{_ as t,Q as r,S as d,U as l,W as a,X as o,a8 as i,a9 as n,H as c}from"./framework-d7e1aa10.js";const s={},u=l("h1",{id:"jvm-常见问题",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#jvm-常见问题","aria-hidden":"true"},"#"),i(" JVM 常见问题")],-1),h={class:"table-of-contents"},p=n('<h2 id="tomcat-中为什么使用自定义类加载器" tabindex="-1"><a class="header-anchor" href="#tomcat-中为什么使用自定义类加载器" aria-hidden="true">#</a> Tomcat 中为什么使用自定义类加载器</h2><p><code>Tomcat</code> 中可以部署多个应用，每个应用中都存在许多类，并且各个应用中的类是独立的，但是其全类名是可以 <strong>相同的</strong>，使用自定义类加载器可以避免至加载一个类，做法就是为部署的 <strong>每个应用都生成一个类加载器示例</strong>，名称为 <code>WebAppClassLoader</code></p><p>另外 <code>Tomcat</code> 还利用自定义加载器实现了 <strong>热加载</strong> 功能</p><h2 id="如何排查-jvm-问题" tabindex="-1"><a class="header-anchor" href="#如何排查-jvm-问题" aria-hidden="true">#</a> 如何排查 JVM 问题</h2><p><strong>对于还在正常运行的系统：</strong></p><ol><li>可以使用 jmap 来查看 JVM 中各个区域的情况</li><li>可以通过 jstack 来查看线程的运行情况，比如哪些线程阻塞了，哪些线程死锁了</li><li>可以通过 jstat 命令来查看垃圾回收情况，特别是 fullgc，如果发现 fullgc 比较频繁，那么就需要调优</li><li>通过各个命令的结果，使用 jvisualvm 等工具进行分析</li><li>可以初步猜测是频繁 fullgc 的原因，此时可能一直没有内存溢出，表示此时实际上回收了很多对象，所以这些对象最好能够是在 younggc 阶段就直接回收，避免这些对象进入老年代。对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，从而导致年轻代放不下就直接到了老年代，此时可以加大年轻代的大小，改完后如果 fullgc 减少说明有效</li><li>还可以找到占用 CPU 最多的线程，定位到具体的方法，优化这个方法的执行，看看是否能避免创建某些对象，从而节省内存</li></ol><p><strong>对于已经发生了 OOM 的系统：</strong></p><ol><li>一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件（<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base</code>）</li><li>可以利用 jvisualvm 工具来分析 dump 文件</li><li>根据 dump 文件找到发生异常的示例对象，和异常的线程（占用 CPU 高），定位到具体的代码</li></ol><p>调优不是一蹴而就，需要分析、推理、实践、总结再分析，最终定位到具体问题</p><h2 id="一个对象加载到-jvm-再到被-gc-清除-都经历了什么过程" tabindex="-1"><a class="header-anchor" href="#一个对象加载到-jvm-再到被-gc-清除-都经历了什么过程" aria-hidden="true">#</a> 一个对象加载到 JVM 再到被 GC 清除，都经历了什么过程？</h2><ol><li>首先是把字节码文件的内容加载到方法区</li><li>然后根据类信息在堆区创建对象</li><li>对象首先会分配在堆区中年轻代的伊甸园区，经过以此 Minor GC 之后，对象如果还存会，就会进入幸存者区。后续的还会发生若干次 Minor GC，如果对象一直存活着，那么就会在幸存者区来回拷贝，每移动一次，年龄就会加一</li><li>当年龄大于 15 后，如果对象依然存活，对象就会进入老年代</li><li>如果经过 Full GC，被标记成为了垃圾对象，那么就会被 GC 线程清理掉</li></ol><h2 id="怎么确定一个对象是否为垃圾" tabindex="-1"><a class="header-anchor" href="#怎么确定一个对象是否为垃圾" aria-hidden="true">#</a> 怎么确定一个对象是否为垃圾？</h2><ol><li>引用计数算法：这种方式是给堆内存中的每个对象记录一个引用值，引用这个数为 0 就被认为是垃圾。这是早期 JDK 使用的方式。但是注意：引用计数无法解决循环引用的问题</li><li>可达性算法：这种方式是在内存中的，从跟对象一直向下找引用，找到的对象就不是垃圾，没有找到的对象就是垃圾</li></ol><h2 id="jvm-有哪些垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#jvm-有哪些垃圾回收算法" aria-hidden="true">#</a> JVM 有哪些垃圾回收算法？</h2><p><strong>主要有三种：</strong></p><ol><li><p>标记清除算法：</p><ul><li><p>标记阶段：把垃圾内存标记出来</p></li><li><p>清理阶段：直接将垃圾内存回收</p></li><li><p>这种算法比较简单，但是会产生大量的 <strong>内存碎片</strong></p></li></ul></li><li><p>复制算法：</p><ul><li><p>为了解决标记算法产生的内存碎片问题，就有了复制算法</p></li><li><p>复制算法将内存分为大小相等的两部分，每次只使用其中的一半</p></li><li><p>垃圾回收时，将当前这一块的存活对象全部拷贝到另外一半，然后当前着一半内存就直接清除</p></li><li><p>这种方法没有内存碎片，但是很浪费空间，而且效率跟存活的对象数量有关</p></li></ul></li><li><p>标记压缩算法：</p><ul><li>为了解决复制算法的缺陷，就有了标记压缩算法</li><li>这种算法在标记阶段跟标记清除算法时一样的</li><li>但是完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将边界以外的所有内存直接清除</li></ul></li></ol><h2 id="什么是-stw" tabindex="-1"><a class="header-anchor" href="#什么是-stw" aria-hidden="true">#</a> 什么是 STW？</h2><ul><li>STW：Stop-The-World，是在垃圾回收算法执行过程中，需要将 JVM 内存 <strong>冻结</strong> 的一种状态</li><li>在此状态下，java 所有线程都是停止执行的（除了 GC 线程外和 native 方法），并且不能跟 JVM 交互</li><li>各种 GC 算法优化的重点，就是减少 STW，同时这也是 JVM 调优的重点</li></ul><h2 id="jvm-参数有哪些" tabindex="-1"><a class="header-anchor" href="#jvm-参数有哪些" aria-hidden="true">#</a> JVM 参数有哪些？</h2><p><strong>大致可以分为三类：</strong></p><ol><li>标注指令：<code>-</code> 开头，这些是所有的 HotSpot 都支持的参数 ，可以使用 <code>java -help</code> 打印出来</li><li>非标注指令：<code>-X</code> 开头，这些指令通常是跟特定的 HotSpot 版本对应的，可以使用 <code>java -X</code> 打印出来</li><li>不稳定参数：<code>-XX</code> 开头，这一类参数是跟特定的 HotSpot 版本对应的，并且变化非常大</li></ol>',21);function m(_,f){const e=c("router-link");return r(),d("div",null,[u,l("nav",h,[l("ul",null,[l("li",null,[a(e,{to:"#jvm-常见问题"},{default:o(()=>[i("JVM 常见问题")]),_:1}),l("ul",null,[l("li",null,[a(e,{to:"#tomcat-中为什么使用自定义类加载器"},{default:o(()=>[i("Tomcat 中为什么使用自定义类加载器")]),_:1})]),l("li",null,[a(e,{to:"#如何排查-jvm-问题"},{default:o(()=>[i("如何排查 JVM 问题")]),_:1})]),l("li",null,[a(e,{to:"#一个对象加载到-jvm-再到被-gc-清除-都经历了什么过程"},{default:o(()=>[i("一个对象加载到 JVM 再到被 GC 清除，都经历了什么过程？")]),_:1})]),l("li",null,[a(e,{to:"#怎么确定一个对象是否为垃圾"},{default:o(()=>[i("怎么确定一个对象是否为垃圾？")]),_:1})]),l("li",null,[a(e,{to:"#jvm-有哪些垃圾回收算法"},{default:o(()=>[i("JVM 有哪些垃圾回收算法？")]),_:1})]),l("li",null,[a(e,{to:"#什么是-stw"},{default:o(()=>[i("什么是 STW？")]),_:1})]),l("li",null,[a(e,{to:"#jvm-参数有哪些"},{default:o(()=>[i("JVM 参数有哪些？")]),_:1})])])])])]),p])}const v=t(s,[["render",m],["__file","Z-JVM常见问题.html.vue"]]);export{v as default};
