import{_ as i,Q as u,S as r,U as n,W as a,X as t,a8 as s,a9 as p,H as o}from"./framework-d7e1aa10.js";const d={},k=n("h1",{id:"java-并发常见问题",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#java-并发常见问题","aria-hidden":"true"},"#"),s(" Java 并发常见问题")],-1),h={class:"table-of-contents"},m=p(`<p>这里简略回答，详细自行查找</p><h2 id="创建线程池的方式" tabindex="-1"><a class="header-anchor" href="#创建线程池的方式" aria-hidden="true">#</a> 创建线程池的方式</h2><ol><li>继承 <code>Thread</code> 类</li><li>实现 <code>Runnable</code> 接口</li><li>实现 <code>Callable&lt;T&gt;</code> 接口，配合 <code>FutureTask&lt;V&gt;</code> 类</li><li>线程池创建</li></ol><h2 id="为什么不建议使用-executors-创建线程池" tabindex="-1"><a class="header-anchor" href="#为什么不建议使用-executors-创建线程池" aria-hidden="true">#</a> 为什么不建议使用 Executors 创建线程池？</h2><p>底层使用 <code>ThreadPoolExecutor</code> 创建，其中 <code>LinkedBlockingQueue&lt;Runnable&gt;()</code> 是一个<mark>无界阻塞队列</mark>，任务过多时会不断将任务添加到队列中，最终可能耗尽内存，<mark>导致 OOM</mark></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                  <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样地，使用其他的例如 <code>Executors.newSingleThreadExecutor</code>，也会有相同问题</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际生产中更建议直接使用 <code>ThreadPoolExecutor</code> 定义线程池，这样可以更加灵活地控制</p><h2 id="线程池的状态" tabindex="-1"><a class="header-anchor" href="#线程池的状态" aria-hidden="true">#</a> 线程池的状态</h2><ol><li>RUNNING</li><li>SHUTDOWN</li><li>STOP</li><li>TIDYING</li><li>TERMINATED</li></ol><h2 id="sychronized-和-reentrantlock-的不同点" tabindex="-1"><a class="header-anchor" href="#sychronized-和-reentrantlock-的不同点" aria-hidden="true">#</a> Sychronized 和 ReentrantLock 的不同点</h2><div class="table-wrapper"><table><thead><tr><th>Sychronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>Java 中的关键字</td><td>JDK 提供的类</td></tr><tr><td>自动加锁和自动释放锁</td><td>需要手动加锁和手动释放锁</td></tr><tr><td>JVM 层面的锁</td><td>API 层面的锁</td></tr><tr><td>非公平锁</td><td>公平锁或非公平锁</td></tr><tr><td>锁的是对象，锁信息保存在对象头中</td><td>int 类型的 state 标识来标识锁的状态</td></tr><tr><td>底层有锁升级</td><td>没有锁升级过程</td></tr></tbody></table></div><h2 id="threadlocal-有哪些应用场景-底层如何实现" tabindex="-1"><a class="header-anchor" href="#threadlocal-有哪些应用场景-底层如何实现" aria-hidden="true">#</a> ThreadLocal 有哪些应用场景？底层如何实现？</h2><p>Java 中提供的<mark>线程本地存储机制</mark>，可以利用该机制<mark>将数据缓存在某个线程内部</mark>，该线程可以在任意时刻、任意方法中获取缓存的数据</p><p>底层是通过 <code>ThreadLocalMap</code> 实现的，key 为 <code>ThreadLocal</code> 对象，value 是需要缓存的值：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */</span>
<span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是注意：如果在线程池中使用 <code>ThreadLocal</code> 会造成内存泄露，因为线程池不会回收 <code>ThreadLocal</code> 对象的 <code>Entry</code> 对象。并且线程对象是通过强引用指向 <code>ThreadLocalMap</code> 的，而 <code>ThreadLocalMap</code> 是通过强引用指向 <code>Entry</code> 对象的，这样只要线程不被回收， <code>Entry</code> 对象就不会被回收，从而导致<mark>内存泄露</mark></p><p>解决方案：使用了 <code>ThreadLocal</code> 对象后手动调用 <code>remove()</code> 方法，手动清除 <code>Entry</code> 对象</p><p><code>ThreadLocal</code> 经典的应用场景就是 <strong>连接管理</strong>，即一个线程持有一个连接，该连接对象可以在不同的方法之间进行 <strong>传递</strong>，而线程之间不共享同一个连接</p><h2 id="reentrantlock-分为公平锁和非公平锁-底层分别怎么实现" tabindex="-1"><a class="header-anchor" href="#reentrantlock-分为公平锁和非公平锁-底层分别怎么实现" aria-hidden="true">#</a> ReentrantLock 分为公平锁和非公平锁，底层分别怎么实现？</h2><p>两种的底层<mark>都是使用 AQS 进行排队</mark>，区别在于线程加锁时：</p><ol><li>如果是公平锁，会先检查 AQS 队列是否存在线程在排队，如果有线程在排队，那么当前线程也排队</li><li>如果是非公平锁，不会检查是否排队，而是会直接竞争锁</li></ol><p>所以，两种锁一旦没有竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的锁</p><p>非公平锁知识体现在了线程加锁阶段，而没有体现在线程唤醒阶段</p><p><strong>注意：ReentrantLock 是可重入锁，不管是公平锁还是非公平锁都是可重入的</strong></p><h2 id="reentrantlock-中的-trylock-和-lock-方法的区别" tabindex="-1"><a class="header-anchor" href="#reentrantlock-中的-trylock-和-lock-方法的区别" aria-hidden="true">#</a> Reentrantlock 中的 tryLock 和 lock 方法的区别</h2><ol><li><code>tryLock()</code> 表示尝试加锁，可以加上锁也可能加不上，<strong>该方法不会阻塞线程</strong>，如果获取到锁就返回 <code>true</code>，否则返回 <code>false</code></li><li><code>lock()</code> 表示 <strong>阻塞加锁</strong>，线程会阻塞直到加上锁，该方法没有返回值</li></ol><h2 id="sychronized-的锁升级过程" tabindex="-1"><a class="header-anchor" href="#sychronized-的锁升级过程" aria-hidden="true">#</a> Sychronized 的锁升级过程</h2>`,29),v=p(`<ol><li>偏向锁：锁对象的对象头中获取线程 ID，该线程下次如果又来获取该锁就可以直接获取到，也就是支持锁重入</li><li>轻量级锁：当一个线程获取到锁后，先是称为偏向锁，如果有第二个线程来竞争，就升级成轻量级锁，底层是由自旋来实现的，<strong>不会阻塞线程</strong></li><li>重量级锁：如果自旋次数过多还没有获取锁，则会升级成重量级锁，重量级锁会导致线程阻塞</li></ol><p>自旋锁通过自旋不阻塞线程，也就无所谓唤醒线程。自旋锁是线程通过 CAS 获取预取的标记，如果没有获取到就会循环获取，因此线程是在一直运行着的，但是相对阻塞来说还是比较轻量的</p><p>阻塞和唤醒这两个步骤都是需要 <strong>操纵系统</strong> 进行操作的，比较消耗时间</p><h2 id="说说对线程安全的理解" tabindex="-1"><a class="header-anchor" href="#说说对线程安全的理解" aria-hidden="true">#</a> 说说对线程安全的理解</h2><p>线程安全一般是指我们写的某段代码，在多个线程同时执行的情况下也能有正常的结果，即不会混乱</p><p>比如执行 <code>i++</code> ，初始值为 0，如果线程安全那么线程一和线程二同时执行后结果应当是，一个线程为 <code>i=1</code>；另一个 <code>i=2</code>，如果不是这样的结果说明线程不安全</p><h2 id="说说对守护线程的理解" tabindex="-1"><a class="header-anchor" href="#说说对守护线程的理解" aria-hidden="true">#</a> 说说对守护线程的理解</h2><ul><li>线程分为 <strong>用户线程</strong> 和 <strong>守护线程</strong></li><li>用户线程就是普通线程；守护线程就是 JVM 的后台线程</li><li>比如垃圾回收线程就是一个守护线程，守护线程会在其他普通线程都停止运行之后自动关闭</li><li>可以通过 <code>thread.setDaemon(true)</code> 来把一个线程设置成守护线程</li></ul><h2 id="并发、并行、串行之间的区别" tabindex="-1"><a class="header-anchor" href="#并发、并行、串行之间的区别" aria-hidden="true">#</a> 并发、并行、串行之间的区别</h2><ol><li>串行：一个任务执行完才能执行下一个任务</li><li>并行：两个任何同时执行</li><li>并发：两个任务整体开上去是同时执行的，但是在底层是被切分成了很多份，然后在不同的时间片执行不同的部分，这样处理起来在整体上就像同时发生的</li></ol><h2 id="java-死锁如何避免" tabindex="-1"><a class="header-anchor" href="#java-死锁如何避免" aria-hidden="true">#</a> Java 死锁如何避免</h2><p><strong>造成死锁的几个原因：</strong></p><ol><li>一个资源每次只能被一个线程使用</li><li>一个线程在阻塞等待某个资源时，不是放已经占有的资源</li><li>一个线程已经获取了资源，在未使用完之前不能被强行剥夺</li><li>若干线程形成头尾相接的循环等待资源关系</li></ol><p>前三个条件是 <strong>锁必须满足的条件</strong>，要避免死锁就要打破第 4 个条件，即不出现循环等待的情况</p><p><strong>具体开发中就是：</strong></p><ol><li>要注意加锁顺序：保证每个线程按同样的顺序加锁</li><li>要注意加锁时限：可以针对锁设置一个 <strong>超时时间</strong></li><li>要注意死锁检查：这是一种预防机制，确保在第一时间发现死锁并解决</li></ol><h2 id="线程池的底层工作原理" tabindex="-1"><a class="header-anchor" href="#线程池的底层工作原理" aria-hidden="true">#</a> 线程池的底层工作原理</h2><p>当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么这个任务就放入队列，队列满了之后，才会新开线程</p><p>线程池内部时通过「队列」+「线程」实现的，当利用线程池执行任务时：</p><ol><li>线程数量小于 <code>corePoolSize</code> 时，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务</li><li>线程数量等于 <code>corePoolSize</code> 时，如果缓冲队列 <code>workQueue</code> 未满，那么任务会被放进缓冲队列</li><li>线程数量大于 <code>corePoolSize</code> 时，如果缓冲队列 <code>workQueue</code> 已满，并且线程池中的数量小于 <code>maximunPoolSize</code>，那么就建立新的线程来处理此任务</li><li>线程数量大于 <code>corePoolSize</code> 时，如果缓冲队列 <code>workQueue</code> 已满，并且线程池中的数量等于 <code>maximunPoolSize</code>，那么通过 <code>handler</code> 所指定的策略来处理此任务</li><li>线程数量大于 <code>corePoolSize</code> 时，如果某线程空闲时间超过 <code>keepAliveTime</code>，线程将被终止。这样，线程池可以动态动态地调整池中的线程数</li></ol><h2 id="countdownlatch-和-semaphore-的区别和底层原理" tabindex="-1"><a class="header-anchor" href="#countdownlatch-和-semaphore-的区别和底层原理" aria-hidden="true">#</a> CountDownLatch 和 Semaphore 的区别和底层原理</h2><p><code>CountDownLatch</code>和<code>Semaphore</code>都是Java中用于控制线程同步的工具类，它们的作用都是控制并发线程的数量，但是它们的实现方式和应用场景有所不同。</p><h3 id="countdownlatch" tabindex="-1"><a class="header-anchor" href="#countdownlatch" aria-hidden="true">#</a> CountDownLatch</h3><p><code>CountDownLatch</code>是一个计数器，它的作用是让一个或多个线程等待一个或多个线程完成操作，然后再继续执行。它的实现原理是一个线程等待多个线程的信号，当多个线程完成某项任务时，计数器减1，当计数器减为0时，等待的线程就可以继续执行了。</p><p>下面是一个简单的<code>CountDownLatch</code>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>javaCopy codeimport <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>CountDownLatch</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 模拟耗时操作</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;执行完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;Thread-&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;等待&quot;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&quot;个线程执行完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;所有线程执行完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，创建了5个线程模拟耗时操作，等待所有线程执行完成之后输出“所有线程执行完成”。</p><h3 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore" aria-hidden="true">#</a> Semaphore</h3><p><code>Semaphore</code>是一个信号量，它的作用是控制同时访问某个资源的线程数量。例如，一个数据库连接池可以使用<code>Semaphore</code>来限制访问数据库的线程数量。</p><p><code>Semaphore</code>的实现原理是，它维护了一个许可证的数量，线程需要获取许可证才能访问资源。当线程访问资源完成之后，需要释放许可证，许可证数量加1。</p><p>下面是一个简单的<code>Semaphore</code>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>javaCopy codeimport <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span>Semaphore</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;获取到许可证&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;释放许可证&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;Thread-&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，创建了10个线程，但是<code>Semaphore</code>的许可证数量只有5个。因此，只有5个线程能够获取到许可证并执行操作，其它线程需要等待许可证被释放之后才能</p><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2>`,34),b={href:"https://www.geeksforgeeks.org/future-and-futuretask-in-java/",target:"_blank",rel:"noopener noreferrer"};function w(f,g){const e=o("router-link"),c=o("Mermaid"),l=o("ExternalLinkIcon");return u(),r("div",null,[k,n("nav",h,[n("ul",null,[n("li",null,[a(e,{to:"#java-并发常见问题"},{default:t(()=>[s("Java 并发常见问题")]),_:1}),n("ul",null,[n("li",null,[a(e,{to:"#创建线程池的方式"},{default:t(()=>[s("创建线程池的方式")]),_:1})]),n("li",null,[a(e,{to:"#为什么不建议使用-executors-创建线程池"},{default:t(()=>[s("为什么不建议使用 Executors 创建线程池？")]),_:1})]),n("li",null,[a(e,{to:"#线程池的状态"},{default:t(()=>[s("线程池的状态")]),_:1})]),n("li",null,[a(e,{to:"#sychronized-和-reentrantlock-的不同点"},{default:t(()=>[s("Sychronized 和 ReentrantLock 的不同点")]),_:1})]),n("li",null,[a(e,{to:"#threadlocal-有哪些应用场景-底层如何实现"},{default:t(()=>[s("ThreadLocal 有哪些应用场景？底层如何实现？")]),_:1})]),n("li",null,[a(e,{to:"#reentrantlock-分为公平锁和非公平锁-底层分别怎么实现"},{default:t(()=>[s("ReentrantLock 分为公平锁和非公平锁，底层分别怎么实现？")]),_:1})]),n("li",null,[a(e,{to:"#reentrantlock-中的-trylock-和-lock-方法的区别"},{default:t(()=>[s("Reentrantlock 中的 tryLock 和 lock 方法的区别")]),_:1})]),n("li",null,[a(e,{to:"#sychronized-的锁升级过程"},{default:t(()=>[s("Sychronized 的锁升级过程")]),_:1})]),n("li",null,[a(e,{to:"#说说对线程安全的理解"},{default:t(()=>[s("说说对线程安全的理解")]),_:1})]),n("li",null,[a(e,{to:"#说说对守护线程的理解"},{default:t(()=>[s("说说对守护线程的理解")]),_:1})]),n("li",null,[a(e,{to:"#并发、并行、串行之间的区别"},{default:t(()=>[s("并发、并行、串行之间的区别")]),_:1})]),n("li",null,[a(e,{to:"#java-死锁如何避免"},{default:t(()=>[s("Java 死锁如何避免")]),_:1})]),n("li",null,[a(e,{to:"#线程池的底层工作原理"},{default:t(()=>[s("线程池的底层工作原理")]),_:1})]),n("li",null,[a(e,{to:"#countdownlatch-和-semaphore-的区别和底层原理"},{default:t(()=>[s("CountDownLatch 和 Semaphore 的区别和底层原理")]),_:1}),n("ul",null,[n("li",null,[a(e,{to:"#countdownlatch"},{default:t(()=>[s("CountDownLatch")]),_:1})]),n("li",null,[a(e,{to:"#semaphore"},{default:t(()=>[s("Semaphore")]),_:1})])])]),n("li",null,[a(e,{to:"#其他"},{default:t(()=>[s("其他")]),_:1})])])])])]),m,a(c,{id:"mermaid-207",code:"eJxLy8kvT85ILCpRCHHiUlAoLk1KL0osyFB4OaXxaW/7813LX+xvf76iGyj1tLH/6YSJQHEFXV07hRd7d79s7wfKwwRetvfCBYCqU/NSuAD3PS0z"}),v,n("ol",null,[n("li",null,[n("a",b,[s("Future and FutureTask"),a(l)])])])])}const x=i(d,[["render",w],["__file","Z-Java并发常见问题.html.vue"]]);export{x as default};
