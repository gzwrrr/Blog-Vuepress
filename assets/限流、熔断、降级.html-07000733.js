import{_ as e,Q as a,S as t,a9 as o}from"./framework-d7e1aa10.js";const r={},c=o('<h1 id="限流、熔断、降级" tabindex="-1"><a class="header-anchor" href="#限流、熔断、降级" aria-hidden="true">#</a> 限流、熔断、降级</h1><h2 id="限流" tabindex="-1"><a class="header-anchor" href="#限流" aria-hidden="true">#</a> 限流</h2><blockquote><p>限流分为：单机/单应用限流、分布式/全局限流</p></blockquote><p>最常用的限流算法：</p><ol><li>令牌桶（Token Bucket）：系统按照固定速率往桶里放入令牌（Token），当满了就不再添加，每个请求拿走一个 Token，空了就拒绝服务，特点是允许突发流量</li><li>漏桶（Leaky Bucket）：请求以一定速率流出桶（即响应速率），过快会直接溢出（拒绝服务，强行限制数据的传输速度），特点是对突发性的流量缺乏效率（平滑处理流量）</li><li>计数器算法：可以使用原子类限制并发情况下的最大请求出，超出直接拒绝请求；也可以使用信号量控制，超出进入阻塞队列</li></ol><h2 id="熔断-降级" tabindex="-1"><a class="header-anchor" href="#熔断-降级" aria-hidden="true">#</a> 熔断 &amp; 降级</h2><p>在高并发情况下，因为服务之间的依赖关系导致调用失败时，通常步骤为：限流、熔断、隔离、降级，这样可以防止雪崩效应</p>',7),i=[c];function n(_,h){return a(),t("div",null,i)}const l=e(r,[["render",n],["__file","限流、熔断、降级.html.vue"]]);export{l as default};
