import{_ as n,Q as s,S as a,U as t,W as i,X as o,a8 as l,a9 as _,H as d}from"./framework-d7e1aa10.js";const c={},p=t("h1",{id:"脏读-不可重复读-幻读",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#脏读-不可重复读-幻读","aria-hidden":"true"},"#"),l(" 脏读/不可重复读/幻读")],-1),h={class:"table-of-contents"},u=_('<div class="table-wrapper"><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不能重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>READ COMMITTED</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>REPEATABLE READ</td><td>否</td><td>否</td><td>是（innodb 除外）</td><td>否</td></tr><tr><td>SERIALIZABLE</td><td>否</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></div><ul><li><p>脏读：</p><ul><li>事务读取到其他事务没提交的数据（针对某个字段）</li></ul></li><li><p>不可重复读：</p><ul><li>指同一次事务中前后查询不一致的问题（针对某个字段）</li><li>即在并发更新时，另一个事务前后查询相同数据时不符合预期</li></ul></li><li><p>幻读：</p><ul><li>一次事务中前后数据量发生变化（针对某几行数据）</li><li>即在并发新增、删除这种会产生数量变化的操作时，另一个事务亲啊后查询相同数据时不符合预期</li></ul></li></ul><p><strong>PR 级别解决幻读问题：</strong></p><p>MySQL 5.1 以上默认使用 innodb，事务隔离级别为可重复读（REPEATABLE READ），但是由于 MVCC（Multi-Version Concurrency Control，多版本并发控制方案），这里的可重复读也可以解决幻读的问题；MVCC 核心为 UNDO_LOG 版本链和 ReadView 快照读（见下文的补充）</p><ul><li><p>UNDO_LOG 版本链使用链表的形式维护数据的历史版本，用于回滚，MySQL 在确保版本链数据不在被引用后才将其删除</p></li><li><p>ReadView 快照读是 SQL 执行时 MVCC 提取数据的依据；</p></li><li><p>【快照读】就是最普通的 Select 查询的 SQL 语句：【当前读】指代写操作对应的 SQL 语句，这时会加上写锁；只有【快照读】才会使用 MVCC，【当前读】会使用行锁与间隙锁</p></li><li><p>当使用 MVCC 时会访问 UNDO_LOG，根据 ReadView 中的数据与访问规则查找 UNDO_LOG 中的数据</p></li><li><p>但是其实 PR 级别下使用 MVCC 不能完全保证消除幻读</p><ul><li>当连续产生多次快照时，ReadView 会产生复用，没有幻读的问题</li><li>当两次快照之间存在【当前读】，ReadView 会重新生成，此时可能产生幻读</li></ul></li></ul><h1 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h1><p>**MVCC：**就是为了尽可能不加锁实现 <strong>读-写分离</strong>，读指快照读（非当前读，当前读要悲观加锁），当然这样读到的数据可能不是最新的，并且不能解决更新丢失问题<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>（第一类更新丢失和第二类更新丢失）</p><ul><li><strong>MVCC + 悲观锁</strong> MVCC解决读写冲突，悲观锁解决写写冲突</li><li><strong>MVCC + 乐观锁</strong> MVCC解决读写冲突，乐观锁解决写写冲突</li></ul><p><strong>UNDO_LOG 版本链的节点的数据结构包含四个字段：</strong></p><ul><li>id：标识</li><li>字段名：当前数据对应的字段名</li><li>trx_id：对应 ReadView 中的 trx_id</li><li>db_roll_ptr： next 指针</li></ul><p><strong>ReadView 的数据结构包含四个字段：</strong></p><ul><li><p>m_ids：当前活跃的事务编号集合，即还没有被提交的事务</p></li><li><p>min_trx_id：最小活跃事务编号</p></li><li><p>max_trx_id：预分配事务编号，当前最大事务编号 + 1</p></li><li><p>creator_trx_id： ReadView 创建者的事务编号</p></li></ul><p><strong>UNDO_LOG 版本链的访问规则：</strong></p><ul><li>当前事务 trx_id 等于 creator_trx_id 时，说明这个数据是自己修改的，可以访问</li><li>当 trx_id 小于 min_trx_id 时，说明数据已经提交，可以访问</li><li>当 trx_id 大于 max_trx_id时，说明该事务是 ReadView 生成之后才开启的，不允许访问</li><li>当 min_trx_id &lt;= trx_id &lt;= max_trx_id 时，与 m_ids 中的事务比对，当 trx_id 不在m_ids 中时说明 trx_id 对应的已经提交，可以访问</li></ul><br><br><br><hr class="footnotes-sep">',18),f={class:"footnotes"},x={class:"footnotes-list"},C={id:"footnote1",class:"footnote-item"},V={href:"https://blog.csdn.net/paopaopotter/article/details/79259686",target:"_blank",rel:"noopener noreferrer"},m=t("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1);function M(R,b){const e=d("router-link"),r=d("ExternalLinkIcon");return s(),a("div",null,[p,t("nav",h,[t("ul",null,[t("li",null,[i(e,{to:"#脏读-不可重复读-幻读"},{default:o(()=>[l("脏读/不可重复读/幻读")]),_:1})]),t("li",null,[i(e,{to:"#补充"},{default:o(()=>[l("补充")]),_:1})])])]),u,t("section",f,[t("ol",x,[t("li",C,[t("p",null,[t("a",V,[l("第一、二类更新丢失相关文章"),i(r)]),l(),m])])])])])}const L=n(c,[["render",M],["__file","脏读-不可重复读-幻读.html.vue"]]);export{L as default};
