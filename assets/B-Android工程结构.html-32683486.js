import{_ as u,Q as p,S as _,U as e,W as i,X as t,a8 as l,a9 as a,H as r}from"./framework-d7e1aa10.js";const f={},g=e("h1",{id:"android-工程结构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#android-工程结构","aria-hidden":"true"},"#"),l(" Android 工程结构")],-1),b={class:"table-of-contents"},m=a('<h2 id="项目层次" tabindex="-1"><a class="header-anchor" href="#项目层次" aria-hidden="true">#</a> 项目层次</h2><p>两个层次（一个项目中有多个模块）：项目、模块；项目结构如下：</p><p><strong>app：</strong></p><ol><li>manifests：AndroidManifest.xml</li><li>java：源码 + 单元测试</li><li>res：当前模块的资源文件 <ol><li>drawable：绘制的图像、可以适配</li><li>layout：项目布局</li><li>mipmap：存放 APP 图标（矢量图标）</li><li>values：颜色值、主题</li></ol></li></ol><p><strong>gradle script：</strong></p><ol><li><code>build.gradle</code>：分为项目和模块，用于描述 APP 工程的编译规则</li><li><code>proguard-rules.pro</code>：混淆规则</li><li><code>gradle.properties</code>：环境变量</li><li><code>settings.gradle</code>：配置需要编译的模块，初始内容为 <code>include &#39;:app&#39;</code>，表示只编译 APP 模块</li><li><code>local.properties</code>：项目的本地配置文件，在项目编译时自动生成，描述了本地开发环境的配置信息</li></ol><h2 id="编译打包" tabindex="-1"><a class="header-anchor" href="#编译打包" aria-hidden="true">#</a> 编译打包</h2><p>注意点：编译工具版本需要和构建工具版本匹配</p><p>应用元数据（defaultConfig）</p><ol><li><code>applicationId</code>：APP 包名</li><li><code>minSdkVersion</code>：最小版本号</li><li><code>targetSdkVersion</code>：期望运行版本号</li><li><code>versionCode</code>：APP 应用的版本号</li><li><code>versionName</code>：APP 应用的版本名称</li></ol><h2 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h2>',11),v={class:"hint-container info"},A=e("p",{class:"hint-container-title"},"相关文章",-1),B={href:"https://github.com/LiushuiXiaoxia/AndroidModular/blob/master/README2.md#%E5%85%B3%E4%BA%8Eandroid%E6%A8%A1%E5%9D%97%E5%8C%96%E6%88%91%E6%9C%89%E4%B8%80%E4%BA%9B%E8%AF%9D%E4%B8%8D%E7%9F%A5%E5%BD%93%E8%AE%B2%E4%B8%8D%E5%BD%93%E8%AE%B2",target:"_blank",rel:"noopener noreferrer"},E={href:"https://www.51cto.com/article/523490.html",target:"_blank",rel:"noopener noreferrer"},x=e("li",null,[e("p",null,"MVP模式、MVVM模式")],-1),k=e("li",null,[e("p",null,"模块化、插件化、独立发布")],-1),P={href:"https://github.com/alibaba/BeeHive",target:"_blank",rel:"noopener noreferrer"},M=a('<details class="hint-container details"><summary>Beehive</summary><p>Beehive的原理是，每一个对外提供服务的模块，需要注册一个抽象接口到Beehive提供的Interfaces(接口池)。注意，在这个池子里只有抽象接口。</p><p>开发阶段，调用方依赖接口池中响应的接口，并以接口为参数，通过Beehive提供的工厂方法获取一个服务实例，这个实例可以正常进行服务。</p><p>运行时阶段，Beehive工厂方法根据服务的注册配置，构造服务实例。若：当前的运行环境没有依赖提供服务的模块，则返回空;若：当前运行环境依赖关系完整，则开始构造服务，并返回。</p></details><h3 id="拆分" tabindex="-1"><a class="header-anchor" href="#拆分" aria-hidden="true">#</a> 拆分</h3><p><strong>整个模式升级基本上经历了这样几个阶段：</strong></p><ul><li>代码独立，先从形式上解耦</li><li>独立代码工程化，为独立运行打下基础</li><li>梳理依赖关系，独立工程可编译</li><li>放弃源码依赖，提速集成编译</li></ul><br><p><strong>把耦合分成三类：</strong></p><ol><li>界面耦合，就是用户操作流程里，从首页-到搜索-到详情-再进店，这些界面的跳转是硬编码的</li><li>依赖耦合，顾名思义，两个模块之间的有依赖，就是耦合</li><li>工程耦合，每个模块有自己的生命周期和运行时，每个模块在生产环境里又需要依赖主工程的运行时</li></ol><br><p><strong>有问题的依赖基本有这样几种：</strong></p><ol><li>模块循环依赖</li><li>层间反向依赖</li><li>非强功能依赖</li></ol><br><p><strong>统跳协议 &amp; Rewrite引擎：</strong></p>',12),w={href:"http://pingguohe.net/2015/11/24/Navigator-and-Rewrite.html",target:"_blank",rel:"noopener noreferrer"},y=a('<h3 id="library-module-开发问题" tabindex="-1"><a class="header-anchor" href="#library-module-开发问题" aria-hidden="true">#</a> Library Module 开发问题</h3><div class="hint-container note"><p class="hint-container-title">说明</p><p>当把个模块分开以后，每个人就可以单独分组对应的模块就行了，不过会有资源冲突问题，建议是对各个模块的资源名字添加前缀，比如user模块中的登录界面布局为<code>activity_login.xml</code>，那么可以写成这样<code>us_activity_login.xml</code>。这样就可以避免资源冲突问题。同时Gradle也提供的一个字段<code>resourcePrefix</code>，确保各个资源名字正确，具体用法可以参考官方文档。</p></div><p>在把代码抽取到各个单独的Library Module中，会遇到各种问题，最常见的就是R文件问题，Android开发中，各个资源文件都是放在res目录中，在编译过程中，会生成R.java文件。R文件中包含有各个资源文件对应的id，这个id是静态常量，但是在Library Module中，这个id不是静态常量，那么在开发时候就要避开这样的问题。解决方案有下面几种：</p><ol><li><p>重新一个Gradle插件，生成一个R2.java文件，这个文件中各个id都是静态常量，这样就可以正常使用了。</p></li><li><p>使用Android系统提供的最原始的方式，直接用<code>findViewById</code>以及<code>setOnClickListener</code>方式。</p></li><li><p>设置项目支持Databinding，然后使用Binding中的对象，但是会增加不少方法数，同时Databinding也会有编译问题和学习成本，但是这些也是小问题，个人觉的问题不大。</p></li></ol><p>⚠️上面是主流的解决方法，推荐的使用优先级为 3 &gt; 2 &gt; 1。</p><h3 id="依赖管理" tabindex="-1"><a class="header-anchor" href="#依赖管理" aria-hidden="true">#</a> 依赖管理</h3><p>随着对代码的分割，主项目app的依赖变多了，如果修改了lib中的代码，那么编译时间是很恐怖的，如果原先在同一个模块的时候，编译时间大概需要2-3min，那么分开以后大概需要5-6min，这个是绝对无法忍受的。</p><p>可以这样解决：把各个子module分别使用单独的一个git仓库，这样每个人也只需要关注自己需要的git仓库即可，主仓库使用git submodule的方式，分别依赖各个子模块。</p><h3 id="数据通信" tabindex="-1"><a class="header-anchor" href="#数据通信" aria-hidden="true">#</a> 数据通信</h3><p>当一个大项目拆成若干小项目时候，数据通信大概有如下几种方式：</p>',10),T=e("p",null,"问题：比如在订单页面下单时候，需要判断用户是否登录，如果没有则需要跳到登录界面。",-1),D=e("p",null,[l("方案：直接指定某个页面的"),e("code",null,"ActivityClass"),l("，然后通过"),e("code",null,"Intent"),l("跳转即可，也可以使用"),e("code",null,"Router"),l("路由跳转")],-1),R=e("p",null,[e("strong",null,"Router方式：")],-1),j=e("ul",null,[e("li",null,"优点：不需要高难度的技术点，使用方便，直接使用字符串定义跳转，可以好的往后兼容"),e("li",null,"缺点：因为使用的是字符串配置，如果字符输入字符，则很难发现bug，同时也很难知道某个参数对应的含义")],-1),C=e("p",null,"问题：比如在下单时候，用户已经登录，下单需要传递用户的基本信息。",-1),L=e("p",null,"方案：所有需要的操作，定义成接口放在Service中。",-1),V=e("p",null,[e("strong",null,"仿Retrofit方式：")],-1),I=e("ul",null,[e("li",null,"因为是Java接口定义，所以可以很简单找到对应的跳转方法，参数定义也很明确，可以直接写在接口定义处，方便查阅。"),e("li",null,"同样因为是Java接口定义，那么如果需要扩展参数，只能重新定义新方法，这样会出现多个方法重载，如果在原先接口上修改，对应的原先调用方也要做响应的修改，比较麻烦。")],-1),S=e("p",null,[e("strong",null,"Interface和Implement：")],-1),G=e("ul",null,[e("li",null,"每次调用都是用反射生成新的对象，实际应用中可能与IoC工具结合使用，比如Dagger2")],-1),N=e("p",null,"问题：比如在切换用户的时候，有时候需要更新数据，如订单页面，需要把原先用户的购物车数据给清空。",-1),O=e("p",null,"方案：针对事件变化提供回调接口，需要监听某个事件时候，设置回调即可（把回调接口定义到对应的service接口中）",-1),H=e("p",null,[e("strong",null,"EventBus：")],-1),X=e("p",null,"利用观察者模式，对事件进行监听，是设置回调更优雅方式的实现。",-1),z=e("ul",null,[e("li",null,[e("p",null,"优点：不需要定义很多个回调接口，只需要定义事件Class，然后通过Claas的唯一性来进行事件匹配。")]),e("li",null,[e("p",null,"缺点：需要定义很多额外的类来表示事件，同时也需要关注EventBus的生命周期，在不需要使用事件时候，需要注销事件绑定，不然容易发生内存泄漏。")])],-1),F=a('<h3 id="映射匹配" tabindex="-1"><a class="header-anchor" href="#映射匹配" aria-hidden="true">#</a> 映射匹配</h3><p><strong>解决方案：</strong></p><ol><li>Map register：全局定义一个Map，各个模块在初始化的时候，分别在初始化的时候注册映射关系。</li><li>APT：使用注解的方式配置映射信息，然后生成一个类似Database一样的文件，然后Database文件中包含一个Map字段，Map中记录各个映射信息。</li><li>Gradle Transform：这是Android Gradle编译提供的一个接口，可以供开发自定义一些功能，而我们就可以根据这个功能生成映射匹配，这种方式和APT类似，APT是运行在代码编译时期，而且Transform是直接扫描class，然后再生成新的class，class中包含Map映射信息。修改class文件，使用的是javassist一个第三方库。</li></ol><p><strong>优点:</strong></p><ul><li>Map：简单明了，很容易入手，不会对编译时间产生任何影响，不会随着Gradle版本的升级而受影响，代码混淆时候不会有影响，无需配置混淆文件。</li><li>APT：使用简单，使用注解配置，代码优雅，原理是用代码生成的方式生成新的文件。</li><li>Transform：使用简单，使用注解配置，代码优雅，原理是用代码生成的方式生成新的文件，不过生成的文件的时期和APT不同，会编译时间产生少许影响。</li></ul><p><strong>缺点:</strong></p><ul><li>Map：在需要新添加映射的时候，需要手动添加，不然不会生效，代码不优雅。</li><li>APT：在编译时期生成文件，会编译时间产生少许影响，同时在不同的Gradle的版本中可能会产生错误或者兼容问题。需要配置混淆设置，不然会丢失文件。技术实现复杂，较难维护。</li><li>Transform：在编译时期生成文件，会编译时间产生少许影响，同时在不同的Gradle的版本中可能会产生错误或者兼容问题。需要配置混淆设置，不然会丢失文件。技术实现复杂，较难维护。</li></ul><div class="hint-container note"><p class="hint-container-title">对比</p><p>从技术复杂性以及维护性来看，Map &gt; APT = Transform</p><p>从使用复杂性以及代码优雅性来看，Transform &gt; APT &gt; Map</p></div><h3 id="容器设计" tabindex="-1"><a class="header-anchor" href="#容器设计" aria-hidden="true">#</a> 容器设计</h3><p>可以做一个简单的类似主app模块一样的模块。比如我是负责某个模块的开发者，那么我只要调试我这个模块就行了，如果需要其他的模块，可以简单的做一个mock，不是把其他的模块直接依赖过来，这样可以起到调试作用。</p><p>另外，可能有时候还是需要单独的运行环境，Android中的编译方式有2中，一种是debug，一种是release。当打包成aar的时候，使用的是release方式，可以把需要调试的代码全部放到debug中，这样打包的时候就不会把调试的文件发布到aar中。不过这种实现方式，需要对Android项目的目录有较高的认识，才可以熟练使用。</p><h2 id="相关文章" tabindex="-1"><a class="header-anchor" href="#相关文章" aria-hidden="true">#</a> 相关文章</h2>',12),J={href:"http://mobile.51cto.com/app-show-523490.htm",target:"_blank",rel:"noopener noreferrer"},U={href:"https://github.com/alibaba/BeeHive",target:"_blank",rel:"noopener noreferrer"},Q={href:"http://limboy.me/tech/2016/03/10/mgj-components.html",target:"_blank",rel:"noopener noreferrer"},W={href:"http://limboy.me/tech/2016/03/14/mgj-components-continued.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://casatwy.com/iOS-Modulization.html",target:"_blank",rel:"noopener noreferrer"},K={href:"http://jboss-javassist.github.io/javassist/",target:"_blank",rel:"noopener noreferrer"},Y={href:"http://www.jianshu.com/p/34f23b694412",target:"_blank",rel:"noopener noreferrer"},Z={href:"http://www.cnblogs.com/baronzhang/p/6442047.html",target:"_blank",rel:"noopener noreferrer"},$={href:"https://github.com/LiushuiXiaoxia/AndroidModular/",target:"_blank",rel:"noopener noreferrer"};function ee(le,ie){const o=r("router-link"),n=r("ExternalLinkIcon"),h=r("Tabs");return p(),_("div",null,[g,e("nav",b,[e("ul",null,[e("li",null,[i(o,{to:"#android-工程结构"},{default:t(()=>[l("Android 工程结构")]),_:1}),e("ul",null,[e("li",null,[i(o,{to:"#项目层次"},{default:t(()=>[l("项目层次")]),_:1})]),e("li",null,[i(o,{to:"#编译打包"},{default:t(()=>[l("编译打包")]),_:1})]),e("li",null,[i(o,{to:"#模块化"},{default:t(()=>[l("模块化")]),_:1}),e("ul",null,[e("li",null,[i(o,{to:"#拆分"},{default:t(()=>[l("拆分")]),_:1})]),e("li",null,[i(o,{to:"#library-module-开发问题"},{default:t(()=>[l("Library Module 开发问题")]),_:1})]),e("li",null,[i(o,{to:"#依赖管理"},{default:t(()=>[l("依赖管理")]),_:1})]),e("li",null,[i(o,{to:"#数据通信"},{default:t(()=>[l("数据通信")]),_:1})]),e("li",null,[i(o,{to:"#映射匹配"},{default:t(()=>[l("映射匹配")]),_:1})]),e("li",null,[i(o,{to:"#容器设计"},{default:t(()=>[l("容器设计")]),_:1})])])]),e("li",null,[i(o,{to:"#相关文章"},{default:t(()=>[l("相关文章")]),_:1})])])])])]),m,e("div",v,[A,e("ol",null,[e("li",null,[e("p",null,[e("a",B,[l("关于Android模块化我有一些话不知当讲不当讲"),i(n)])])]),e("li",null,[e("p",null,[e("a",E,[l("天猫模块化"),i(n)])])])])]),e("ol",null,[x,k,e("li",null,[e("p",null,[l("相关库："),e("a",P,[l("Beehive"),i(n)]),l("：Beehive是一个运行时框架，主要解决依赖耦合和工程耦合")])])]),M,e("p",null,[l("统调协议是一个基于URL的跳转方案，配合Rewrite引擎实现全App调用解耦（"),e("a",w,[l("相关文章 – 苹果核"),i(n)]),l("）")]),y,i(h,{id:"288",data:[{title:"页面跳转"},{title:"主动获取数据"},{title:"被动获得数据"}],"tab-id":"fruit"},{tab0:t(({title:s,value:d,isActive:c})=>[T,D,R,j]),tab1:t(({title:s,value:d,isActive:c})=>[C,L,V,I,S,G]),tab2:t(({title:s,value:d,isActive:c})=>[N,O,H,X,z]),_:1}),F,e("ol",null,[e("li",null,[e("p",null,[e("a",J,[l("天猫手机解耦之路"),i(n)])])]),e("li",null,[e("p",null,[e("a",U,[l("iOS 模块化BeeHive"),i(n)])])]),e("li",null,[e("p",null,[e("a",Q,[l("蘑菇街 App 的组件化之路"),i(n)])])]),e("li",null,[e("p",null,[e("a",W,[l("蘑菇街 App 的组件化之路·续"),i(n)])])]),e("li",null,[e("p",null,[e("a",q,[l("iOS应用架构谈 组件化方案"),i(n)])])]),e("li",null,[e("p",null,[e("a",K,[l("javassist资料"),i(n)])])]),e("li",null,[e("p",null,[e("a",Y,[l("iOS组件化方案调研"),i(n)])])]),e("li",null,[e("p",null,[e("a",Z,[l("安居客Android项目架构演进"),i(n)])])]),e("li",null,[e("p",null,[e("a",$,[l("关于Android模块化我有一些话不知当讲不当讲"),i(n)])])])])])}const ne=u(f,[["render",ee],["__file","B-Android工程结构.html.vue"]]);export{ne as default};
