import{_ as o,Q as a,S as c,U as e,a8 as t,W as l,a9 as i,H as r}from"./framework-d7e1aa10.js";const s={},n=e("h1",{id:"mybatis",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mybatis","aria-hidden":"true"},"#"),t(" Mybatis")],-1),p={class:"hint-container info"},h=e("p",{class:"hint-container-title"},"说明",-1),u=e("p",null,"Mybatis 学习",-1),m={href:"https://mybatis.org/mybatis-3/zh/index.html",target:"_blank",rel:"noopener noreferrer"},y=i('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>Mybatis 中的核心类为 <code>SqlSession</code></p><p>Mybatis 将所有 Xml 配置信息都封装到 All-ln-One 重量级对象 Configuration内部。 在Xml映射文件中：</p><ol><li><code>&lt;parameterMap&gt;</code> 标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 <code>ParameterMapping</code> 对象</li><li><code>&lt;resultMap&gt;</code> 标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象</li><li>每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 SQL 会被解析为 <code>BoundSql</code> 对象</li></ol><h2 id="标签" tabindex="-1"><a class="header-anchor" href="#标签" aria-hidden="true">#</a> 标签</h2><p><code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code></p><p><code>&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;</code></p><p>加上动态 SQL 的9个标签，<code>trim | where | set | foreach | if | choose | when |otherwise | bind</code> 等</p><p>其中 <code>&lt;sql&gt;</code> 为 SQL 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 SQL 片段</p><p><code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签</p><h2 id="映射" tabindex="-1"><a class="header-anchor" href="#映射" aria-hidden="true">#</a> 映射</h2><h3 id="映射对象类型" tabindex="-1"><a class="header-anchor" href="#映射对象类型" aria-hidden="true">#</a> 映射对象类型</h3><p>Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>typeHandler</code> ，实现 <code>TypeHandler</code> 的<code>setParameter</code> 和 <code>getResul</code> 接口方法 <code>TypeHandler</code> 有两个作用：</p><ol><li>一是完成从 <code>javaType</code> 至 <code>jdbcType</code> 的转换</li><li>二是完成 <code>jdbcType</code> 至 <code>javaType</code> 的转换，体现为 <code>setParameter</code> 和 <code>getResult</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果</li></ol><h3 id="映射的参数" tabindex="-1"><a class="header-anchor" href="#映射的参数" aria-hidden="true">#</a> 映射的参数</h3><ol><li>单个参数时直接传递即可</li><li>多个参数必须使用 <code>@param</code> 注解</li></ol><h2 id="resulttype-与-resultmap" tabindex="-1"><a class="header-anchor" href="#resulttype-与-resultmap" aria-hidden="true">#</a> ResultType 与 ResultMap</h2><ol><li><p>类名与数据库中的相同时，可以直接设置 ResultType 参数为 POJO</p></li><li><p>若不相同，那么需要设置 ResultMap 将结果名字和 POJO 名字进行转换</p></li></ol><h2 id="执行器" tabindex="-1"><a class="header-anchor" href="#执行器" aria-hidden="true">#</a> 执行器</h2><p>有三种基本的 Executor：</p><ol><li>SimpleExecutor：每执行一次 <code>update</code> 或 <code>select</code>，就开启一个 <code>Statement</code> 对象，用完立刻关闭 <code>Statement</code> 对象</li><li>ReuseExecutor：执行 <code>update</code> 或 <code>select</code> ，<code>以sql</code> 作为 <code>key</code> 查找 <code>Statement </code>对象，存在就使用，不存在就创建，用完后，不关闭 <code>Statement</code> 对象，而是放置于 <code>Map</code></li><li>BatchExecutor：完成批处理</li></ol><p>在配置文件中，可以指定默认的 <code>Executor</code> 下 <code>type</code> 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 <code>SqlSession</code> 的方法传递 <code>Executor Type</code> 类型参数</p><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ol><li><p>DAO 层的接口方法不能重载</p></li><li><p>XML 文件中如果有标签嵌套了，那么不同标签的定义位置是可以任意选择的，因为解析时发现有嵌套的标签还未加载，那么会先加载，后面的，最后再回头解析还未解析完的</p></li><li><p>不同的 XML 映射文件中 ID 想要重复那么需要配置 Namespace</p></li><li><p>批量插入可以返回列表的主键</p></li><li><p>在配置文件中设置 <code>usegeneratedkeys</code> 为 <code>true</code>，可以自动获取生成的主键值</p></li></ol>',24);function g(_,b){const d=r("ExternalLinkIcon");return a(),c("div",null,[n,e("div",p,[h,u,e("p",null,[t("官网："),e("a",m,[t("https://mybatis.org/mybatis-3/zh/index.html"),l(d)])])]),y])}const f=o(s,[["render",g],["__file","index.html.vue"]]);export{f as default};
