import{_ as n,Q as i,S as l,U as e,W as a,X as t,a8 as o,a9 as c,H as r}from"./framework-d7e1aa10.js";const s={},p=e("h1",{id:"android-网络通信",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#android-网络通信","aria-hidden":"true"},"#"),o(" Android 网络通信")],-1),u={class:"table-of-contents"},h=c('<h2 id="异步消息" tabindex="-1"><a class="header-anchor" href="#异步消息" aria-hidden="true">#</a> 异步消息</h2><p><strong>四大组件：</strong></p><ol><li><code>Message</code></li><li><code>MessageQueue</code></li><li><code>Handler</code></li><li><code>Looper</code></li></ol><h3 id="asynctask" tabindex="-1"><a class="header-anchor" href="#asynctask" aria-hidden="true">#</a> AsyncTask</h3><p>重写AsyncTask中的几个方法才能完成对异步任务的定制。经常需要重写的方法有以下4个：</p><ol><li><p><code>onPreExecute()</code>：这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等</p></li><li><p><code>doInBackground(Params...)</code>：这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用<code>publishProgress (Progress...)</code>方法来完成。</p></li><li><p><code>onProgressUpdate(Progress...)</code>：当在后台任务中调用了<code>publishProgress(Progress...)</code>方法后，<code>onProgressUpdate (Progress...)</code>方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p></li><li><p><code>onPostExecute(Result)</code>：当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执行的结果，以及关闭进度条对话框等。</p></li></ol><h2 id="网络请求" tabindex="-1"><a class="header-anchor" href="#网络请求" aria-hidden="true">#</a> 网络请求</h2><p>在过去，Android上发送HTTP请求一般有两种方式：<code>HttpURLConnection</code>和<code>HttpClient</code>。不过由于HttpClient存在API数量过多、扩展困难等缺点，Android团队越来越不建议我们使用这种方式。</p><p>在Android 6.0系统中，HttpClient的功能被完全移除了，标志着此功能被正式弃用，因此本小节我们就学习一下现在官方建议使用的<code>HttpURLConnection</code>的用法。</p><p>如今一般采用：</p><ol><li>OkHttp</li><li>Retrofit</li></ol><h2 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h2><p>Kotlin 中线程参数主要有以下3种值可选：</p><ol><li><code>Dispatchers.Default</code></li><li><code>Dispatchers.IO</code></li><li><code>Dispatchers.Main</code></li></ol><p><code>suspendCoroutine</code>函数必须在协程作用域或挂起函数中才能调用，它接收一个Lambda表达式参数，主要作用是将当前协程立即挂起，然后在一个普通的线程中执行Lambda表达式中的代码。Lambda表达式的参数列表上会传入一个Continuation参数，调用它的<code>resume()</code>方法或<code>resumeWithException()</code>可以让协程恢复执行</p>',15);function _(f,m){const d=r("router-link");return i(),l("div",null,[p,e("nav",u,[e("ul",null,[e("li",null,[a(d,{to:"#android-网络通信"},{default:t(()=>[o("Android 网络通信")]),_:1}),e("ul",null,[e("li",null,[a(d,{to:"#异步消息"},{default:t(()=>[o("异步消息")]),_:1}),e("ul",null,[e("li",null,[a(d,{to:"#asynctask"},{default:t(()=>[o("AsyncTask")]),_:1})])])]),e("li",null,[a(d,{to:"#网络请求"},{default:t(()=>[o("网络请求")]),_:1})]),e("li",null,[a(d,{to:"#并发"},{default:t(()=>[o("并发")]),_:1})])])])])]),h])}const k=n(s,[["render",_],["__file","Android网络通信.html.vue"]]);export{k as default};
