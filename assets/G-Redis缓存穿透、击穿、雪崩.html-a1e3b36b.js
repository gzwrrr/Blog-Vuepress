import{_ as r,Q as o,S as n,U as l,W as a,X as t,a8 as i,a9 as s,H as d}from"./framework-d7e1aa10.js";const u={},c=l("h1",{id:"redis-缓存穿透、击穿、雪崩",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#redis-缓存穿透、击穿、雪崩","aria-hidden":"true"},"#"),i(" Redis 缓存穿透、击穿、雪崩")],-1),h={class:"table-of-contents"},_=s('<h2 id="_1-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_1-缓存穿透" aria-hidden="true">#</a> 1.缓存穿透</h2><ul><li>当用户查询数据时，要是 redis 中没有，即缓存没命中，就会到数据库中查询，要是在数据库中也没有，那么本次查询失败</li><li>当用户很多或者有人恶意执行上述查询失败的操作时，就会造成数据库压力很大，此时就相当于出现了缓存穿透</li><li>解决方案： <ul><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>redis 存储空对象：当存储层没命中时，将返回的空对象也存入 redis 中，同时设置一个过期时间，之后再访问这个数据时就避免了直接访问数据库。但这种方法会浪费很多空间存储空值的键，并且即使设置了过期时间，缓存层和存储层还是会有一段时间窗口不一致，这对于需要保持一致性的业务会产生影响</li><li>布隆过滤器：是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则直接丢弃，避免了对底层存储系统的压力</li></ul></li></ul><h2 id="_2-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_2-缓存击穿" aria-hidden="true">#</a> 2.缓存击穿</h2><ul><li>是指某个键在扛着高并发时可能会出现失效的情况</li><li>当这个键被击穿或缓存过期后会有大量请求打入数据库，并且还会写回缓存，这会导致数据库和服务器压力过大</li><li>解决方案： <ul><li>设置热点数据不过期</li><li>加互斥锁：使用分布式锁保证对于每个 key 同时只有一个线程查询，其他线程在没有获得锁时只能等待，从而降低压力，但是这样会将压力转移到分布式锁上，所以分布式锁必须设计好</li><li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。</li></ul></li></ul><h2 id="_3-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_3-缓存雪崩" aria-hidden="true">#</a> 3.缓存雪崩</h2><ul><li><p>是指在某个时间段缓存集中过期失效，或是 redis 服务不可用</p></li><li><p>解决方案：</p><ul><li>设置热点数据永远不过期</li><li>增设多几个 redis，即将 redis 集群扩容，保证服务高可用（搭建异地多活），如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中</li><li>限流降级：在缓存失效后，通过加锁或队列来控制读数据库和写缓存得线程数量</li><li>数据预热：就是在正式部署之前把可能查询的数据预先访问一遍，这样部分可能大量访问的数据就会先加载到缓存中。在即将发生高并发访问前手动触发加载缓存并设置不同的过期时间，让缓存失效的时间点不会集中在一起</li></ul></li></ul><h2 id="_4-缓存污染" tabindex="-1"><a class="header-anchor" href="#_4-缓存污染" aria-hidden="true">#</a> 4.缓存污染</h2><ul><li>缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。</li><li>缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。</li><li>关键在于 <strong>最大缓存设置多大</strong> 以及选择怎么样的 <strong>缓存淘汰策略</strong><ul><li>设置最大缓存可以通过：<code>CONFIG SET maxmemory xxgb</code> 来设置</li><li>缓存淘汰策略有八种，分别是： <ul><li>不淘汰 <code> noeviction</code> （默认策略）</li><li>对设置了时间的数据进行淘汰： <code>volatile-random（随机）、volatile-ttl、volatile-lru、volatile-lfu</code></li><li>对全部数据进行淘汰：<code>allkeys-random（随机）、allkeys-lru、allkeys-lfu</code></li></ul></li></ul></li></ul><h2 id="_5-数据库与缓存一致性" tabindex="-1"><a class="header-anchor" href="#_5-数据库与缓存一致性" aria-hidden="true">#</a> 5.数据库与缓存一致性</h2><p><strong>缓存更新常用策略（策略）有四种：</strong></p><ol><li>Cache aside： <ol><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ol></li><li>Read through：将 <strong>缓存和持久化看成一个整体</strong>，读取时失效再由缓存服务持久化与更新缓存</li><li>Write through：将 <strong>缓存和持久化看成一个整体</strong>，更新时没有命中缓存则直接由缓存服务更新数据库数据；更新时命中则先更新缓存再更新数据库</li><li>Write behind caching（Write back）：在更新数据时只更新缓存而不更新数据库，之后缓存会异步批量更新数据库，这样 I/O 会很快并且持久化操作可以合并，缺点就是数据不是强一致性的且可能会丢失（主机断电等原因）</li></ol><p><strong>队列 + 重试机制：</strong> 会入侵业务代码</p><ul><li>更新数据库数据；</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成功</li></ul><p><strong>异步更新缓存（基于订阅binlog的同步机制）：</strong></p><ul><li>更新数据库数据</li><li>更新操作写入 binlog 并由非业务代码进行提取</li><li>将需要删除的key发送至消息队列</li><li>非业务代码消费消息</li><li>继续重试删除操作，直到成功</li></ul>',15);function g(f,p){const e=d("router-link");return o(),n("div",null,[c,l("nav",h,[l("ul",null,[l("li",null,[a(e,{to:"#redis-缓存穿透、击穿、雪崩"},{default:t(()=>[i("Redis 缓存穿透、击穿、雪崩")]),_:1}),l("ul",null,[l("li",null,[a(e,{to:"#_1-缓存穿透"},{default:t(()=>[i("1.缓存穿透")]),_:1})]),l("li",null,[a(e,{to:"#_2-缓存击穿"},{default:t(()=>[i("2.缓存击穿")]),_:1})]),l("li",null,[a(e,{to:"#_3-缓存雪崩"},{default:t(()=>[i("3.缓存雪崩")]),_:1})]),l("li",null,[a(e,{to:"#_4-缓存污染"},{default:t(()=>[i("4.缓存污染")]),_:1})]),l("li",null,[a(e,{to:"#_5-数据库与缓存一致性"},{default:t(()=>[i("5.数据库与缓存一致性")]),_:1})])])])])]),_])}const m=r(u,[["render",g],["__file","G-Redis缓存穿透、击穿、雪崩.html.vue"]]);export{m as default};
