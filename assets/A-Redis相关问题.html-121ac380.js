import{_ as n,Q as s,S as r,U as t,W as d,X as i,a8 as e,a9 as a,H as c}from"./framework-d7e1aa10.js";const y={},x=t("h1",{id:"redis-相关问题",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#redis-相关问题","aria-hidden":"true"},"#"),e(" Redis 相关问题")],-1),g={class:"table-of-contents"},o=a('<h2 id="_1-redis的相关问题" tabindex="-1"><a class="header-anchor" href="#_1-redis的相关问题" aria-hidden="true">#</a> 1.Redis的相关问题</h2><ul><li><p>redis是单线程的，是基于内存操作的，CPU不是redis的性能瓶颈，redis的瓶颈在于机器的内存和网络带宽，官方表示这可以使用单线程实现，便使用单线程了</p></li><li><p>redis将所有的数据放在了内存中，使用单线程是最快的。倘若使用多线程，会在CPU中进行上下文切换，这是非常耗时的</p></li></ul><h3 id="_1-1-redis-conf" tabindex="-1"><a class="header-anchor" href="#_1-1-redis-conf" aria-hidden="true">#</a> 1.1 Redis.conf</h3><p><strong>【】中的为具体的自定义配置</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align:center;">序号</th><th style="text-align:center;">参数</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">unit</td><td style="text-align:center;">单位，对大小写不敏感</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">include 【path】</td><td style="text-align:center;">可以将多个配置文件引入组合成一个</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">bind 【ip】</td><td style="text-align:center;">绑定 ip</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">pretected-mode 【yes | no】</td><td style="text-align:center;">是否开启受保护模式，默认为 yes</td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;">port 【port】</td><td style="text-align:center;">设置端口</td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;">daemonize 【yes | no】</td><td style="text-align:center;">是否以守护进程的方式运行，默认是 no</td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;">pidfile 【path】</td><td style="text-align:center;">指定 pid 文件，让 redis 在后台运行</td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;">loglevel 【level】</td><td style="text-align:center;">指定日志级别</td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;">logfile 【path】</td><td style="text-align:center;">日志文件的位置</td></tr><tr><td style="text-align:center;">10</td><td style="text-align:center;">database 【sum】</td><td style="text-align:center;">数据库的数量，默认为 16</td></tr><tr><td style="text-align:center;">11</td><td style="text-align:center;">always-show-logo 【yes | no】</td><td style="text-align:center;">是否总是显示 logo</td></tr><tr><td style="text-align:center;">12</td><td style="text-align:center;">save 【time】 【keyNum】</td><td style="text-align:center;">在 time 时间（单位为：s）内修改了 keyNum 个 key 就将数据持久化到 .rdb/.aof 文件</td></tr><tr><td style="text-align:center;">13</td><td style="text-align:center;">stop-writes-on-bgsave-error 【yes | no】</td><td style="text-align:center;">如果持久化出错，是否还需要继续工作，默认 yes</td></tr><tr><td style="text-align:center;">14</td><td style="text-align:center;">rdbcompression 【yes | no】</td><td style="text-align:center;">是否压缩 rdb 文件，默认 yes</td></tr><tr><td style="text-align:center;">15</td><td style="text-align:center;">dir 【path】</td><td style="text-align:center;">rdb 文件的保存目录</td></tr><tr><td style="text-align:center;">16</td><td style="text-align:center;">requirepass 【pwd】</td><td style="text-align:center;">设置密码，默认为空</td></tr><tr><td style="text-align:center;">17</td><td style="text-align:center;">maxclients 【sum】</td><td style="text-align:center;">最大连接数量</td></tr><tr><td style="text-align:center;">18</td><td style="text-align:center;">maxmemory 【size】</td><td style="text-align:center;">redis 配置的最大内存容量，单位为 byte</td></tr><tr><td style="text-align:center;">19</td><td style="text-align:center;">maxmemory-policy noeviction</td><td style="text-align:center;">内存达到上限之后的处理策略</td></tr><tr><td style="text-align:center;">20</td><td style="text-align:center;">appendonly 【yes | no】</td><td style="text-align:center;">是否使用 aof 持久化模式，默认为 no，即使用 rdb</td></tr><tr><td style="text-align:center;">21</td><td style="text-align:center;">appendfilename 【filename】</td><td style="text-align:center;">持久化文件的名称</td></tr><tr><td style="text-align:center;">22</td><td style="text-align:center;">appendsync everysec</td><td style="text-align:center;">每秒都执行一次同步数据的操作</td></tr></tbody></table></div><h3 id="_1-2-为什么要使用redis" tabindex="-1"><a class="header-anchor" href="#_1-2-为什么要使用redis" aria-hidden="true">#</a> 1.2 为什么要使用Redis</h3><ol><li>读写性能优异：Redis 读取速度是 110000 次/s,写的速度是 81000 次/s</li><li>数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作</li><li>原子性：Redis 所有操作都是原子性的，同时 Redis 还支持对几个操作合并后执行原子性操作</li><li>支持发布/订阅模式、通知、key 过期等特性</li><li>支持使用 RDB 或者 AOF 进行持久化</li><li>分布式，可以使用集群</li></ol><h3 id="_1-3-redis-单线程快的原因" tabindex="-1"><a class="header-anchor" href="#_1-3-redis-单线程快的原因" aria-hidden="true">#</a> 1.3 Redis 单线程快的原因</h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器 file event handler。</p><p>这个文件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。</p><p>可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</p><ol><li>文件事件处理器的结构包含4个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）</li><li>多个 Socket 可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听</li><li>多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中取出一个 Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。</li><li>然后一个 Socket 的事件处理完之后，IO多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。</li></ol><p>单线程快的原因：</p><ol><li>纯内存操作</li><li>核心是基于非阻塞的IO多路复用机制</li><li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li></ol><h3 id="_1-4-使用场景" tabindex="-1"><a class="header-anchor" href="#_1-4-使用场景" aria-hidden="true">#</a> 1.4 使用场景</h3><ol><li>热点数据缓存：一般有两种保存数据的方式： <ol><li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis，此时要注意缓存击穿，而且数据的实时性会相对较差，适用于对于数据实时性要求不是特别高的场景</li><li>插入数据时，同时写入Redis，这样实时性相对较强，但是开发时不便于统一处理，适用于字典表、数据量不大的数据存储</li></ol></li><li>延时任务，限时业务，例如订单支付、限时优惠活动。另外：延时操作还可以使用rabbitmq、activemq 等消息中间件来实现</li><li>redis由于 <code>incrby</code> 命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等</li><li>可以实现 <strong>分布式锁</strong>：这个主要利用redis的setnx命令进行，setnx：&quot;set if not exists&quot;就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。在分布式锁的场景中，主要用在比如秒杀系统等</li><li>可以实现排行榜、点赞、求出共同好友等并存储</li><li>实现队列：由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作</li></ol><h3 id="_1-5-相关框架" tabindex="-1"><a class="header-anchor" href="#_1-5-相关框架" aria-hidden="true">#</a> 1.5 相关框架</h3><ol><li>Redission（分布式锁/分布式服务）：Redission是一个基于Redis的Java分布式对象和服务框架，它提供了分布式锁、分布式对象、分布式限流、分布式集合等功能。在分布式系统中，分布式锁是非常重要的一种机制，用来保证多个进程或线程访问共享资源的安全性。Redission提供了多种分布式锁实现方式，例如可重入锁、公平锁、联锁、红锁等。Redission还支持异步和反应式编程模型，可以帮助我们实现高效的分布式应用程序。</li><li>lettuce（Redis客户端）：lettuce是一个高性能的Redis客户端库，它提供了同步、异步和反应式编程模型，支持集群、哨兵和单机部署模式。lettuce可以与Spring等常见框架集成，使我们的开发变得更加便捷。</li><li>Jedis（Redis客户端）：Jedis是一个广泛使用的Java Redis客户端，它提供了比较完整的Redis操作接口，可以实现数据读写、事务、发布订阅等操作。与lettuce不同的是，Jedis只支持同步操作，不支持异步和反应式编程模型。Jedis可以与Spring等框架集成，使我们的开发变得更加简单。</li><li>Spring Data Redis（数据访问）：Spring Data Redis是Spring Data家族的一部分，提供了对Redis的支持。它提供了一个强大的RedisTemplate，可以方便地进行数据读写、事务、发布订阅等操作。Spring Data Redis还支持对Redis集群和哨兵模式的访问，并提供了基于注解和XML的配置方式，可以轻松实现与Spring框架的集成。</li></ol><h3 id="_1-6-性能测试" tabindex="-1"><a class="header-anchor" href="#_1-6-性能测试" aria-hidden="true">#</a> 1.6 性能测试</h3><p>redis-benchmark 是 redis 官方自带的一个压力测试工具</p><p>redis-benchmark 命令参数：</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th style="text-align:left;">选项</th><th style="text-align:left;">描述</th><th style="text-align:left;">默认值</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left;">-h</td><td style="text-align:left;">指定服务器主机名</td><td style="text-align:left;">127.0.0.1</td></tr><tr><td>2</td><td style="text-align:left;">-p</td><td style="text-align:left;">指定服务器端口</td><td style="text-align:left;">6379</td></tr><tr><td>3</td><td style="text-align:left;">-s</td><td style="text-align:left;">指定服务器socket</td><td style="text-align:left;">/</td></tr><tr><td>4</td><td style="text-align:left;">-c</td><td style="text-align:left;">指定并发连接数</td><td style="text-align:left;">50</td></tr><tr><td>5</td><td style="text-align:left;">-n</td><td style="text-align:left;">指定请求数</td><td style="text-align:left;">10000</td></tr><tr><td>6</td><td style="text-align:left;">-d</td><td style="text-align:left;">以字节的形式指定SET/GET值的数据大小</td><td style="text-align:left;">2</td></tr><tr><td>7</td><td style="text-align:left;">-k</td><td style="text-align:left;">1=keep alive 0 = reconnect</td><td style="text-align:left;">1</td></tr><tr><td>8</td><td style="text-align:left;">-r</td><td style="text-align:left;">SET/GET/INCR 使用随机key，SADD使用随机值</td><td style="text-align:left;">/</td></tr><tr><td>9</td><td style="text-align:left;">-p</td><td style="text-align:left;">通过管道传输<code>&lt;numreq&gt;</code>请求</td><td style="text-align:left;">1</td></tr><tr><td>10</td><td style="text-align:left;">-q</td><td style="text-align:left;">强制退出redis，仅显示query/sec值</td><td style="text-align:left;">/</td></tr><tr><td>11</td><td style="text-align:left;">--csv</td><td style="text-align:left;">以CSV格式输出</td><td style="text-align:left;">/</td></tr><tr><td>12</td><td style="text-align:left;">-l</td><td style="text-align:left;">生成循环，永久执行测试</td><td style="text-align:left;">/</td></tr><tr><td>13</td><td style="text-align:left;">-t</td><td style="text-align:left;">仅运行以逗号分隔的测试命令列表</td><td style="text-align:left;">/</td></tr><tr><td>14</td><td style="text-align:left;">-l</td><td style="text-align:left;">Idle模式，仅打开N个idle连接并等待</td><td style="text-align:left;">/</td></tr></tbody></table></div>',22);function h(f,p){const l=c("router-link");return s(),r("div",null,[x,t("nav",g,[t("ul",null,[t("li",null,[d(l,{to:"#redis-相关问题"},{default:i(()=>[e("Redis 相关问题")]),_:1}),t("ul",null,[t("li",null,[d(l,{to:"#_1-redis的相关问题"},{default:i(()=>[e("1.Redis的相关问题")]),_:1}),t("ul",null,[t("li",null,[d(l,{to:"#_1-1-redis-conf"},{default:i(()=>[e("1.1 Redis.conf")]),_:1})]),t("li",null,[d(l,{to:"#_1-2-为什么要使用redis"},{default:i(()=>[e("1.2 为什么要使用Redis")]),_:1})]),t("li",null,[d(l,{to:"#_1-3-redis-单线程快的原因"},{default:i(()=>[e("1.3 Redis 单线程快的原因")]),_:1})]),t("li",null,[d(l,{to:"#_1-4-使用场景"},{default:i(()=>[e("1.4 使用场景")]),_:1})]),t("li",null,[d(l,{to:"#_1-5-相关框架"},{default:i(()=>[e("1.5 相关框架")]),_:1})]),t("li",null,[d(l,{to:"#_1-6-性能测试"},{default:i(()=>[e("1.6 性能测试")]),_:1})])])])])])])]),o])}const _=n(y,[["render",h],["__file","A-Redis相关问题.html.vue"]]);export{_ as default};
