import{_ as r,Q as n,S as d,U as t,W as a,X as i,a8 as e,a9 as s,H as c}from"./framework-d7e1aa10.js";const h={},o=t("h1",{id:"接口调用出错的应对策略",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#接口调用出错的应对策略","aria-hidden":"true"},"#"),e(" 接口调用出错的应对策略")],-1),_={class:"table-of-contents"},u=s('<h1 id="写在前面" tabindex="-1"><a class="header-anchor" href="#写在前面" aria-hidden="true">#</a> 写在前面</h1><ul><li>对于接口调用失败的情况，如果没有相应的容错应对策略很可能导致服务不可用</li><li>常见的容错策略有： <ul><li>故障转移</li><li>快速失败</li><li>安全失败</li><li>沉默失败</li></ul></li></ul><br><h1 id="故障转移" tabindex="-1"><a class="header-anchor" href="#故障转移" aria-hidden="true">#</a> 故障转移</h1><ul><li>高可用的服务集群中（尤其是被依赖的关键服务）均会部署多个副本</li><li>这些节点可以部署在不同的节点、网络交换区、可用区（分别应对节点宕机、网络分区、不可抗力导致的故障）</li><li>故障转移是指如果调用的服务器出现故障，系统不会立即向调用者返回失败结果，而是自动切换到其他的节点尝试返回成功调用的结果</li><li>这样可以保证整体的高可用性</li></ul><br><h1 id="快速失败" tabindex="-1"><a class="header-anchor" href="#快速失败" aria-hidden="true">#</a> 快速失败</h1><ul><li>有一些业务场景是不允许做故障转移的，因为故障转移策略的前提是服务具备幂等性</li><li>对于非幂等性的服务，重复调用就可能产生脏数据，这样带来的麻烦远远大于某次服务调用失败的，此时应该选择快速失败作为容错策略</li><li>当非幂等性服务调用失败后，往往是不清楚哪一步出现异常的，此时为了避免重复操作，最恰当的做法就是尽快让服务报错，尽快抛出异常让调用者处理</li></ul><br><h1 id="安全失败" tabindex="-1"><a class="header-anchor" href="#安全失败" aria-hidden="true">#</a> 安全失败</h1><ul><li>在一个调用链路中的服务通常分为主路和旁路，即不是每个服务都是不可或缺的，有些服务失败了也不影响核心业务的正确性</li><li>使用 Spring 开发时，通过扩展点、事件或者 AOP 注入的逻辑通常都属于旁路逻辑，如：审计、日志、调式信息等</li><li>属于旁路逻辑的另一个显著特征是后续处理不会依赖其返回值，或者该返回值不会影响后续的处理结果</li><li>对于这类旁路逻辑，一种理想的容错策略是：即使旁路逻辑失败了也当作正确的返回；如果需要返回值的话，系统就自动返回一个符合返回类型的值</li><li>失败后系统会自动记录一条服务调用出错的日志备查，这样的策略就被称为安全失败</li></ul><br><h1 id="沉默失败" tabindex="-1"><a class="header-anchor" href="#沉默失败" aria-hidden="true">#</a> 沉默失败</h1><ul><li>如果大量请求需要等到才是或者长时间处理后才能宣告失败，那么很容易由于某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源而影响系统稳定</li><li>对于这种情况，一种合理的策略是当请求在一段时间连续失败若干次后，默认服务提供方在以一定时间内无法再对外服务，此时进行熔断，不在向它分配请求流量，即将错误隔离开来，避免对其他部分产生影响，这样的策略就被称为沉默失败</li></ul><br><h1 id="优缺点-应用场景" tabindex="-1"><a class="header-anchor" href="#优缺点-应用场景" aria-hidden="true">#</a> 优缺点/应用场景</h1><div class="table-wrapper"><table><thead><tr><th style="text-align:center;">容错策略</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th><th style="text-align:center;">应用场景</th></tr></thead><tbody><tr><td style="text-align:center;">故障转移</td><td style="text-align:center;">系统自动处理<br>调用者对失败的信息不可见</td><td style="text-align:center;">增加了调用时间<br>消耗了额外的资源</td><td style="text-align:center;">调用的是幂等性服务<br>对调用时间不敏感</td></tr><tr><td style="text-align:center;">快速失败</td><td style="text-align:center;">调用者对失败的处理有控制权<br>不依赖服务的幂等性</td><td style="text-align:center;">调用则必须正确处理失败<br>如果只是抛异常可能引起雪崩</td><td style="text-align:center;">调用的是非幂等性服务<br>超时阈值较低</td></tr><tr><td style="text-align:center;">安全失败</td><td style="text-align:center;">不影响主路逻辑</td><td style="text-align:center;">只适用于旁路调用</td><td style="text-align:center;">调用链中的旁路服务</td></tr><tr><td style="text-align:center;">沉默失败</td><td style="text-align:center;">能够控制错误，避免影响整体</td><td style="text-align:center;">出错的服务将在一段时间内不可用</td><td style="text-align:center;">频繁超时的服务</td></tr></tbody></table></div>',17);function x(b,f){const l=c("router-link");return n(),d("div",null,[o,t("nav",_,[t("ul",null,[t("li",null,[a(l,{to:"#接口调用出错的应对策略"},{default:i(()=>[e("接口调用出错的应对策略")]),_:1})]),t("li",null,[a(l,{to:"#写在前面"},{default:i(()=>[e("写在前面")]),_:1})]),t("li",null,[a(l,{to:"#故障转移"},{default:i(()=>[e("故障转移")]),_:1})]),t("li",null,[a(l,{to:"#快速失败"},{default:i(()=>[e("快速失败")]),_:1})]),t("li",null,[a(l,{to:"#安全失败"},{default:i(()=>[e("安全失败")]),_:1})]),t("li",null,[a(l,{to:"#沉默失败"},{default:i(()=>[e("沉默失败")]),_:1})]),t("li",null,[a(l,{to:"#优缺点-应用场景"},{default:i(()=>[e("优缺点/应用场景")]),_:1})])])]),u])}const g=r(h,[["render",x],["__file","接口调用出错的应对策略-已发布.html.vue"]]);export{g as default};
