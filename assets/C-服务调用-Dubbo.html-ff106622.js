import{_ as n,Q as l,S as r,U as e,a8 as i,W as t,a9 as a,H as d}from"./framework-d7e1aa10.js";const s={},c=a('<h1 id="服务调用-dubbo" tabindex="-1"><a class="header-anchor" href="#服务调用-dubbo" aria-hidden="true">#</a> 服务调用-Dubbo</h1><blockquote><p>提供 RPC 通信与服务治理两大能力，开箱即用，很好地支持 Java 和 Go（还有其他的语言）</p></blockquote><p>Dubbo3 是在云原生背景下诞生的，使用 Dubbo 构建的微服务遵循云原生思想，能更好的复用底层云原生基础设施、贴合云原生微服务架构。这体现在：</p><ul><li>服务支持部署在容器、Kubernetes（K8S）平台，服务生命周期可实现与平台调度周期对齐；</li><li>支持经典 Service Mesh （服务网格）微服务架构，引入了 Proxyless Mesh 架构，进一步简化 Mesh 的落地与迁移成本，提供更灵活的选择；</li><li>作为桥接层，支持与 SpringCloud、gRPC 等异构微服务体系的互调互通</li></ul><p>Dubbo 从设计上是完全遵循云原生微服务开发理念的，这体现在多个方面，首先是对云原生基础设施与部署架构的支持，包括 Kubernetes、Service Mesh 等，另一方面，Dubbo 众多核心组件都已面向云原生升级，包括 Triple 协议、统一路由规则、对多语言支持。值得一提的是，如何使用 Dubbo 支持弹性伸缩的服务如 Serverless 也在未来计划之中，这包括利用 Native Image 提高 Dubbo 的启动速度与资源消耗等。</p><p>结合当前版本，本节主要从以下两点展开 Dubbo 的云原生特性</p><ul><li>容器调度平台（Kubernetes）</li><li>Service Mesh</li></ul><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><h3 id="架构设计" tabindex="-1"><a class="header-anchor" href="#架构设计" aria-hidden="true">#</a> 架构设计</h3><blockquote><p>从抽象架构上分为两层：<strong>服务治理抽象控制面（包含多个协调服务）</strong> 和 <strong>Dubbo 数据面（发起与接收 RPC 调用）</strong></p></blockquote><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230315/dubbo架构.png" alt="architecture" tabindex="0" loading="lazy"><figcaption>architecture</figcaption></figure><p>Dubbo 是一个高性能、轻量级的开源 RPC 框架，主要用于构建分布式服务应用。它支持多种协议、多种序列化方式和多种注册中心，提供了丰富的功能，包括负载均衡、容错、路由、服务降级等。Dubbo 的架构设计具有以下几个方面的特点：</p><ol><li>服务治理架构：Dubbo 的架构设计采用了服务治理的思想，将分布式服务治理问题抽象成了统一的架构模型。它提供了注册中心、配置中心、路由中心等多个核心组件，支持服务的注册与发现、配置管理、负载均衡等功能，大大简化了分布式服务治理的复杂度。</li><li>高度可扩展性：Dubbo 的架构设计具有高度可扩展性，支持多种协议、多种序列化方式和多种注册中心，可以根据应用需求进行自由选择和配置。此外，Dubbo 还支持自定义协议、序列化方式和注册中心，可以快速扩展和定制化。</li><li>面向接口设计：Dubbo 的架构设计采用了面向接口设计的思想，提供了统一的服务接口定义和服务提供方、消费方的契约协议，将服务接口、参数、返回值等信息进行了封装和统一管理。这种设计思想降低了服务间的耦合度，提高了服务的灵活性和可复用性。</li><li>服务端异步处理：Dubbo 的架构设计采用了服务端异步处理的思想，支持异步调用和响应处理，提高了服务的并发性和吞吐量。此外，Dubbo 还支持多线程模型和线程池调度，可以快速响应大量并发请求。</li><li>多种容错机制：Dubbo 的架构设计具有多种容错机制，包括服务降级、失败重试、熔断器等，可以有效提高服务的可用性和稳定性。此外，Dubbo 还支持多种负载均衡策略和路由策略，可以根据不同的应用场景进行灵活配置。</li></ol><br><p><strong>不同层次的方案：</strong></p><ol><li>Servive：业务层</li><li>Config：配置层，可以使用：JavaConfig、XML、Properties</li><li>Proxy 服务代理层：支持 JDK 动态代理、javassist 等代理机制</li><li>Registry 注册中心层：支持 Zookeeper 、Redis 等作为注册中心</li><li>Cluster：路由层</li><li>Protocal 远程过程调用：支持 Dubbo、Http 等调用协议</li><li>Exchange：数据交换曾</li><li>Transport 网络传输层：支持 Netty、Mina 等网络传输框架</li><li>Serialize 数据序列化层：支持 JSON、Hessian 等序列化机制</li></ol><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230727/dubbo架构.jpg" alt="/dev-guide/images/dubbo-framework.jpg" tabindex="0" loading="lazy"><figcaption>/dev-guide/images/dubbo-framework.jpg</figcaption></figure><br><p><strong>一切皆可扩展：</strong></p><ul><li><strong>协议与编码扩展</strong>。通信协议、序列化编码协议等</li><li><strong>流量管控扩展</strong>。集群容错策略、路由规则、负载均衡、限流降级、熔断策略等</li><li><strong>服务治理扩展</strong>。注册中心、配置中心、元数据中心、分布式事务、全链路追踪、监控系统等</li><li><strong>诊断与调优扩展</strong>。流量统计、线程池策略、日志、QoS 运维命令、健康检查、配置加载等</li></ul><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230725/dubbo一切皆可扩展.png" alt="Dubbo 一切皆可扩展" tabindex="0" loading="lazy"><figcaption>Dubbo 一切皆可扩展</figcaption></figure><br><p><strong>微内核+插件设计：</strong></p><p>该设计从三个层次来展开：</p><ul><li>协议通信层</li><li>流量管控层</li><li>服务治理层</li></ul><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230725/dubbo微内核与插件.png" alt="微内核+插件" tabindex="0" loading="lazy"><figcaption>微内核+插件</figcaption></figure><h3 id="部署架构" tabindex="-1"><a class="header-anchor" href="#部署架构" aria-hidden="true">#</a> 部署架构</h3><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230319/部署架构.png" alt="//imgs/v3/concepts/threecenters.png" tabindex="0" loading="lazy"><figcaption>//imgs/v3/concepts/threecenters.png</figcaption></figure><p>作为一个微服务框架，Dubbo sdk 跟随着微服务组件被部署在分布式集群各个位置，为了在分布式环境下实现各个微服务组件间的协作， Dubbo 定义了一些中心化组件，这包括：</p><ol><li>注册中心：协调消费者与生产者的地址注册和发现</li><li>配置中心：存储 Dubbo 启动阶段的全局配置，保证个环境配置一致；还负责服务治理规则（路由、动态配置）的存储和推送</li><li>元数据中心：接收生产者上报的服务接口的元数据，相当于注册中心的额外扩展</li></ol><h2 id="通信" tabindex="-1"><a class="header-anchor" href="#通信" aria-hidden="true">#</a> 通信</h2><blockquote><p>Dubbo3 提供了 Triple(Dubbo3)、Dubbo2 协议，这是 Dubbo 框架的原生协议。除此之外，Dubbo3 也对众多第三方协议进行了集成，并将它们纳入 Dubbo 的编程与服务治理体系， 包括 gRPC、Thrift、JsonRPC、Hessian2、REST 等。</p></blockquote><p>Dubbo 对通信协议的支持具有以下特点：</p><ul><li>不绑定通信协议</li><li>提供高性能通信协议实现</li><li>支持流式通信模型</li><li>不绑定序列化协议</li><li>支持单个服务的多协议暴露</li><li>支持单端口多协议发布</li><li>支持一个应用内多个服务使用不同通信协议</li></ul><p>RPC 协议的设计需要考虑以下内容：</p><ul><li>通用性： 统一的二进制格式，跨语言、跨平台、多传输层协议支持</li><li>扩展性： 协议增加字段、升级、支持用户扩展和附加业务元数据</li><li>性能：As fast as it can be</li><li>穿透性：能够被各种终端设备识别和转发：网关、代理服务器等 通用性和高性能通常无法同时达到，需要协议设计者进行一定的取舍。</li></ul><h3 id="通信模型" tabindex="-1"><a class="header-anchor" href="#通信模型" aria-hidden="true">#</a> 通信模型</h3><p>Dubbo 提供更丰富的通信模型：</p><ul><li>消费端异步请求(Client Side Asynchronous Request-Response)</li><li>提供端异步执行（Server Side Asynchronous Request-Response）</li><li>消费端请求流（Request Streaming）</li><li>提供端响应流（Response Streaming）</li><li>双向流式通信（Bidirectional Streaming）</li></ul><h3 id="triple-协议" tabindex="-1"><a class="header-anchor" href="#triple-协议" aria-hidden="true">#</a> Triple 协议</h3><blockquote><p>Triple 兼容 gRPC ，以 HTTP2 作为传输层构建新的协议</p></blockquote><div class="hint-container note"><p class="hint-container-title">补充</p><p>自从 2017 年 gRPC 协议成为 CNCF 的项目后，包括 k8s、etcd 等越来越多的基础设施和业务都开始使用 gRPC 的生态，作为云原生的微服务化框架， Dubbo 的新协议也完美兼容了 gRPC。并且，对于 gRPC 协议中一些不完善的部分， Triple 也将进行增强和补充。</p></div><p>自从 2017 年 gRPC 协议成为 CNCF 的项目后，包括 k8s、etcd 等越来越多的基础设施和业务都开始使用 gRPC 的生态，作为云原生的微服务化框架， Dubbo 的新协议也完美兼容了 gRPC。并且，对于 gRPC 协议中一些不完善的部分， Triple 也将进行增强和补充。</p><p>基于 grpc 协议进行进一步扩展</p>',44),u=e("ul",null,[e("li",{Dubbo:"",service:"",version:""},"Service-Version → “tri-service-version”"),e("li",{Dubbo:"",service:"",group:""},"Service-Group → “tri-service-group”"),e("li",{tracing:"",id:""},"Tracing-ID → “tri-trace-traceid”"),e("li",{_span:"",id:"",_:""},"Tracing-RPC-ID → “tri-trace-rpcid”"),e("li",{cluster:"",infomation:""},"Cluster-Info → “tri-unit-info”")],-1),b=a('<p>Triple 协议的核心特性如下：</p><ul><li>支持 TLS 加密、Plaintext 明文数据传输</li><li>支持反压与限流</li><li>支持 Streaming 流式通信</li><li>同时支持 HTTP/1 和 HTTP/2 传输协议</li></ul><h2 id="服务" tabindex="-1"><a class="header-anchor" href="#服务" aria-hidden="true">#</a> 服务</h2><h3 id="服务治理" tabindex="-1"><a class="header-anchor" href="#服务治理" aria-hidden="true">#</a> 服务治理</h3><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230315/dubbo服务治理能力.png" alt="governance" tabindex="0" loading="lazy"><figcaption>governance</figcaption></figure><ol><li><strong>地址发现</strong>：Dubbo 服务发现具备高性能、支持大规模集群、服务级元数据配置等优势，默认提供 Nacos、Zookeeper、Consul 等多种注册中心适配，与 Spring Cloud、Kubernetes Service 模型打通，支持自定义扩展。</li><li><strong>负载均衡</strong>：Dubbo 默认提供加权随机、加权轮询、最少活跃请求数优先、最短响应时间优先、一致性哈希和自适应负载等策略</li><li><strong>流量路由</strong>：Dubbo 支持通过一系列流量规则控制服务调用的流量分布与行为，基于这些规则可以实现基于权重的比例流量分发、灰度验证、金丝雀发布、按请求参数的路由、同区域优先、超时配置、重试、限流降级等能力。</li><li><strong>链路追踪</strong>：Dubbo 官方通过适配 OpenTelemetry 提供了对 Tracing 全链路追踪支持，用户可以接入支持 OpenTelemetry 标准的产品如 Skywalking、Zipkin 等。另外，很多社区如 Skywalking、Zipkin 等在官方也提供了对 Dubbo 的适配。</li><li><strong>可观测性</strong>：Dubbo 实例通过 Prometheus 等上报 QPS、RT、请求次数、成功率、异常次数等多维度的可观测指标帮助了解服务运行状态，通过接入 Grafana、Admin 控制台帮助实现数据指标可视化展示。</li></ol><p>Dubbo 服务治理生态还提供了对 <strong>API 网关</strong>、<strong>限流降级</strong>、<strong>数据一致性</strong>、<strong>认证鉴权</strong>等场景的适配支持。</p><h3 id="服务引入" tabindex="-1"><a class="header-anchor" href="#服务引入" aria-hidden="true">#</a> 服务引入</h3><p>Dubbo完成服务引入的过程如下：</p><ol><li>消费者引入依赖：在消费者端的项目中，需要引入 Dubbo 相关依赖，如 dubbo、dubbo-spring-boot-starter 等。</li><li>配置消费者信息：在消费者端的项目中，需要配置 Dubbo 的消费者信息，包括注册中心地址、服务超时时间、服务调用重试次数等等。</li><li>编写消费者代码：编写调用 Dubbo 服务的消费者代码，一般可以通过 @Reference 注解注入服务代理对象，然后像调用本地方法一样调用服务即可。</li><li>启动消费者应用：启动消费者应用，Dubbo 将自动从注册中心订阅服务提供者的地址列表，并建立连接。</li><li>远程调用：Dubbo 将消费者的请求通过网络协议发送给服务提供者，服务提供者接收请求并返回响应结果，Dubbo 再将响应结果返回给消费者端。</li></ol><p>总的来说，Dubbo完成服务引入的过程就是将服务的代理对象注入到消费者的代码中，并通过网络协议实现远程调用。</p><h3 id="服务发现" tabindex="-1"><a class="header-anchor" href="#服务发现" aria-hidden="true">#</a> 服务发现</h3><blockquote><p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。</p></blockquote><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230318/服务发现.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="hint-container note"><p class="hint-container-title">3.x 与 2.x</p><p>相比于 2.x 版本中的基于接口粒度的服务发现机制，3.x 引入了全新的基于应用粒度的服务发现机制。</p><p>就使用方式上而言，Dubbo3 与 Dubbo2 的服务发现配置是完全一致的，不需要改动什么内容。但就实现原理上而言，Dubbo3 引入了全新的服务发现模型 - 应用级服务发现， 在工作原理、数据格式上已完全不能兼容老版本服务发现。</p></div><p><strong>注册中心：</strong></p><p>服务发现的一个核心组件是注册中心，Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。</p><p>Dubbo 的服务发现机制，让微服务组件之间可以独立演进并任意部署，消费端可以在无需感知对端部署位置与 IP 地址的情况下完成通信。Dubbo 提供的是 Client-Based 的服务发现机制，使用者可以有多种方式启用服务发现：</p><ul><li>使用独立的注册中心组件，如 Nacos、Zookeeper、Consul、Etcd、Redis 等。</li><li>将服务的组织与注册交给底层容器平台，如 Kubernetes，这被理解是一种更云原生的方式</li></ul><div class="hint-container info"><p class="hint-container-title">说明</p><p>区别于其他很多微服务框架的是，<strong>Dubbo3 的服务发现机制诞生于阿里巴巴超大规模微服务电商集群实践场景，因此，其在性能、可伸缩性、易用性等方面的表现大幅领先于业界大多数主流开源产品</strong>。是企业面向未来构建可伸缩的微服务集群的最佳选择。</p></div><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230725/dubbo服务调用.png" alt="service-discovery" tabindex="0" loading="lazy"><figcaption>service-discovery</figcaption></figure><ul><li>首先，Dubbo 注册中心以应用粒度聚合实例数据，消费者按消费需求精准订阅，避免了大多数开源框架如 Istio、Spring Cloud 等全量订阅带来的性能瓶颈。</li><li>其次，Dubbo SDK 在实现上对消费端地址列表处理过程做了大量优化，地址通知增加了异步、缓存、bitmap 等多种解析优化，避免了地址更新常出现的消费端进程资源波动。</li><li>最后，在功能丰富度和易用性上，服务发现除了同步 ip、port 等端点基本信息到消费者外，Dubbo 还将服务端的 RPC/HTTP 服务及其配置的元数据信息同步到消费端，这让消费者、提供者两端的更细粒度的协作成为可能，Dubbo 基于此机制提供了很多差异化的治理能力。</li></ul><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230725/dubbo按需订阅.png" alt="service-discovery" tabindex="0" loading="lazy"><figcaption>service-discovery</figcaption></figure><div class="hint-container info"><p class="hint-container-title">工作流程</p><p>消费者从注册中心接收到地址 (ip:port) 信息，然后与提供者建立连接并通过元数据服务读取到对端的元数据配置信息，两部分信息共同组装成 Dubbo 消费端有效的面向服务的地址列表。</p><p>以上两个步骤都是在实际的 RPC 服务调用发生之前。</p></div><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230725/dubbo提供者消费者工作流程.png" alt="service-discovery" tabindex="0" loading="lazy"><figcaption>service-discovery</figcaption></figure><h3 id="服务网格" tabindex="-1"><a class="header-anchor" href="#服务网格" aria-hidden="true">#</a> 服务网格</h3><p>Service Mesh 在业界得到了广泛的传播与认可，并被认为是下一代的微服务架构，这主要是因为它解决了很多棘手的问题，包括透明升级、多语言、依赖冲突、流量治理等。</p><p>Service Mesh 的典型架构是通过部署独立的 Sidecar 组件来拦截所有的出口与入口流量，并在 Sidecar 中集成丰富的流量治理策略如负载均衡、路由等，除此之外，Service Mesh 还需要一个控制面（Control Panel）来实现对 Sidecar 流量的管控，即各种策略下发。我们在这里称这种架构为经典 Mesh。</p><p>然而任何技术架构都不是完美的，经典 Mesh 在实施层面也面临成本过高的问题</p><ol><li>需要运维控制面（Control Panel）</li><li>需要运维 Sidecar</li><li>需要考虑如何从原有 SDK 迁移到 Sidecar</li><li>需要考虑引入 Sidecar 后整个链路的性能损耗</li></ol><p>为了解决 Sidecar 引入的相关成本问题，Dubbo 引入了另一种变相的 Mesh 架构 - Proxyless Mesh，顾名思义，Proxyless Mesh 就是指没有 Sidecar 的部署，转而由 Dubbo SDK 直接与控制面交互。</p><p>可以设想，在不同的组织、不同的发展阶段，未来以 Dubbo 构建的微服务将会允许有三种部署架构：传统 SDK、基于 Sidecar 的 Service Mesh、脱离 Sidecar 的 Proxyless Mesh。</p><h3 id="服务导出" tabindex="-1"><a class="header-anchor" href="#服务导出" aria-hidden="true">#</a> 服务导出</h3><p>在Dubbo中，服务的导出是通过<code>Protocol</code>和<code>Exporter</code>两个关键组件来实现的。</p><p>首先，<code>Protocol</code>是Dubbo的核心组件之一，它定义了服务协议和网络传输方式，并通过<code>export</code>方法将服务导出为一个或多个<code>Exporter</code>对象，同时通过<code>refer</code>方法引入远程服务。Dubbo内置了多种协议，如Dubbo协议、RMI协议、Hessian协议、HTTP协议等，其中Dubbo协议是Dubbo的默认协议。</p><p>而<code>Exporter</code>则是一个代理对象，用于暴露服务接口，并负责接收和处理客户端请求。在Dubbo中，<code>Exporter</code>通常由<code>Protocol</code>的实现类来创建，它会将服务接口实现包装成一个<code>Invoker</code>对象，并将其绑定到一个网络端口上，以接收客户端请求。</p><p>具体的服务导出流程如下：</p><ol><li>首先，<code>Protocol</code>根据配置文件中指定的协议类型和端口号创建一个对应的实例，例如Dubbo协议的<code>DubboProtocol</code>实例；</li><li>然后，<code>Protocol</code>通过<code>export</code>方法将服务接口和服务实现绑定到创建的实例上，并返回一个或多个<code>Exporter</code>对象；</li><li><code>Exporter</code>负责将服务接口实现包装成一个<code>Invoker</code>对象，并将其绑定到指定的协议和端口上，等待客户端请求；</li><li>客户端通过<code>ProxyFactory</code>创建一个远程服务代理对象，并发起远程调用请求；</li><li><code>Invoker</code>接收到请求后，根据请求信息和服务接口实现执行相应的方法，并将结果返回给客户端。</li></ol><p>需要注意的是，Dubbo支持多协议、多注册中心和多集群等场景，因此，在服务导出时，需要根据实际情况进行配置，以满足不同的业务需求。</p><h2 id="流量" tabindex="-1"><a class="header-anchor" href="#流量" aria-hidden="true">#</a> 流量</h2><h3 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡" aria-hidden="true">#</a> 负载均衡</h3><ol><li>Random Load Balance 随机负载均衡策略：随机选择一个可用的服务提供者。</li><li>Round Robin Load Balance 轮询负载均衡策略：按照顺序轮询选择可用的服务提供者。</li><li>Weighted Random Load Balance 加权随机负载均衡策略：在随机负载均衡策略的基础上，根据每个服务提供者的权重进行加权选择。</li><li>Weighted Round Robin Load Balance 加权轮询负载均衡策略：在轮询负载均衡策略的基础上，根据每个服务提供者的权重进行加权选择。</li><li>Consistent Hash Load Balance 一致性哈希负载均衡策略：将每个服务提供者映射到一个哈希环上，根据请求的哈希值选择距离该哈希值最近的服务提供者。</li><li>Least Active Load Balance 最小活跃数负载均衡策略：选择当前活跃数最少的可用服务提供者，活跃数指当前处理请求的线程数。</li><li>Sticky Load Balance 粘滞会话负载均衡策略：将同一个消费者的请求路由到同一个服务提供者，实现会话粘滞。</li></ol><div class="table-wrapper"><table><thead><tr><th style="text-align:left;">算法</th><th style="text-align:left;">特性</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">Weighted Random LoadBalance</td><td style="text-align:left;">加权随机</td><td style="text-align:left;">默认算法，默认权重相同</td></tr><tr><td style="text-align:left;">RoundRobin LoadBalance</td><td style="text-align:left;">加权轮询</td><td style="text-align:left;">借鉴于 Nginx 的平滑加权轮询算法，默认权重相同，</td></tr><tr><td style="text-align:left;">LeastActive LoadBalance</td><td style="text-align:left;">最少活跃优先 + 加权随机</td><td style="text-align:left;">背后是能者多劳的思想</td></tr><tr><td style="text-align:left;">Shortest-Response LoadBalance</td><td style="text-align:left;">最短响应优先 + 加权随机</td><td style="text-align:left;">更加关注响应速度</td></tr><tr><td style="text-align:left;">ConsistentHash LoadBalance</td><td style="text-align:left;">一致性哈希</td><td style="text-align:left;">确定的入参，确定的提供者，适用于有状态请求</td></tr><tr><td style="text-align:left;">P2C LoadBalance</td><td style="text-align:left;">Power of Two Choice</td><td style="text-align:left;">随机选择两个节点后，继续选择“连接数”较小的那个节点。</td></tr><tr><td style="text-align:left;">Adaptive LoadBalance</td><td style="text-align:left;">自适应负载均衡</td><td style="text-align:left;">在 P2C 算法基础上，选择二者中 load 最小的那个节点</td></tr></tbody></table></div><h3 id="容错策略" tabindex="-1"><a class="header-anchor" href="#容错策略" aria-hidden="true">#</a> 容错策略</h3><div class="table-wrapper"><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>Failover Cluste</td><td>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)。默认容错机制</td></tr><tr><td>Failfast Cluster</td><td>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</td></tr><tr><td>Failsafe Cluster</td><td>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</td></tr><tr><td>Failback Cluster</td><td>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</td></tr><tr><td>Forking Cluster</td><td>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</td></tr><tr><td>Broadcast Cluster</td><td>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</td></tr></tbody></table></div><h3 id="路由规则" tabindex="-1"><a class="header-anchor" href="#路由规则" aria-hidden="true">#</a> 路由规则</h3><div class="hint-container info"><p class="hint-container-title">说明</p><p>流量管理的本质是将请求根据制定好的路由规则分发到应用服务上</p><p>Dubbo 提供了丰富的流量管控策略</p><ul><li><strong>地址发现与负载均衡</strong>，地址发现支持服务实例动态上下线，负载均衡确保流量均匀的分布到每个实例上。</li><li><strong>基于路由规则的流量管控</strong>，路由规则对每次请求进行条件匹配，并将符合条件的请求路由到特定的地址子集。</li></ul></div><p>应用实例可以是单例，也可以是集群</p><p>路由规则可以有多个，不同的路由规则之间存在优先级</p><p>多个不同的路由规则可以到同一个服务；一个路由也可以到不同服务；路由也可以不路由到任何服务</p>',50),p={href:"https://www.w3cschool.cn/dubbo/ab-testing-deployment.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.w3cschool.cn/dubbo/canary-deployment.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.w3cschool.cn/dubbo/blue-green-deployment.html",target:"_blank",rel:"noopener noreferrer"},v=a('<br><p>Dubbo 的流量管控规则可以基于应用、服务、方法、参数等粒度精准的控制流量走向，根据请求的目标服务、方法以及请求体中的其他附加参数进行匹配，符合匹配条件的流量会进一步的按照特定规则转发到一个地址子集。流量管控规则有以下几种：</p><ol><li><p>标签路由规则：</p><ul><li>标签路由规则是一个非此即彼的流量隔离方案，也就是匹配<code>标签</code>的请求会 100% 转发到有相同<code>标签</code>的实例，没有匹配<code>标签</code>的请求会 100% 转发到其余未匹配的实例。</li><li><code>标签</code>主要是指对 Provider 端应用实例的分组，目前有两种方式可以完成实例分组，分别是<code>动态规则打标</code>和<code>静态规则打标</code>。<code>动态规则打标</code> 可以在运行时动态的圈住一组机器实例，而 <code>静态规则打标</code> 则需要实例重启后才能生效，其中，动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</li></ul></li><li><p>条件路由规则：</p><ul><li>条件路由与标签路由的工作模式非常相似，也是首先对请求中的参数进行匹配，符合匹配条件的请求将被转发到包含特定实例地址列表的子集。相比于标签路由，条件路由的匹配方式更灵活。</li><li>在标签路由中，一旦给某一台或几台机器实例打了标签，则这部分实例就会被立马从通用流量集合中移除，不同标签之间不会再有交集。</li><li>从条件路由的视角，所有的实例都是一致的，路由过程中不存在分组隔离的问题，每次路由过滤都是基于全量地址中执行</li></ul></li><li><p>动态配置规则：</p><ul><li>可以动态的修改 Dubbo 服务进程的运行时行为，整个过程不需要重启，配置参数实时生效。基于这个强大的功能，基本上所有运行期参数都可以动态调整，比如超时时间、临时开启 Access Log、修改 Tracing 采样率、调整限流降级参数、负载均衡、线程池配置、日志等级、给机器实例动态打标签等。</li><li>动态配置规则支持应用、服务两个粒度，也就是说一次可以选择只调整应用中的某一个或几个服务的参数配置。</li><li>出于系统稳定性、安全性的考量，有些特定的参数是不允许动态修改的，但除此之外，基本上所有参数都允许动态修改，很多强大的运行态能力都可以通过这个规则实现，您可以找个示例应用去尝试一下。通常 URL 地址中的参数均可以修改，这在每个语言实现的参考手册里也记录了一些更详细的说明。</li></ul></li><li><p>脚本路由规则：</p><ul><li>脚本路由是最直观的路由方式，同时它也是当前最灵活的路由规则，因为可以在脚本中定义任意的地址筛选规则。</li><li>如果我们为某个服务定义一条脚本规则，则后续所有请求都会先执行一遍这个脚本，脚本过滤出来的地址即为请求允许发送到的、有效的地址集合。</li></ul></li></ol><div class="hint-container info"><p class="hint-container-title">说明</p><p>通常，在 Dubbo 中，多个路由器组成一条路由链共同协作，前一个路由器的输出作为另一个路由器的输入，经过层层路由规则筛选后，最终生成有效的地址集合。</p><ul><li>Dubbo 中的每个服务都有一条完全独立的路由链，每个服务的路由链组成可能不通，处理的规则各异，各个服务间互不影响。</li><li>对单条路由链而言，即使每次输入的地址集合相同，根据每次请求上下文的不同，生成的地址子集结果也可能不同。</li></ul></div><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//dubbo/20230725/dubbo路由链路.png" alt="Dubbo Router" tabindex="0" loading="lazy"><figcaption>Dubbo Router</figcaption></figure><h3 id="限流熔断" tabindex="-1"><a class="header-anchor" href="#限流熔断" aria-hidden="true">#</a> 限流熔断</h3><p>根据服务的具体部署情况，服务所能处理的流量上限是一定的，当对服务的请求数量保持在合理的范围时，系统运行正常；而当请求数量严重超过服务处理能力时，如大促期间的流量洪峰等场景，就可能造成服务提供者端的资源过度消耗、负载过高，进而出现响应延迟、请求无应答、系统假死等情况。</p><p>如何确定服务所能处理的流量最大值：</p>',8),m=e("li",null,"一种模式是由用户预先设定一个固定的限流值，如 Dubbo 通过集成 Sentinel 等产品实现的限流能力即是这种模式",-1),f={href:"https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/performance/adaptive-concurrency-control/",target:"_blank",rel:"noopener noreferrer"},D=a(`<p>内置的自适应限流算法设置方法与静态的最大并发值设置类似，只需在服务端设置 flowcontrol 参数即可，可选值有以下两种：</p><ul><li>heuristicSmoothingFlowControl。当服务端收到一个请求时，首先判断CPU的使用率是否超过50%。如果没有超过50%，则接受这个请求进行处理。如果超过50%，说明当前的负载较高，便从 HeuristicSmoothingFlowControl 算法中获得当前的 maxConcurrency 值。如果当前正在处理的请求数量超过了 maxConcurrency，则拒绝该请求。</li><li>autoConcurrencyLimiter。与 HeuristicSmoothingFlowControl 的最大区别是，AutoConcurrencyLimiter 是基于窗口的，每当窗口内积累了一定量的采样数据时，才利用窗口内的数据来更新得到 maxConcurrency，其次，利用exploreRatio来对剩余的容量进行探索。</li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><h3 id="配置管理" tabindex="-1"><a class="header-anchor" href="#配置管理" aria-hidden="true">#</a> 配置管理</h3><ol><li>API 配置</li><li>XML 配置</li><li>Annotation 配置</li><li>属性配置</li></ol><h3 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h3><p>Dubbo 微服务要支持 Kubernetes 平台调度，最基础的就是实现 dubbo 服务生命周期与容器生命周期的对齐，这包括 Dubbo 的启动、销毁、服务注册等生命周期事件。</p><p>相比于以往 Dubbo 自行定义生命周期事件，并要求开发人员在运维实践过程中遵守约定，Kubernetes 底层基础设施定义了严格的组件生命周期事件(probe)，转而要求 Dubbo 去按约定适配。</p><h3 id="安全措施" tabindex="-1"><a class="header-anchor" href="#安全措施" aria-hidden="true">#</a> 安全措施</h3><ol><li>Token 检测，防止绕过注册中心</li><li>提供黑白名单，控制服务方允许的调用方</li></ol><h2 id="实战" tabindex="-1"><a class="header-anchor" href="#实战" aria-hidden="true">#</a> 实战</h2><div class="hint-container info"><p class="hint-container-title">说明</p><p>使用官网提供的示例代码：dubbo-samples</p></div><h3 id="注解驱动" tabindex="-1"><a class="header-anchor" href="#注解驱动" aria-hidden="true">#</a> 注解驱动</h3><h4>Provider Configuration</h4><p>First, there have to be an overall configuration of provider:</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>@Configuration
@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.annotation.impl&quot;)
@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)
static class ProviderConfiguration {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@EnableDubbo</code> will enable Spring <code>org.apache.dubbo.samples.annotation.impl</code> package to find anything annotated by Dubbo annotation.</p><p>As a provider, the interface implementation class have to be annotated by <code>@DubboService</code>:</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>@DubboService
public class AnnotatedGreetingService implements GreetingService {

    public String sayHello(String name) {
        System.out.println(&quot;greeting service received: &quot; + name);
        return &quot;hello, &quot; + name;
    }

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="consumer-configuration" tabindex="-1"><a class="header-anchor" href="#consumer-configuration" aria-hidden="true">#</a> Consumer Configuration</h3><p>The overall configuration for consumer is very smilier to provider&#39;s:</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>@Configuration
@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.samples.annotation.action&quot;)
@PropertySource(&quot;classpath:/spring/dubbo-consumer.properties&quot;)
@ComponentScan(value = {&quot;org.apache.dubbo.samples.annotation.action&quot;})
static class ConsumerConfiguration {

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And you can use <code>@DubboReference</code> annotation to autowire the provider into consumer:</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>@Component(&quot;annotatedConsumer&quot;)
public class GreetingServiceConsumer {

    @DubboReference
    private GreetingService greetingService;
    
    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,24);function y(x,C){const o=d("ExternalLinkIcon");return l(),r("div",null,[c,u,b,e("p",null,[i("Dubbo提供了支持mesh方式的流量管理策略，可以很容易实现 "),e("a",p,[i("A/B测试"),t(o)]),i("、"),e("a",h,[i("金丝雀发布"),t(o)]),i("、"),e("a",g,[i("蓝绿发布"),t(o)]),i("等能力")]),v,e("ol",null,[m,e("li",null,[i("另一种方式是 Dubbo 框架自动根据系统或集群负载情况执行限流，相比用户预先设置限流值更加灵活方便，Dubbo 目前内置了"),e("a",f,[i("自适应限流模式"),t(o)])])]),D])}const P=n(s,[["render",y],["__file","C-服务调用-Dubbo.html.vue"]]);export{P as default};
