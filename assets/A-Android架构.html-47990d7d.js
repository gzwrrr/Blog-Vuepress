import{_ as d,Q as s,S as c,U as e,W as n,X as r,a8 as l,a9 as a,H as t}from"./framework-d7e1aa10.js";const h={},p=e("h1",{id:"android-架构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#android-架构","aria-hidden":"true"},"#"),l(" Android 架构")],-1),_={class:"table-of-contents"},u=a('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>Android系统架构分为五层：</p><ol><li>从上到下依次是应用层（System Apps）</li><li>应用框架层（Java API Framework）</li><li>系统运行库层（Native）</li><li>硬件抽象层(HAL)和Linux内核层。</li><li>AF就是其中的System <strong>Apps</strong>和Java API <strong>Framework</strong>，这两层都是使用Java语言开发的。</li></ol><h2 id="架构设计原则" tabindex="-1"><a class="header-anchor" href="#架构设计原则" aria-hidden="true">#</a> 架构设计原则</h2><p>三大原则：</p><ol><li>关注点分离</li><li>（持久）数据模型驱动界面</li><li>单一数据源（SSOT）与单向数据流（UDF）</li></ol><p>三层架构：</p>',7),g={href:"https://developer.android.google.cn/jetpack/compose?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},f={href:"https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},A=e("li",null,"领域层（网域）",-1),k=e("li",null,[l("数据层： "),e("ul",null,[e("li",null,[l("应用的数据层包含"),e("em",null,"业务逻辑"),l("。业务逻辑决定应用的价值，它包含决定应用如何创建、存储和更改数据的规则。")]),e("li",null,[l("数据层由多个仓库组成，其中每个仓库都可以包含零到多个数据源。您应该为应用中处理的每种不同类型的数据分别创建一个存储库类。例如，您可以为与电影相关的数据创建一个 "),e("code",null,"MoviesRepository"),l(" 类，或者为与付款相关的数据创建一个 "),e("code",null,"PaymentsRepository"),l(" 类。")])])],-1),m=a('<p>此<em>现代应用架构</em>鼓励采用以下方法及其他一些方法：</p><ul><li>反应式分层架构。</li><li>应用的所有层中的单向数据流 (UDF)。</li><li>包含状态容器的界面层，用于管理界面的复杂性。</li><li>协程和数据流。</li><li>依赖项注入最佳实践。</li></ul><p>存储库类负责以下任务：</p><ul><li>向应用的其余部分公开数据。</li><li>集中处理数据变化。</li><li>解决多个数据源之间的冲突。</li><li>对应用其余部分的数据源进行抽象化处理。</li><li>包含业务逻辑。</li></ul><p>每个数据源类应仅负责处理一个数据源，数据源可以是文件、网络来源或本地数据库。数据源类是应用与数据操作系统之间的桥梁。</p><p>此层中的类通常称为“用例”或“交互方”。每个用例都应仅负责单个功能。例如，如果多个 ViewModel 依赖时区在屏幕上显示适当的消息，则您的应用可能具有 <code>GetTimeZoneUseCase</code> 类。</p><h3 id="系统架构" tabindex="-1"><a class="header-anchor" href="#系统架构" aria-hidden="true">#</a> 系统架构</h3><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//android/20231002/android系统结构.png" alt="image-20230922143831716" tabindex="0" loading="lazy"><figcaption>image-20230922143831716</figcaption></figure><p>分为四层：</p><ol><li>应用层：所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play上下载的小游戏，当然还包括你自己开发的程序。</li><li>应用框架层：这一层主要提供了构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者可以使用这些API来构建自己的应用程序。</li><li>系统运行库层 <ol><li>这一层通过一些C/C++库为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGL|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。</li><li>在这一层还有Android运行时库，它主要提供了一些核心库，允许开发者使用Java语言来编写Android应用。</li><li>另外，Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的虚拟机实例。相较于Java虚拟机，Dalvik和ART都是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。</li></ol></li><li>Linux内核层：Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如： <ol><li>显示驱动</li><li>音频驱动</li><li>照相机驱动</li><li>蓝牙驱动</li><li>Wi-Fi驱动</li><li>电源管理</li></ol></li></ol><h3 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h3><p>应用中的类要依赖其他类才能正常工作。可以使用以下任一设计模式来收集特定类的依赖项：</p>',12),v={href:"https://developer.android.google.cn/training/dependency-injection?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},b={href:"https://en.wikipedia.org/wiki/Service_locator_pattern",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,"Android 中有两种主要的依赖项注入方式：",-1),y=e("ul",null,[e("li",null,[e("strong",null,"构造函数注入"),l("：这就是上面描述的方式。您将某个类的依赖项传入其构造函数。")]),e("li",null,[e("strong",null,"字段注入（或 setter 注入）"),l("：某些 Android 框架类（如 activity 和 fragment）由系统实例化，因此无法进行构造函数注入。使用字段注入时，依赖项将在创建类后实例化。")])],-1),w={class:"hint-container note"},D=e("p",{class:"hint-container-title"},"说明",-1),I={href:"https://dagger.dev/",target:"_blank",rel:"noopener noreferrer"},S={href:"https://en.wikipedia.org/wiki/Google_Guice",target:"_blank",rel:"noopener noreferrer"},z={href:"https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},H={href:"https://developer.android.google.cn/training/dependency-injection/dagger-basics?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},J={href:"https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},L={href:"https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},P=e("h3",{id:"最佳实践",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#最佳实践","aria-hidden":"true"},"#"),l(" 最佳实践")],-1),V={class:"hint-container info"},C=e("p",{class:"hint-container-title"},"说明",-1),G={href:"https://mp.weixin.qq.com/s/p811AN6BnYkYpHVuS0Adaw",target:"_blank",rel:"noopener noreferrer"},j=e("ol",null,[e("li",null,"不要将数据存储在应用组件中"),e("li",null,"减少对 Android 类的依赖"),e("li",null,"尽量少公开每个模块中的代码"),e("li",null,"专注于应用的独特核心，以使其从其他应用中脱颖而出"),e("li",null,"考虑如何使应用的每个部分可独立测试"),e("li",null,"保留尽可能多的相关数据和最新数据")],-1);function F(N,U){const o=t("router-link"),i=t("ExternalLinkIcon");return s(),c("div",null,[p,e("nav",_,[e("ul",null,[e("li",null,[n(o,{to:"#android-架构"},{default:r(()=>[l("Android 架构")]),_:1}),e("ul",null,[e("li",null,[n(o,{to:"#前言"},{default:r(()=>[l("前言")]),_:1})]),e("li",null,[n(o,{to:"#架构设计原则"},{default:r(()=>[l("架构设计原则")]),_:1}),e("ul",null,[e("li",null,[n(o,{to:"#系统架构"},{default:r(()=>[l("系统架构")]),_:1})]),e("li",null,[n(o,{to:"#设计模式"},{default:r(()=>[l("设计模式")]),_:1})]),e("li",null,[n(o,{to:"#最佳实践"},{default:r(()=>[l("最佳实践")]),_:1})])])])])])])]),u,e("ol",null,[e("li",null,[l("UI，界面层由以下两部分组成： "),e("ul",null,[e("li",null,[l("在屏幕上呈现数据的界面元素。您可以使用 View 或 "),e("a",g,[l("Jetpack Compose"),n(i)]),l(" 函数构建这些元素。")]),e("li",null,[l("用于存储数据、向界面提供数据以及处理逻辑的状态容器（如 "),e("a",f,[l("ViewModel"),n(i)]),l(" 类）。")])])]),A,k]),m,e("ul",null,[e("li",null,[e("a",v,[l("依赖注入 (DI)"),n(i)]),l("：依赖注入使类能够定义其依赖项而不构造它们。在运行时，另一个类负责提供这些依赖项。")]),e("li",null,[e("a",b,[l("服务定位器"),n(i)]),l("：服务定位器模式提供了一个注册表，类可以从中获取其依赖项而不构造它们。")])]),x,y,e("div",w,[D,e("p",null,[e("a",I,[l("Dagger"),n(i)]),l(" 是适用于 Java、Kotlin 和 Android 的热门依赖项注入库，由 Google 进行维护。Dagger 为您创建和管理依赖关系图，从而便于您在应用中使用 DI。它提供了完全静态和编译时依赖项，解决了基于反射的解决方案（如 "),e("a",S,[l("Guice"),n(i)]),l("）的诸多开发和性能问题。")]),e("p",null,[e("a",z,[l("Hilt"),n(i)]),l(" 是推荐用于在 Android 中实现依赖项注入的 Jetpack 库。Hilt 通过为项目中的每个 Android 类提供容器并自动为您管理其生命周期，定义了一种在应用中执行 DI 的标准方法。")]),e("p",null,[l("Hilt 在热门 DI 库 "),e("a",H,[l("Dagger"),n(i)]),l(" 的基础上构建而成，因而能够受益于 Dagger 提供的编译时正确性、运行时性能、可伸缩性和 Android Studio 支持。（[参考]("),e("a",J,[l("使用 Hilt 实现依赖项注入"),n(i)]),l(")）")]),e("p",null,[l("**官方建议在 Android 应用中采用依赖项注入模式并使用 "),e("a",L,[l("Hilt 库"),n(i)]),l("。**Hilt 通过遍历依赖项树自动构造对象，为依赖项提供编译时保证，并为 Android 框架类创建依赖项容器。")])]),P,e("div",V,[C,e("p",null,[e("a",G,[l("Android 开发最佳实践，让你少走弯路"),n(i)])])]),j])}const B=d(h,[["render",F],["__file","A-Android架构.html.vue"]]);export{B as default};
