import{_ as n,Q as o,S as r,U as l,W as t,X as e,a8 as i,a9 as s,H as u}from"./framework-d7e1aa10.js";const c={},p=l("h1",{id:"java锁优化",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#java锁优化","aria-hidden":"true"},"#"),i(" Java锁优化")],-1),d={class:"table-of-contents"},_=s('<h1 id="java-主流锁体系" tabindex="-1"><a class="header-anchor" href="#java-主流锁体系" aria-hidden="true">#</a> Java 主流锁体系</h1><ul><li>乐观锁、悲观锁</li><li>读锁（共享锁）、写锁（排他锁）</li><li>自旋锁、非自旋锁</li><li>无锁、偏向锁、轻量级锁、重量级锁</li><li>分布式锁</li><li>区间锁（分段锁）</li><li>重入锁、非重入锁</li><li>公平锁、非公平锁</li></ul><p><strong>线程是否要锁住同步资源：</strong></p><ul><li>锁住：悲观锁</li><li>不锁住：乐观锁</li></ul><p><strong>锁住同步资源失败线程是否要阻塞：</strong></p><ul><li>阻塞</li><li>不阻塞： <ul><li>自旋锁</li><li>适应性自旋锁</li></ul></li></ul><p><strong>多个线程竞争同步资源的流程细节：</strong></p><ul><li>不锁住资源，多个线程只有一个能修改资源成功，其他线程会重试——无锁</li><li>同一个线程执行同步资源时自动获得资源——偏向锁</li><li>多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放——轻量级锁</li><li>多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒——总量级锁</li></ul><p><strong>多个线程竞争锁时是否要排队：</strong></p><ul><li><p>排队：公平锁</p></li><li><p>不排队：非公平锁，先尝试插队，插队失败再排队</p></li></ul><p><strong>一个线程的多个流程能不能获取同一把锁：</strong></p><ul><li>能：可重入锁</li><li>不能：不可重入锁</li></ul><p><strong>多个线程能不能共享一把锁：</strong></p><p>能：共享锁</p><p>不能：排他锁</p><h1 id="自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁" aria-hidden="true">#</a> 自旋锁</h1><ul><li>指当一个线程在获得锁时，如果锁已经被其他线程获取，那么该线程将循环等待</li><li>然后不断判断锁是否能被成功获取，自旋直到获取到锁后才退出循环</li></ul><p><strong>自旋锁的意义与使用场景：</strong></p><ul><li>不是用 cas 时：阻塞与唤醒线程需要操作系统切换 CPU 状态，需要消耗一定的时间</li><li>场景：同步代码块逻辑简单，执行时间很短</li></ul><p><strong>自适应自旋：</strong></p><ul><li>假定不同线程持有同一个锁对象的时间基本相当</li><li>竞争度趋于稳定，可以根据上一次自旋的时间与结果调整下一次自旋的时间</li></ul>',21);function h(g,v){const a=u("router-link");return o(),r("div",null,[p,l("nav",d,[l("ul",null,[l("li",null,[t(a,{to:"#java锁优化"},{default:e(()=>[i("Java锁优化")]),_:1})]),l("li",null,[t(a,{to:"#java-主流锁体系"},{default:e(()=>[i("Java 主流锁体系")]),_:1})]),l("li",null,[t(a,{to:"#自旋锁"},{default:e(()=>[i("自旋锁")]),_:1})])])]),_])}const m=n(c,[["render",h],["__file","H-Java锁优化.html.vue"]]);export{m as default};
