import{_ as l,Q as e,S as i,a9 as o}from"./framework-d7e1aa10.js";const c={},d=o('<h1 id="消息总线-springcloudbus" tabindex="-1"><a class="header-anchor" href="#消息总线-springcloudbus" aria-hidden="true">#</a> 消息总线-SpringCloudBus</h1><ul><li>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个公用的消息主题，并让系统中所有微服务实例都链接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称之为消息总线</li><li>基本原理是客户端实例都会监听消息队列中的同一个 <code>topic</code>（默认是 <code>Spring Cloud Bus</code>），当一个服务刷新数据时，它会把这个消息放到该主题中，这样其他监听同一个主题的服务就能得到新的通知，并更新自身的状态</li><li>可以配合 <code>Spring Cloud Config</code> 实现真正的动态配置刷新</li><li>支持两种消息代理：<code>RabbitMQ</code> 和 <code>Kafaka</code></li><li><code>Spring Cloud Bus</code> 是将分布式系统的节点与轻量级消息系统链接起来的框架，整合了 Java 事件处理机制和消息中间件的功能</li><li>能够管理和传播分布式系统间的消息，就像一个分布式执行器，可以用于广播状态更改、事件推送等，也可以作为微服务间的通信通道</li></ul><p><strong>两种触发方式：</strong></p><ul><li><p>利用消息总线触发一个客户端 <code>/bus/refresh</code> 端点从而刷新所有客户端的配置</p></li><li><p>利用消息总线触发一个服务端 <code>/bus/refresh</code> 端点从而刷新所有客户端的配置</p></li><li><p>注意：需要给配置中心的服务端和客户端都加上消息总线的支持</p></li></ul><p><strong>使用客户端通知的弊端：</strong></p><ul><li>打破了微服务的职责单一性，因为客户端本身是业务模块，本就不应该承担配置刷新的职责</li><li>破坏了微服务个节点的平衡性</li><li>存在其他的局限性，如微服务在迁移的时候，网络地址是常常发生改变的，如果这时候想要刷新可能需要更多的修改</li></ul>',6),r=[d];function s(n,u){return e(),i("div",null,r)}const a=l(c,[["render",s],["__file","A-消息总线-SpringCloudBus.html.vue"]]);export{a as default};
