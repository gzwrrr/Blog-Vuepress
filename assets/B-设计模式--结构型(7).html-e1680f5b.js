import{_ as r,Q as _,S as d,U as l,W as e,X as t,a8 as i,a9 as n,H as u}from"./framework-d7e1aa10.js";const h={},p=l("h1",{id:"设计模式-结构型-7",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#设计模式-结构型-7","aria-hidden":"true"},"#"),i(" 设计模式--结构型(7)")],-1),o={class:"table-of-contents"},s=n('<h2 id="_1-适配器模式" tabindex="-1"><a class="header-anchor" href="#_1-适配器模式" aria-hidden="true">#</a> 1.适配器模式</h2><ul><li><p>将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</p></li><li><p>从用户的角度看不到「被适配者 」，是解耦的</p></li><li><p>用户调用适配器转化出来的目标i接口方法，适配器再调用「被适配者」的相关接口方法</p></li><li><p>将一个类中的方法通过适配器进行一定的转换</p></li><li><p>分类：</p><ul><li>类适配器：使用继承的方式</li><li>对象适配器：使用聚合的方式，体现了「合成复用原则」</li><li>接口适配器：使用抽象类实现不同的接口的全部方法，只不过这些方法都是空方法，这样在真正使用的时候就可以单独重写一个方法（匿名类重写方法）并只使用该方法</li></ul></li></ul><br><h2 id="_2-桥接模式" tabindex="-1"><a class="header-anchor" href="#_2-桥接模式" aria-hidden="true">#</a> 2.桥接模式</h2><ul><li><p>结构型设计模式</p></li><li><p>将「实现」和「抽象」放在两个不同的类层次中，使得两个层次可以「独立改变」</p></li><li><p>基于类的「最下设计原则」，通过使用「封装」、「聚合」和「继承」等行为让不同的类承担不同的职责</p></li><li><p>最主要的特点是把「抽象」与「行为实现」分离开来，从而可以保持各个部分的「独立性」以及应对他们的「功能扩展」</p></li></ul><br><h2 id="_3-装饰器模式" tabindex="-1"><a class="header-anchor" href="#_3-装饰器模式" aria-hidden="true">#</a> 3.装饰器模式</h2><ul><li><p>装饰器模式就像打包一个快递，主体是被修饰者，填充/纸板等的就为修饰物</p></li><li><p>动态地将新功能「附加」到对象上。在对象的扩展方面，他比继承更有「弹性」，装饰者模式也体现了开闭原则</p></li><li><p>装饰器中可以包含被装饰者，相当于把饮料往调料里边加，而不是把调料往饮料中加</p></li></ul><br><h2 id="_4-组合模式" tabindex="-1"><a class="header-anchor" href="#_4-组合模式" aria-hidden="true">#</a> 4.组合模式</h2><ul><li><p>结构型型模式</p></li><li><p>又称「部分整体模式」，它创建了对象组的树形结构，将对象组合成树状结构以表示「整体-部分」的关系</p></li><li><p>依据树形结构来组合对象，用来表示部分以及整体层次</p></li><li><p>使得用户对单个对象和组合对象的访问具有「一致性」，即组合能让客户以一致的方式处理个别对象以及组合对象</p></li></ul><br><h2 id="_5-外观模式" tabindex="-1"><a class="header-anchor" href="#_5-外观模式" aria-hidden="true">#</a> 5.外观模式</h2><ul><li><p>又称「过程模式」，位子系统中的「一组接口」提供一个「一致的界面」，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p></li><li><p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节</p></li></ul><br><h2 id="_6-享元模式" tabindex="-1"><a class="header-anchor" href="#_6-享元模式" aria-hidden="true">#</a> 6.享元模式</h2><ol><li>又称「蝇量模式」，运用共享技术有效地支持大量「细粒度」的对象</li><li>常用于系统的底层开发，解决系统性能问题。例如数据库连接池里边都是创建好的连接对象，在这些连接对象中我们需要的则直接拿来用，避免了重复创建，如果没有需要的则再创建一个</li><li>能够解决重复对象的内存浪费问题，当系统中有大量相似的对象，需要缓冲池时，不需要总是创建新的对象，可以从缓存池中拿，这样可以降低系统内存，同时提高效率</li><li>经典的应用场景就是「池」技术，String 常量池/数据库连接池/缓存池等都是享元模式的应用，这是「池」技术的重要实现方式</li></ol><br><h2 id="_7-代理模式" tabindex="-1"><a class="header-anchor" href="#_7-代理模式" aria-hidden="true">#</a> 7.代理模式</h2><ol><li><p>为一个对象提供一个替身，以控制对这个对象的访问</p></li><li><p>通过代理模式访问目标对象的好处是，可与在目标对象实现的基础上，增加「额外的功能操作」，即扩展目标对象的功能</p></li><li><p>被代理的对象可以是「远程对象」，「创建开销打大」的对象，「需要安全控制」的对象</p></li><li><p>代理模式有三种不同的形式：</p><ul><li>静态代理 <ul><li>需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者是继承相同的父类</li><li>能够在不修改目标对象功能的情况下，对目标功能进行扩展</li></ul></li><li>动态代理（JDK 代理/接口代理，主要是使用「反射」） <ul><li>代理对象不需要实现接口，但是目标对象需要实现接口，否则不能用动态代理</li><li>代理对象的生成是利用 JDK 的 API，动态地在内存中构建代理对象</li></ul></li><li>Cglib 代理（可以在内存中动态地创建对象，而不需要实现接口，属于动态代理的范畴） <ul><li>又称子类代理，当目标对象只有一个单独的对象的时候，没有任何的接口，这个时候就可以用目标对象子类来实现代理</li><li>它是在内存中构建一个子类对象从而实现对目标对象功能扩展</li><li>Cglib 是一个强大的高性能的代码生成包，它可以在运行期间扩展 Java 类与实现 Java 接口，它广泛地被许多 AOP 框架使用，实现方法拦截</li><li>在 AOP 编程中的两种代理： <ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</li></ul></li></ul></li><li><p>代理模式的变体：</p><ul><li>防火墙代理：内网通过代理穿透防火墙，实现对公网的访问</li><li>缓存代理：例如：当请求图片文件等资源时，先到缓存代理取，如果取不到资源再到公网或者数据库取，之后再缓存</li><li>远程代理：远程对象的本地代表，通过它可以把远程对象当成本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</li><li>同步代理：主要使用在多线程编程中，完成多线程间的同步工作</li></ul></li></ol>',20);function c(f,b){const a=u("router-link");return _(),d("div",null,[p,l("nav",o,[l("ul",null,[l("li",null,[e(a,{to:"#设计模式-结构型-7"},{default:t(()=>[i("设计模式--结构型(7)")]),_:1}),l("ul",null,[l("li",null,[e(a,{to:"#_1-适配器模式"},{default:t(()=>[i("1.适配器模式")]),_:1})]),l("li",null,[e(a,{to:"#_2-桥接模式"},{default:t(()=>[i("2.桥接模式")]),_:1})]),l("li",null,[e(a,{to:"#_3-装饰器模式"},{default:t(()=>[i("3.装饰器模式")]),_:1})]),l("li",null,[e(a,{to:"#_4-组合模式"},{default:t(()=>[i("4.组合模式")]),_:1})]),l("li",null,[e(a,{to:"#_5-外观模式"},{default:t(()=>[i("5.外观模式")]),_:1})]),l("li",null,[e(a,{to:"#_6-享元模式"},{default:t(()=>[i("6.享元模式")]),_:1})]),l("li",null,[e(a,{to:"#_7-代理模式"},{default:t(()=>[i("7.代理模式")]),_:1})])])])])]),s])}const m=r(h,[["render",c],["__file","B-设计模式--结构型(7).html.vue"]]);export{m as default};
