import{_ as d,Q as c,S as s,U as e,W as l,X as a,a8 as o,a9 as i,H as r}from"./framework-d7e1aa10.js";const h={},p=e("h1",{id:"jetpack-概览",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#jetpack-概览","aria-hidden":"true"},"#"),o(" Jetpack 概览")],-1),u={class:"table-of-contents"},_={class:"hint-container info"},g=e("p",{class:"hint-container-title"},"相关文章",-1),k={href:"https://developer.android.google.cn/jetpack?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},v={href:"https://zhuanlan.zhihu.com/p/334350927",target:"_blank",rel:"noopener noreferrer"},f={class:"table-wrapper"},m=e("thead",null,[e("tr",null,[e("th",null,"组件"),e("th",null,"说明")])],-1),b={href:"https://developer.android.google.cn/jetpack/androidx/releases/activity?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"activity",-1),x=e("td",null,[o("访问基于 "),e("code",null,"activity "),o("构建的可组合 API。")],-1),w={href:"https://developer.android.google.cn/jetpack/androidx/releases/appcompat?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},M=e("code",null,"appcompat",-1),D=e("td",null,[o("允许在平台的旧版 API 上访问新 API（很多使用 "),e("code",null,"Material Design"),o("）。")],-1),L={href:"https://developer.android.google.cn/jetpack/androidx/releases/appsearch?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},A=e("code",null,"appsearch",-1),z=e("td",null,"为用户构建自定义应用内搜索功能。",-1),j={href:"https://developer.android.google.cn/jetpack/androidx/releases/camera?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},W=e("code",null,"camera",-1),V=e("td",null,"构建移动相机应用。",-1),q={href:"https://developer.android.google.cn/jetpack/androidx/releases/compose?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},J=e("code",null,"compose",-1),I=e("td",null,[e("code",null,"Jetpack Compose"),o("是一种声明式的UI框架，用于构建安卓应用的用户界面。它通过使用"),e("code",null,"Kotlin"),o("语言来定义应用的界面结构和外观，取代了传统的XML布局和编程方式。"),e("code",null,"Compose"),o("简化了UI开发过程，提供了更简洁、直观和灵活的方式来构建应用界面")],-1),R={href:"https://developer.android.google.cn/jetpack/androidx/releases/databinding?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},O=e("code",null,"databinding",-1),B=e("td",null,[e("code",null,"Data Binding"),o("是一种用于实现数据和界面绑定的库。它允许开发者在布局文件中直接绑定数据对象，使数据的变化能够自动反映在界面上，减少了手动更新界面的工作，即使用声明性格式将布局中的界面组件绑定到应用中的数据源。")],-1),C={href:"https://developer.android.google.cn/jetpack/androidx/releases/fragment?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"fragment",-1),S=e("td",null,"将您的应用细分为在一个 Activity 中托管的多个独立屏幕。",-1),T={href:"https://developer.android.google.cn/jetpack/androidx/releases/hilt?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},U=e("code",null,"hilt",-1),E=e("td",null,[o("扩展了 "),e("code",null,"Dagger Hilt "),o("的功能，以实现 "),e("code",null,"androidx "),o("库中某些类的依赖项注入。")],-1),N={href:"https://developer.android.google.cn/jetpack/androidx/releases/lifecycle?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},G=e("code",null,"lifecycle",-1),H=e("td",null,[o("构建生命周期感知型组件，这些组件可以根据 "),e("code",null,"activity "),o("或 "),e("code",null,"fragment"),o(" 的当前生命周期状态调整行为。")],-1),Q={href:"https://material.io/develop/android",target:"_blank",rel:"noopener noreferrer"},X=e("code",null,"Material Design 组件",-1),F=e("td",null,[o("适用于 "),e("code",null,"Android"),o(" 的模块化、可自定义 "),e("code",null,"Material Design"),o(" 界面组件。")],-1),K={href:"https://developer.android.google.cn/jetpack/androidx/releases/navigation?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},Y=e("code",null,"navigation",-1),Z=e("td",null,"构建和组织应用内界面，处理深层链接以及在屏幕之间导航。",-1),$={href:"https://developer.android.google.cn/jetpack/androidx/releases/paging?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},ee=e("code",null,"paging",-1),oe=e("td",null,[o("在页面中加载数据，并在 "),e("code",null,"RecyclerView "),o("中呈现。")],-1),le={href:"https://developer.android.google.cn/jetpack/androidx/releases/room?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},te=e("code",null,"room",-1),ne=e("td",null,[o("创建、存储和管理由 "),e("code",null,"SQLite "),o("数据库支持的持久性数据。")],-1),ae={href:"https://developer.android.google.cn/jetpack/androidx/releases/test?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},re=e("code",null,"test",-1),ie=e("td",null,[o("在 "),e("code",null,"Android "),o("中进行测试。")],-1),de={href:"https://developer.android.google.cn/jetpack/androidx/releases/work?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},ce=e("code",null,"work",-1),se=e("td",null,"调度和执行可延期且基于约束条件的后台任务。",-1),he={href:"https://developer.android.google.cn/jetpack/androidx/releases/ads?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},pe=e("code",null,"ads",-1),ue=e("td",null,"获取广告 ID（无论是否通过 Play 服务）。",-1),_e={href:"https://developer.android.google.cn/jetpack/androidx/releases/annotation?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},ge=e("code",null,"annotation",-1),ke=e("td",null,"公开元数据，帮助工具开发者和其他开发者了解您的应用代码。",-1),ve=e("tr",null,[e("td",null,[e("code",null,"ViewModel")]),e("td",null,[e("code",null,"ViewModel"),o("是一种用于管理UI相关数据的架构组件。它可以存储和管理与界面相关的数据，并在配置变化（如旋转屏幕）时保持数据的一致性，以避免数据的丢失和重新加载")])],-1),fe=e("tr",null,[e("td",null,[e("code",null,"LiveData")]),e("td",null,[e("code",null,"LiveData"),o("是一种可观察的数据持有者类，它可以感知生命周期并提供数据的更新和通知机制。"),e("code",null,"LiveData"),o("可以与"),e("code",null,"ViewModel"),o("一起使用，以实现数据的观察和响应")])],-1),me=i(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><div class="hint-container info"><p class="hint-container-title">说明</p><p>Jetpack 非常庞大，主要由基础、架构、行为、界面这4个部分组成。</p><p>能够帮助开发者更好更方便地构建应用程序的组件，Google都将其纳入了Jetpack</p></div><h2 id="viewmodel" tabindex="-1"><a class="header-anchor" href="#viewmodel" aria-hidden="true">#</a> ViewModel</h2><div class="language-groovy line-numbers-mode" data-ext="groovy"><pre class="language-groovy"><code><span class="token comment">// 引入依赖</span>
implementation <span class="token interpolation-string"><span class="token string">&quot;androidx.lifecycle:lifecycle-extensions:2.2.0&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//android/20231001/viewmodel生命周期.png" alt="image-20230928160334188" tabindex="0" loading="lazy"><figcaption>image-20230928160334188</figcaption></figure><h2 id="lifecycles" tabindex="-1"><a class="header-anchor" href="#lifecycles" aria-hidden="true">#</a> Lifecycles</h2><p>在编写Android应用程序的时候，可能会经常遇到需要感知Activity生命周期的情况。比如说，某个界面中发起了一条网络请求，但是当请求得到响应的时候，界面或许已经关闭了，这个时候就不应该继续对响应的结果进行处理。</p><p>因此，我们需要能够时刻感知到Activity的生命周期，以便在适当的时候进行相应的逻辑控制。</p><blockquote><p>TODO</p></blockquote><h2 id="livedata" tabindex="-1"><a class="header-anchor" href="#livedata" aria-hidden="true">#</a> LiveData</h2><blockquote><p>此外还应该关注：RxJava、Flow</p></blockquote><ol><li><p>LiveData是Jetpack提供的一种响应式编程组件，它可以包含任何类型的数据，并在数据发生变化的时候通知给观察者。LiveData特别适合与ViewModel结合在一起使用，虽然它也可以单独用在别的地方，但是在绝大多数情况下，它是使用在ViewModel当中的</p></li><li><p>千万不可以把Activity的实例传给ViewModel，ViewModel的生命周期是长于Activity的，如果把Activity的实例传给ViewModel，就很有可能会因为Activity无法释放而造成内存泄漏</p></li><li><p>LiveData可以包含任何类型的数据，并在数据发生变化的时候通知给观察者。</p></li><li><p>如果你需要在子线程中给LiveData设置数据，一定要调用postValue()方法，而不能再使用setValue()方法，否则会发生崩溃。</p></li></ol><blockquote><p>TODO</p></blockquote><h3 id="map-和-switchmap" tabindex="-1"><a class="header-anchor" href="#map-和-switchmap" aria-hidden="true">#</a> map 和 switchMap</h3><p>LiveData的基本用法虽说可以满足大部分的开发需求，但是当项目变得复杂之后，可能会出现一些更加特殊的需求。</p><p>LiveData为了能够应对各种不同的需求场景，提供了两种转换方法：<code>map()</code>和<code>switchMap()</code>方法。</p><p><code>switchMap()</code>的使用场景非常固定：如果ViewModel中的某个LiveData对象是调用另外的方法获取的，那么我们就可以借助<code>switchMap()</code>方法，将这个LiveData对象转换成另外一个可观察的LiveData对象。</p><blockquote><p>TODO</p></blockquote><h3 id="感知组件生命周期" tabindex="-1"><a class="header-anchor" href="#感知组件生命周期" aria-hidden="true">#</a> 感知组件生命周期</h3><ol><li>LiveData之所以能够成为Activity与ViewModel之间通信的桥梁，并且还不会有内存泄漏的风险，靠的就是Lifecycles组件。LiveData在内部使用了Lifecycles组件来自我感知生命周期的变化，从而可以在Activity销毁的时候及时释放引用，避免产生内存泄漏的问题。</li><li>由于要减少性能消耗，当Activity处于不可见状态的时候（比如手机息屏，或者被其他的Activity遮挡），如果LiveData中的数据发生了变化，是不会通知给观察者的。只有当Activity重新恢复可见状态时，才会将数据通知给观察者，而LiveData之所以能够实现这种细节的优化，依靠的还是Lifecycles组件。</li><li>如果在Activity处于不可见状态的时候，LiveData发生了多次数据变化，当Activity恢复可见状态时，只有最新的那份数据才会通知给观察者，前面的数据在这种情况下相当于已经过期了，会被直接丢弃。</li></ol><blockquote><p>TODO</p></blockquote><h2 id="room" tabindex="-1"><a class="header-anchor" href="#room" aria-hidden="true">#</a> Room</h2>`,22),be={class:"hint-container info"},ye=e("p",{class:"hint-container-title"},"相关文章",-1),xe={href:"https://developer.android.google.cn/topic/libraries/architecture/room?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},we=e("blockquote",null,[e("p",null,"主要由Entity、Dao和Database这3部分组成，每个部分都有明确的职责"),e("p",null,"TODO")],-1),Me=e("h2",{id:"workmanager",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#workmanager","aria-hidden":"true"},"#"),o(" WorkManager")],-1),De={class:"hint-container info"},Le=e("p",{class:"hint-container-title"},"相关文章",-1),Ae={href:"https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},ze=i(`<div class="language-groovy line-numbers-mode" data-ext="groovy"><pre class="language-groovy"><code><span class="token comment">// 引入依赖</span>
implementation <span class="token interpolation-string"><span class="token string">&quot;androidx.work:work-runtime:2.2.0&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>为了解决频繁的功能和API变更，Google推出了WorkManager组件。WorkManager很适合用于处理一些要求定时执行的任务，它可以根据操作系统的版本自动选择，底层是使用AlarmManager实现还是JobScheduler实现，从而降低了我们的使用成本。另外，它还支持周期性任务、链式任务处理等功能，是一个非常强大的工具。</li><li>适合用于持久性工作的推荐解决方案。如果工作始终要通过应用重启和系统重新启动来调度，便是持久性的工作。由于大多数后台处理操作都是通过持久性工作完成的，因此 WorkManager 是适用于后台处理操作的主要推荐 API。</li><li>WorkManager和Service并不相同，也没有直接的联系。Service是Android系统的四大组件之一，它在没有被销毁的情况下是一直保持在后台运行的。而WorkManager只是一个处理定时任务的工具，它可以保证即使在应用退出甚至手机重启的情况下，之前注册的任务仍然将会得到执行，因WorkManager很适合用于执行一些定期和服务器进行交互的任务，比如周期性地同步数据等等。</li><li>使用WorkManager注册的周期性任务不能保证一定会准时执行，这并不是bug，而是系统为了减少电量消耗，可能会将触发时间临近的几个任务放在一起执行，这样可以大幅度地减少CPU被唤醒的次数，从而有效延长电池的使用时间。WorkManager的基本用法其实非常简单，主要分为以下3步：</li></ol><br><p><strong>一般步骤：</strong></p><ol><li>定义一个后台任务，并实现具体的任务逻辑；</li><li>配置该后台任务的运行条件和约束信息，并构建后台任务请求；</li><li>将该后台任务请求传入WorkManager的enqueue()方法中，系统会在合适的时间运行。</li></ol><br><p>后台任务的写法非常固定，也很好理解。首先每一个后台任务都必须继承自Worker类，并调用它唯一的构造函数。然后重写父类中的<code>doWork()</code>方法，在这个方法中编写具体的后台任务逻辑即可。</p><ol><li><code>doWork()</code>方法不会运行在主线程当中，因此可以放心地在这里执行耗时逻辑</li><li><code>doWork()</code>方法要求返回一个<code>Result</code>对象，用于表示任务的运行结果，成功就返回<code>Result.success()</code>，失败就返回<code>Result.failure()</code>。除此之外，还有一个<code>Result.retry()</code>方法，它其实也代表着失败，只是可以结合<code>WorkRequest.Builder</code>的<code>setBackoffCriteria()</code>方法来重新执行任务</li><li>如果后台任务的doWork()方法中返回了Result.retry()，那么是可以结合setBackoffCriteria()方法来重新执行任务的</li><li>可以借助链式编程来实现多个独立的后台任务的调度</li></ol>`,8);function je(We,Ve){const n=r("router-link"),t=r("ExternalLinkIcon");return c(),s("div",null,[p,e("nav",u,[e("ul",null,[e("li",null,[l(n,{to:"#jetpack-概览"},{default:a(()=>[o("Jetpack 概览")]),_:1}),e("ul",null,[e("li",null,[l(n,{to:"#前言"},{default:a(()=>[o("前言")]),_:1})]),e("li",null,[l(n,{to:"#viewmodel"},{default:a(()=>[o("ViewModel")]),_:1})]),e("li",null,[l(n,{to:"#lifecycles"},{default:a(()=>[o("Lifecycles")]),_:1})]),e("li",null,[l(n,{to:"#livedata"},{default:a(()=>[o("LiveData")]),_:1}),e("ul",null,[e("li",null,[l(n,{to:"#map-和-switchmap"},{default:a(()=>[o("map 和 switchMap")]),_:1})]),e("li",null,[l(n,{to:"#感知组件生命周期"},{default:a(()=>[o("感知组件生命周期")]),_:1})])])]),e("li",null,[l(n,{to:"#room"},{default:a(()=>[o("Room")]),_:1})]),e("li",null,[l(n,{to:"#workmanager"},{default:a(()=>[o("WorkManager")]),_:1})])])])])]),e("div",_,[g,e("ul",null,[e("li",null,[e("p",null,[e("a",k,[o("Jetpack 官方文档"),l(t)])])]),e("li",null,[e("p",null,[e("a",v,[o("Jetpack 是什么？"),l(t)])])])])]),e("div",f,[e("table",null,[m,e("tbody",null,[e("tr",null,[e("td",null,[e("a",b,[y,l(t)])]),x]),e("tr",null,[e("td",null,[e("a",w,[M,l(t)])]),D]),e("tr",null,[e("td",null,[e("a",L,[A,l(t)])]),z]),e("tr",null,[e("td",null,[e("a",j,[W,l(t)])]),V]),e("tr",null,[e("td",null,[e("a",q,[J,l(t)])]),I]),e("tr",null,[e("td",null,[e("a",R,[O,l(t)])]),B]),e("tr",null,[e("td",null,[e("a",C,[P,l(t)])]),S]),e("tr",null,[e("td",null,[e("a",T,[U,l(t)])]),E]),e("tr",null,[e("td",null,[e("a",N,[G,l(t)])]),H]),e("tr",null,[e("td",null,[e("a",Q,[X,l(t)])]),F]),e("tr",null,[e("td",null,[e("a",K,[Y,l(t)])]),Z]),e("tr",null,[e("td",null,[e("a",$,[ee,l(t)])]),oe]),e("tr",null,[e("td",null,[e("a",le,[te,l(t)])]),ne]),e("tr",null,[e("td",null,[e("a",ae,[re,l(t)])]),ie]),e("tr",null,[e("td",null,[e("a",de,[ce,l(t)])]),se]),e("tr",null,[e("td",null,[e("a",he,[pe,l(t)])]),ue]),e("tr",null,[e("td",null,[e("a",_e,[ge,l(t)])]),ke]),ve,fe])])]),me,e("div",be,[ye,e("p",null,[e("a",xe,[o("Room 官方文档"),l(t)])])]),we,Me,e("div",De,[Le,e("p",null,[e("a",Ae,[o("WorkManager 官方文档"),l(t)])])]),ze])}const Je=d(h,[["render",je],["__file","A-Jetpack概览.html.vue"]]);export{Je as default};
