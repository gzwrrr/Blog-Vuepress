import{_ as r,Q as c,S as s,U as i,W as l,X as t,a8 as e,a9 as n,H as a}from"./framework-d7e1aa10.js";const p={},h=i("h1",{id:"android-界面绘制",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#android-界面绘制","aria-hidden":"true"},"#"),e(" Android 界面绘制")],-1),u={class:"table-of-contents"},_={class:"hint-container info"},w=i("p",{class:"hint-container-title"},"相关文章",-1),g={href:"https://developer.android.google.cn/guide/topics/resources/drawable-resource?hl=zh-cn#LayerList",target:"_blank",rel:"noopener noreferrer"},f=n('<blockquote><p>控件都可以称为 View 或者视图</p></blockquote><p>两种方式；</p><ol><li>XML</li><li>硬编码</li></ol><p>两种 API：</p><ol><li>View（自定义 View）</li><li>Compose</li></ol><p>界面的构成（使用 UDF 管理，状态向下流动、事件向上流动的这种模式称为单向数据流 (UDF)）：</p><ol><li>元素</li><li>状态</li></ol><p>中级控件</p><p>高级控件</p><p>自定义控件</p><h2 id="udf" tabindex="-1"><a class="header-anchor" href="#udf" aria-hidden="true">#</a> UDF</h2><p>状态向下流动、事件向上流动的这种模式称为单向数据流 (UDF)。这种模式对应用架构的影响如下：</p><ul><li>ViewModel 会存储并公开界面要使用的状态。界面状态是经过 ViewModel 转换的应用数据。</li><li>界面会向 ViewModel 发送用户事件通知。</li><li>ViewModel 会处理用户操作并更新状态。</li><li>更新后的状态将反馈给界面以进行呈现。</li><li>系统会对导致状态更改的所有事件重复上述操作。</li></ul><p>换句话说，UDF 有助于实现以下几点：</p><ul><li><strong>数据一致性</strong>。界面只有一个可信来源。</li><li><strong>可测试性</strong>。状态来源是独立的，因此可独立于界面进行测试。</li><li><strong>可维护性</strong>。状态的更改遵循明确定义的模式，即状态更改是用户事件及其数据拉取来源共同作用的结果。</li></ul>',15),V=i("code",null,"LiveData",-1),b={href:"https://developer.android.google.cn/codelabs/basic-android-kotlin-training-livedata?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},m={href:"https://developer.android.google.cn/kotlin/flow?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},x=i("h2",{id:"用户事件",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#用户事件","aria-hidden":"true"},"#"),e(" 用户事件")],-1),v=i("p",null,"如果用户事件与修改界面元素的状态（如可展开项的状态）相关，界面便可以直接处理这些事件。如果事件需要执行业务逻辑（如刷新屏幕上的数据），则应用由 ViewModel 处理此事件。",-1),y=i("h2",{id:"尺寸",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#尺寸","aria-hidden":"true"},"#"),e(" 尺寸")],-1),L={class:"hint-container info"},k=i("p",{class:"hint-container-title"},"相关文章",-1),D={href:"https://www.jb51.net/article/113125.htm",target:"_blank",rel:"noopener noreferrer"},W=n('<div class="table-wrapper"><table><thead><tr><th>单位/概念</th><th>说明</th></tr></thead><tbody><tr><td>px</td><td>像素（Pixel），是屏幕上的最小可操作单元，通常用于表示图像或屏幕上的点</td></tr><tr><td>resolution</td><td>分辨率，表示屏幕上水平和垂直方向的像素数量，通常以宽x高的形式表示，例如1920x1080</td></tr><tr><td>dpi</td><td>每英寸点数（Dots Per Inch），表示每英寸的线性像素密度，用于测量屏幕或图像的清晰度</td></tr><tr><td>density</td><td>密度，通常指屏幕像素密度或显示设备的像素密度，通常以DPI（每英寸点数）表示</td></tr><tr><td>inch</td><td>英寸，1 英寸约等于2.54厘米，主要用来描述手机屏幕的大小</td></tr><tr><td>pt</td><td>通常用来作为字体的尺寸单位，1 pt相当于1/72英寸</td></tr><tr><td>sp</td><td>大部分人只知道它通常用作字体的尺寸单位，实际大小还与具体设备上的用户设定有关</td></tr><tr><td>dp（dip）</td><td>即设备无关像素（device independent pixels），这种尺寸单位在不同设备上的物理大小相同</td></tr></tbody></table></div><ul><li><p><code>dpi</code>：像素密度</p></li><li><p><code>ldpi</code>：对应的dpi范围为0 ~ 120，也就是说每英寸有0到120个像素点的屏幕的屏幕密度都属于</p></li><li><p><code>mdpi</code>：dpi范围为120 ~ 160</p></li><li><p><code>hdpi</code>：dpi范围为160 ~ 240</p></li><li><p><code>xhdpi</code>：dpi范围为240~320</p></li><li><p><code>xxhdpi</code>：dpi范围为320~480</p></li><li><p><code>px = dip x dpi / 160</code></p></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>对于相同尺寸的手机，即使分辨率不一样，同 dp 的组件占用屏幕的比例也相同</p></div><h2 id="视图-布局" tabindex="-1"><a class="header-anchor" href="#视图-布局" aria-hidden="true">#</a> 视图/布局</h2><p>视图：</p><ol><li><code>ScrollView</code> 垂直滚动视图</li><li><code>HorizontalScrollView</code> 水平滚动视图</li></ol><p>布局（可以自定义后引入，组件化思想）：</p>',7),C=i("li",null,[i("code",null,"LinearLayout"),e(" 线性布局：水平、垂直、权重")],-1),M=i("code",null,"RelativeLayout",-1),A={href:"https://blog.csdn.net/ZQIR12/article/details/127822301",target:"_blank",rel:"noopener noreferrer"},I=i("li",null,[i("code",null,"GridLayout"),e(" 网格布局")],-1),B=i("li",null,[i("code",null,"FrameLayout"),e("：帧布局（外加 Fragment）")],-1),P=i("p",null,"其他：",-1),G=i("ol",null,[i("li",null,"layout_width、layout_height：wrap_content、match_parent、固定大小"),i("li",null,"ViewGroup、Context（Resource）"),i("li",null,"对齐（layout_gravity、gravity）"),i("li",null,"orientation=vertical/horizontal")],-1),R=i("h2",{id:"简单控件",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#简单控件","aria-hidden":"true"},"#"),e(" 简单控件")],-1),F={class:"hint-container info"},S=i("p",{class:"hint-container-title"},"相关文章",-1),T={href:"https://blog.csdn.net/weixin_49770443/article/details/117327634",target:"_blank",rel:"noopener noreferrer"},U=n('<div class="hint-container note"><p class="hint-container-title">说明（XML）</p><p>注意点：需要注意命名空间</p><p>代码中获取 XML 中的组件使用 R 类（gradle 自动生成）直接获取</p><p>层次结构：</p><ol><li>layout</li><li>id</li></ol><p>引用：</p><ol><li>唯一 ID：@+id/</li><li>引用组件：@string/</li></ol></div><p>文本：设置文本的：内容、颜色、宽高</p><ol><li><code>TextView</code>（文本框）</li><li><code>EditView</code>（输入框）</li><li><code>AutoCompleteTextView</code></li></ol><p>选择框：</p><ol><li><code>RadioGroup</code>（单选）</li><li><code>CheckBox</code>（多选）</li></ol><p>按钮：</p><ol><li><code>Button</code>：由 <code>TextView</code> 派生而来 <ol><li><code>onClick </code>点击事件（不推荐直接使用，应当使用监听器）</li><li><code>setOnClickListener</code> 设置监听（实现 <code>View.onOnClickListener</code>）</li><li><code>setOnLongClickListener </code>长按点击事件</li><li>双击事件</li><li>可用/禁用</li></ol></li><li><code>ImageButton</code>（图像按钮）</li><li><code>ToggleButton</code>（开关）</li><li><code>RadioButtun</code>（单选按钮）</li></ol><p>图像：</p><ol><li><code>ImageView</code></li><li><code>ImageButton</code>：继承于 <code>ImageView</code></li><li>同时展示文本和图像：<code>ImageView</code> + <code>TextView</code>、Button 的 drawable 属性</li><li><code>ImageSwitcher</code> / <code>Gallery</code></li></ol><p>列表：</p><ol><li><code>Spinner</code>：下拉列表</li><li><code>ListView</code>：列表（最常用）</li></ol><p>日期/时间：</p><ol><li><code>DatePicker</code>：日期选择器</li><li><code>TimePicker</code>：时间选择器</li></ol><p>提示/对话框：</p><ol><li><code>Toast</code>：提示</li><li><code>Dialog</code>：对话</li></ol><p>进度条：</p><ol><li><code>ProgressBar</code>：进度条</li><li><code>ProgressDialog</code>：对话框中的进度条</li></ol><p>其他：</p><ol><li><code>SeekBar</code>：拖动条</li><li><code>RatingBar</code>：评分组件</li></ol><h2 id="高级控件" tabindex="-1"><a class="header-anchor" href="#高级控件" aria-hidden="true">#</a> 高级控件</h2><p>适配器：</p><ol><li>数组适配器</li><li>简单适配器</li><li>基础适配器</li></ol><p>控件：</p><ol><li>下拉列表</li><li>列表类视图 <ol><li>ListView</li><li>RecyclerView</li><li>GridView</li></ol></li><li>翻页类视图 <ol><li>ViewPager（可以做引导页）</li><li>PagerTabStrip</li></ol></li><li>Fragment（处理适配） <ol><li>生命周期</li><li>静态注册、动态注册</li></ol></li><li>WebView 网页控件</li><li>Snackbar</li><li>DrawerLayout</li><li>NavigationView/circleimageview</li><li>FloatingActionButton</li><li>CoordinatorLayout/FrameLayout</li><li>MaterialCardView</li><li>AppBarLayout</li><li>SwipeRefreshLayout</li><li>CollapsingToolbarLayout</li></ol><h2 id="界面渲染" tabindex="-1"><a class="header-anchor" href="#界面渲染" aria-hidden="true">#</a> 界面渲染</h2><ul><li>每一个Activity都拥有一个Window对象的实例。这个实例实际是PhoneWindow类型的。那么PhoneWindow从名字很容易看出，它应该是Window的儿子</li><li>每一个Activity都有一个PhoneWindow对象，通过setContentView()设置的布局是被放到DecorView中，DecorView是视图树的最顶层</li><li>DecorView继承了FrameLayout，并且一般情况下，它会在先添加一个预设的布局。比如DecorCaptionView，它是从上到下放置自己的子布局的，相当于一个LinearLayout。通常它会有一个标题栏，然后有一个容纳内容的mContentRoot，这个布局的类型视情况而定。我们希望显示的布局就是放到了mContentRoot中。</li><li>WindowManager是在Activity执行attach()时被创建的，attach()方法是在onCreate()之前被调用的。</li><li>WindowManagerImpl持有了PhoneWindow的引用，因此它可以对PhoneWindow进行管理。同时它还持有一个非常重要的引用mGlobal。这个mGlobal指向一个WindowManagerGlobal类型的单例对象，这个单例每个应用程序只有唯一的一个。在图中，我说明了WindowManagerGlobal维护了本应用程序内所有Window的DecorView，以及与每一个DecorView对应关联的ViewRootImpl。这也就是为什么我前面提到过，WindowManager只是一个代理，实际的管理功能是通过WindowManagerGlobal实现的。</li><li>WindowManagerImpl确实只是WindowManagerGlobal的一个代理而已。同时，上面这个方法在整个Android的视图框架流程中十分的重要。我们知道，在Activity执行onResume()后界面就要开始渲染了。原因是在onResume()时，会调用WindowManager的addView()方法(实际最后调用的是WindowManagerGlobal的addView()方法)，把视图添加到窗口上。</li></ul>',26);function z(N,E){const o=a("router-link"),d=a("ExternalLinkIcon");return c(),s("div",null,[h,i("nav",u,[i("ul",null,[i("li",null,[l(o,{to:"#android-界面绘制"},{default:t(()=>[e("Android 界面绘制")]),_:1}),i("ul",null,[i("li",null,[l(o,{to:"#udf"},{default:t(()=>[e("UDF")]),_:1})]),i("li",null,[l(o,{to:"#用户事件"},{default:t(()=>[e("用户事件")]),_:1})]),i("li",null,[l(o,{to:"#尺寸"},{default:t(()=>[e("尺寸")]),_:1})]),i("li",null,[l(o,{to:"#视图-布局"},{default:t(()=>[e("视图/布局")]),_:1})]),i("li",null,[l(o,{to:"#简单控件"},{default:t(()=>[e("简单控件")]),_:1})]),i("li",null,[l(o,{to:"#高级控件"},{default:t(()=>[e("高级控件")]),_:1})]),i("li",null,[l(o,{to:"#界面渲染"},{default:t(()=>[e("界面渲染")]),_:1})])])])])]),i("div",_,[w,i("p",null,[i("a",g,[e("可绘制资源"),l(d)])])]),f,i("p",null,[e("如需关于将 "),V,e(" 用作可观察数据容器的介绍，请参阅"),i("a",b,[e("此 Codelab"),l(d)]),e("。如需关于 Kotlin 数据流的类似介绍，请参阅 "),i("a",m,[e("Android 上的 Kotlin 数据流"),l(d)]),e("。")]),x,v,y,i("div",L,[k,i("p",null,[i("a",D,[e("Android中的常用尺寸单位（dp、sp）快速入门教程"),l(d)])])]),W,i("ol",null,[C,i("li",null,[M,e(" 相对布局："),i("a",A,[e("相关文章"),l(d)])]),I,B]),P,G,R,i("div",F,[S,i("p",null,[i("a",T,[e("Android 常用的控件总结"),l(d)])])]),U])}const O=r(p,[["render",z],["__file","G-Android界面绘制.html.vue"]]);export{O as default};
