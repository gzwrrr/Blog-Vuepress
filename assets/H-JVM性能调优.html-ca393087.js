import{_ as l,Q as o,S as d,U as a,a8 as s,W as e,a9 as n,H as i}from"./framework-d7e1aa10.js";const p={},r=n('<h1 id="jvm-性能调优" tabindex="-1"><a class="header-anchor" href="#jvm-性能调优" aria-hidden="true">#</a> JVM 性能调优</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> 常见问题</h3><ol><li>生产环境出现 OOM 证明处理</li><li>生产环境给服务器分配多少内存合适</li><li>如何对垃圾回收器的性能进行调优</li><li>生产环境 CPU 负载飙高如何处理</li><li>生产环境应该给应用分配多少线程</li><li>不加日志时如何确定请求是否执行了某一行代码</li><li>不加日志时如何查看某个方法的入参和返回值</li></ol><h3 id="为什么调优" tabindex="-1"><a class="header-anchor" href="#为什么调优" aria-hidden="true">#</a> 为什么调优</h3><ol><li>防止或解决 OOM</li><li>减少 Full GC 频率</li></ol><h3 id="监控的依据" tabindex="-1"><a class="header-anchor" href="#监控的依据" aria-hidden="true">#</a> 监控的依据</h3><ol><li>运行日志</li><li>异常堆栈</li><li>GC 日志</li><li>线程快照</li><li>堆转储快照</li></ol><h3 id="性能优化三部曲" tabindex="-1"><a class="header-anchor" href="#性能优化三部曲" aria-hidden="true">#</a> 性能优化三部曲</h3><p><strong>性能监控（发现问题）：</strong></p><ol><li>GC 频繁</li><li>CPU 负载过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间过长</li></ol><p><strong>性能分析（排查问题）：</strong></p><ol><li>使用工具分析日志</li><li>灵活运用命令行工具，比如：jps、jstack、jmap、jinfo</li><li>dump 出堆文件，使用内存分析工具分析</li><li>使用 Arthas、jconsole、jVisualVM 等图形化工具来查看 JVM 状态</li></ol><p><strong>性能调优（解决问题）：</strong></p><ol><li>适当增加内存，根据业务选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>横向扩展服务器资源，分散节点压力</li><li>合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如：缓存、消息队列</li></ol><h3 id="性能指标" tabindex="-1"><a class="header-anchor" href="#性能指标" aria-hidden="true">#</a> 性能指标</h3><ol><li>停顿时间</li><li>吞吐量</li><li>并发数</li><li>内存占用</li></ol><h3 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h3><h4>对象回收</h4><p>在分析 GC 时可回收对象有哪些时还涉及到一下概念：</p><ol><li>浅堆（Shallow Heap）：与浅拷贝对应；不计算当前对象中引用指向的对象的大小，即只包含了当前对象的值、引用、对象头的大小</li><li>深堆（Retained Heap，保留集）：与深拷贝对应；在浅堆的基础上，加上「只能」由当前对象指向的对象的大小</li><li>对象实际大小：在浅堆的基础上，加上由当前对象指向的对象的大小</li><li>支配树：支配是指，如果访问 B 对象只能通过 A 对象，那么 A 对象支配 B 对象及 B 对象支配的对象，由此可以构成一棵支配树</li></ol><p>分析出支配树后，可以很容易找到对象的深堆，深堆的大小就是对象回收后释放的总内存的大小</p><h4>内存泄露与溢出</h4><p>要分清两个问题：</p><ol><li>是否被使用</li><li>是否被需要</li></ol><p>如果被使用中，但是不被需要，就代表可能存在不需要的对象引用未断开的情况，可能有内存泄露</p><p>内存泄露的一些情况：</p><ol><li>静态集合类：静态类指向局部变量</li><li>单例模式：对象生命周期过长</li><li>内部类持有外部类：内部类被其他类引用，这样会导致外部类无法释放</li><li>各种连接：数据库连接、网络连接、IO 连接</li><li>变量不合理的作用域：局部变量提升到全局变量后，只要对象不能被回收，那么该变量也不能被回收</li><li>改变了哈希值：将对象放入 HashSet 之后，如果对象中的某些字段参与了哈希值的计算，并且之后使用中还修改了这些字段的值，那么 HashSet 中的该对象就不能再被使用了</li><li>缓存泄露：本地缓存中的非必须的对象不能被及时清理，此时可以使用弱引用，当内存不足时将这些不是必须的对象回收</li><li>监听器和回调：如果客户端在实现的 API 中注册回调，但是没有显示地取消，那么就会积聚，此时也可以使用弱引用解决</li></ol><h2 id="工具" tabindex="-1"><a class="header-anchor" href="#工具" aria-hidden="true">#</a> 工具</h2><p>基础工具：</p>',30),c=a("li",null,[s("jmap："),a("code",null,"jmap -dump:format=b file=<filename.hprof> <pid>"),s(" 直接在控制台打印出信息。jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列")],-1),u=a("li",null,"jconsole：JDK 自带的监控工具",-1),m={href:"https://juejin.cn/post/6844904152850497543%EF%BC%89",target:"_blank",rel:"noopener noreferrer"},h=a("li",null,"jps：查看运行中的 Java 应用的进程号",-1),b=a("li",null,"jinfo：用来查看正在运行的 java 应用程序的扩展参数",-1),k=a("li",null,"jstat：查看 JVM 内存状态",-1),v=a("li",null,"CHLSDB",-1),g=a("li",null,"jdb",-1),_=a("p",null,"进阶工具：",-1),j=a("ol",null,[a("li",null,"jprofile"),a("li",null,"btrace"),a("li",null,"Greys"),a("li",null,"Arthas"),a("li",null,"javOSizez"),a("li",null,"dmesg")],-1),f=a("p",null,"常见的日志分析工具：",-1),y=a("li",null,"GCViewer：离线工具，比较老",-1),C={href:"https://gceasy.io/",target:"_blank",rel:"noopener noreferrer"},J=a("li",null,"GCHisto：和 GCViewer 类似，不怎么维护了",-1),V=a("li",null,"GCLogViewer",-1),x=a("li",null,"Hpjmeter",-1),B=a("li",null,"garbagecat",-1),M=n(`<p>其他工具：</p><ol><li>Flame Graphs 火焰图：查看方法占用 CPU 的情况</li><li>Tprofiler</li><li>Btrace</li><li>YourKit</li><li>JProbe</li><li>Spring Insight</li></ol><h3 id="命令行工具" tabindex="-1"><a class="header-anchor" href="#命令行工具" aria-hidden="true">#</a> 命令行工具</h3><p>jstat</p><blockquote><p>jstat 命令结构：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p></blockquote><ol><li><code>option</code>：可选参数</li><li><code>interval</code>：用于指定输出统计数据的周期，单位为毫秒</li><li><code>count</code>：用于指定查询的总次数</li><li><code>-t</code>：可以在输出信息前加上一个 Timestamp 列，显示程序运行的时间，单位为秒</li><li><code>-h</code>：可以在周期性数据输出时，输出多少行数据后输出一个表头信息</li><li><code>vmid</code>：进程号</li></ol><p>其中重点为 <code>option</code> 参数，其余参数可由下面的例子解释：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># -t 加上 Timestamp 列，-h3 表示每输出三行再打印一次表头，1688 表示进程号，1000 表示每隔 1 秒输出一次，10 代表一共输出 10 次</span>
jstat <span class="token parameter variable">-class</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">-h3</span> <span class="token number">16788</span> <span class="token number">1000</span> <span class="token number">10</span>

<span class="token comment"># 输出如下：</span>
Timestamp  Loaded  Bytes  Unloaded  Bytes     Time   
<span class="token number">423.1</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
<span class="token number">424.1</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
<span class="token number">425.1</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
Timestamp  Loaded  Bytes  Unloaded  Bytes     Time   
<span class="token number">426.1</span>	   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
<span class="token number">427.1</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
<span class="token number">428.1</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
Timestamp  Loaded  Bytes  Unloaded  Bytes     Time   
<span class="token number">429.1</span>  		<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
<span class="token number">430.2</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
<span class="token number">431.2</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
Timestamp  Loaded  Bytes  Unloaded  Bytes     Time   
<span class="token number">432.2</span>   	<span class="token number">1001</span>  <span class="token number">2247.3</span>        <span class="token number">0</span>     <span class="token number">0.0</span>       <span class="token number">0.07</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="table-wrapper"><table><thead><tr><th>序号</th><th>option</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-class</code></td><td>显示类装载的相关信息</td></tr><tr><td>2</td><td><code>-gc</code></td><td>显示 GC 相关信息</td></tr><tr><td>3</td><td><code>-gccapacity</code></td><td>与 <code>-gc</code> 类似，但是更关注堆区最大/最小内存</td></tr><tr><td>4</td><td><code>-gcutil</code></td><td>与 <code>-gc</code> 类似，但是更关注已使用空间</td></tr><tr><td>5</td><td><code>-gccause</code></td><td>与 <code>-gcutil</code> 一样，但是还会额外打印原因</td></tr><tr><td>6</td><td><code>-gcnew</code></td><td>显示新生代 GC 情况</td></tr><tr><td>7</td><td><code>-gcnewcapacity</code></td><td>与 <code>-gccapacity</code> 类似</td></tr><tr><td>8</td><td><code>-gcold</code></td><td>显示老年代 GC 情况</td></tr><tr><td>9</td><td><code>-gcoldcapacity</code></td><td>与 <code>-gccapacity</code> 类似</td></tr><tr><td>10</td><td><code>-gcpermcapacity</code></td><td>与 <code>-gccapacity</code> 类似（显示永久代）</td></tr><tr><td>11</td><td><code>-compiler</code></td><td>显示 JIT 编译器编译过的方法、耗时等信息</td></tr><tr><td>12</td><td><code>-printcompilation</code></td><td>输出已经被 JIT 编译的方法</td></tr></tbody></table></div><p>补充：jstatd 可以用于监控远程程序，本质是一个 RMI 服务端程序，作用相当于代理服务器，可以建立本地计算机与远程监控工具的通信，然后将本地 Java 程序信息传递到远程计算机</p><h4>jinfo</h4><blockquote><p>查看虚拟机配置参数相关信息，命令结构较为简单：<code>jinfo &lt;option&gt; &lt;pid&gt;</code>，主要分为查看和修改信息</p></blockquote><div class="table-wrapper"><table><thead><tr><th>序号</th><th>option</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-sysprops</code></td><td>查看由 <code>System.getProperties()</code> 获取的参数</td></tr><tr><td>2</td><td><code>-flags</code></td><td>查看曾经赋值过的参数</td></tr><tr><td>3</td><td><code>-flag &lt;具体参数&gt;</code></td><td>查看某个进程的具体参数值</td></tr><tr><td>4</td><td>\`-flag [+</td><td>-]&lt;具体参数&gt;\`</td></tr><tr><td>5</td><td><code>-flag &lt;具体参数&gt;=&lt;具体参数值&gt;</code></td><td>修改某个进程的具体参数，针对非 boolean 类型的参数</td></tr></tbody></table></div><h4>jmap</h4><blockquote><p>导出内存映像文件（dump 文件）和内存使用情况</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息、内存的使用信息</span>
jmap -histo<span class="token punctuation">[</span>:<span class="token punctuation">[</span><span class="token operator">&lt;</span>histo-options<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>

<span class="token comment"># 生成转储快照，即 dump 文件</span>
jmap -dump:<span class="token operator">&lt;</span>dump-options<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>

<span class="token comment"># 仅仅 linux/solaris 平台有效，显示再 F-Queue 队列中等待 Finalizer 线程执行 finalize 方法的对象</span>
jmap <span class="token parameter variable">-finalizerinfo</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>

<span class="token comment"># 其他</span>
jmap -? <span class="token parameter variable">-h</span> <span class="token parameter variable">--help</span>
jmap <span class="token parameter variable">-clstats</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 生成 dump 文件</span>
jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span><span class="token operator">&lt;</span>filename.hprof<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>

<span class="token comment"># 只将堆存活的对象放到 dump 文件中</span>
jmap -dump:live,format<span class="token operator">=</span>b,file<span class="token operator">=</span><span class="token operator">&lt;</span>filename.hprof<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：jmap 必须在安全点上进行操作，而 jstat 是可以实时获取数据的</p><h4>jhat</h4>`,19),T={href:"http://localhost:7000",target:"_blank",rel:"noopener noreferrer"},G=n('<p>注意：jhat 在 JDK 9 之后就被删除了，官方建议使用 Visual VM 代替</p><h4>jstack</h4><blockquote><p>用于生成虚拟机指定进程当前时刻的线程快照 Thread Dump，命令结构为：<code>jstack -&lt;option&gt; &lt;pid&gt;</code></p></blockquote><div class="table-wrapper"><table><thead><tr><th>序号</th><th>option</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-F</code></td><td>当正常的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>2</td><td><code>-l</code></td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>3</td><td><code>-m</code></td><td>如果调用的是本地方法，可以显示 C/C++ 的堆栈</td></tr><tr><td>4</td><td><code>-h</code></td><td>查看帮助信息</td></tr></tbody></table></div><h4>jcmd</h4><blockquote><p>多功能工具，可以实现之前的除了 jstat 之外的所有命令的功能，jcmd 有 jmap 的大部分功能，并且官方也建议使用 jcmd 代替 jmap</p></blockquote><div class="table-wrapper"><table><thead><tr><th>序号</th><th>option</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>-l</code></td><td>列出所有 JVM 进程</td></tr><tr><td>2</td><td><code>&lt;pid&gt; help</code></td><td>针对指定的进程列出支持的所有指令</td></tr><tr><td>3</td><td><code>&lt;pid&gt; &lt;具体命令&gt;</code></td><td>配合上面的命令，对指定进程执行具体命令</td></tr></tbody></table></div><h3 id="图形化工具" tabindex="-1"><a class="header-anchor" href="#图形化工具" aria-hidden="true">#</a> 图形化工具</h3><h4>jConsole</h4><p>JDK 自带的可视化监控工具，可以查看 Java 应用程序的运行情况、监控堆信息、元空间使用情况、类加载情况等</p><h4>VisualVM</h4><blockquote><p>注意：分为 jVisualVM 和 VisualVM，都差不多，前者在 JDK 中就有，而后者需要单独下载</p></blockquote><p>JDK 提供的可视化监控工具，用于查看虚拟机运行的应用程序的详细信息</p><h4>JMC</h4><p>内置了 Java Flight Recorder，能够以极低的开销收集 Java 虚拟机的性能数据</p><h4>MAT</h4><p>基于 Eclipse 的内存分析工具，是一个快速、功能丰富的堆分析工具，可以帮助查找内存泄露和减少内存消耗</p><p>MAT 功能较为强大，可以很容易看出内存情况，比如给出了支配树、分析报告等</p><h4>JProfiler</h4><p>与 Visual VM 类似，功能强大的商业软件，但是需要付费</p><ol><li>跨平台、使用简单、界面友好</li><li>对分析的应用影响小</li><li>对 CPU、线程、内存的分析功能强大</li><li>对 JDBC、NoSQL、JSP、Servlet 等也提供分析功能</li><li>支持在线和离线模式，可以监控本地、远程环境</li></ol><p>包含的功能：</p><ol><li>遥感监测数据视图分析</li><li>内存视图分析</li><li>Heap Walker</li><li>CPU 视图分析</li><li>线程视图分析</li></ol><h4>Arthas</h4><p>Alibaba 开源 Java 诊断工具（用的比较多）</p><h4>Btrace</h4><p>Java 运行时追踪工具，可以在不停机的情况下跟踪指定的方法调用、构造函数调用、系统内存信息等</p>',27);function q(H,S){const t=i("ExternalLinkIcon");return o(),d("div",null,[r,a("ol",null,[c,u,a("li",null,[s("jstack：线程堆栈分析工具（"),a("a",m,[s("https://juejin.cn/post/6844904152850497543）"),e(t)])]),h,b,k,v,g]),_,j,f,a("ol",null,[y,a("li",null,[s("GCEasy：在线工具，官网 "),a("a",C,[s("https://gceasy.io/"),e(t)])]),J,V,x,B]),M,a("blockquote",null,[a("p",null,[s("与 jmap 搭配使用，用于分析 dump 文件。jhat 内置了 HTTP 服务器，用户可以在浏览器中查看分析结果，默认访问地址为："),a("a",T,[s("http://localhost:7000"),e(t)])])]),G])}const w=l(p,[["render",q],["__file","H-JVM性能调优.html.vue"]]);export{w as default};
