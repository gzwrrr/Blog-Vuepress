import{_ as s,Q as e,S as l,U as o,W as n,X as a,a8 as t,a9 as r,H as c}from"./framework-d7e1aa10.js";const d={},p=o("h1",{id:"windows-文件管理",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#windows-文件管理","aria-hidden":"true"},"#"),t(" Windows 文件管理")],-1),g=o("div",{class:"hint-container info"},[o("p",{class:"hint-container-title"},"说明"),o("p",null,"个人 Windows 上的文件管理方案，如果觉得不妥或者有更好的方案可以评论一下")],-1),h={class:"table-of-contents"},u=r('<h2 id="为什么会考虑文件管理" tabindex="-1"><a class="header-anchor" href="#为什么会考虑文件管理" aria-hidden="true">#</a> 为什么会考虑文件管理？</h2><p><strong>起初：</strong> 两年前刚开始学习编程时电脑都不太会用，对文件管理一点概念都没有，经常出现找不到文件或者 C 盘时常脸红</p><br><p><strong>萌芽：</strong> 随着编程需要的「环境/配置/依赖」越来越多，逐渐意识到不好好管理文件就可能每次需要时重新配置一下，非常打乱节奏，于是开始清理以及重装</p><br><p><strong>曲折：</strong> 最初的方案是根据 <strong>带含义的长目录名</strong> 管理，例如 <code>A-Multi-Software-N</code>（表示用于存放所有软件，目录不可移动，大概这种意思），当时一味地认为分层够多，层级够深就可以很好的管理，但实际上分层多分层深只会找得累，时间长了自己都不记得；目录名长则是新建时很折磨。之后甚至还因为文件路径太长导致系统环境变量满了（我还手残不小心删了，只能全部重新配置），折磨久了就完全放弃了这种冗长的方案。</p><br><p><strong>如今：</strong> 上面的经历提醒我做好文件管理，<strong>分层不能太多，名称不能太长，但是含义必须明确</strong>，当层级超过三层左右查找就变得吃力，此时应该考虑 <strong>平铺</strong> 管理。当前的理念或者目标就是：</p><ol><li><strong>快捷</strong>： 不要过分追求多层次的树状结构，超过一定层级后就开始平铺，一切都是为了 <strong>快速查询</strong> 而服务的</li><li><strong>规范</strong>： 命名统一（我采用的是大驼峰命名），并且用尽可能少的单词解释含义，目的是在需要分类时能第一时间想到并找到对应的目录在哪</li><li><strong>易备份</strong>： 每一类别集中管理，同时要方便备份（备份时直接压缩某一类的底层目录即可），目的是将数据迁移的成本降至最低，比如「软件安装路径及其数据等」与「软件安装包/压缩包」分离（我最初的方案是都放在一起，后来发现备份时很麻烦）</li></ol><h2 id="当前管理模式" tabindex="-1"><a class="header-anchor" href="#当前管理模式" aria-hidden="true">#</a> 当前管理模式</h2><blockquote><p>先直接感受下是否整齐，第一个图片是 C 盘，第二个图片是 D 盘。</p><p>已经使用挺久了，过程没有什么大问题</p></blockquote><div class="hint-container note"><p class="hint-container-title">话外音</p><p>C 盘其实不应该放这么多东西，太多会导致系统卡顿（即便是做好了管理），我这里主要是因为 D 盘是后来加的，当时 C 盘已经存了很多东西，迁移成本太大就保持这样了，我下面 C 盘中的所有分层其实都可以转移到 D 盘中。</p><p>有条件还是建议尽量存在系统盘之外的盘符中。</p></div><details class="hint-container details"><summary>C 盘</summary><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//文件管理/20230310/文件管理1.png" alt="文件管理" tabindex="0" loading="lazy"><figcaption>文件管理</figcaption></figure></details><details class="hint-container details"><summary>D 盘</summary><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//文件管理/20230310/文件管理2.png" alt="文件管理2" tabindex="0" loading="lazy"><figcaption>文件管理2</figcaption></figure></details><br><p><strong>可以看到顶级目录主要有：</strong></p><p>静态（路径不能随意改变，不必迁移备份，例如软件不能随意移动，不需要备份管理）：</p><ol><li>Software：全部软件</li><li>Config：全部配置/依赖</li></ol><p>动态（路径可能随时修改，需要备份迁移等）：</p><ol><li>Data：全部工作数据</li><li>Code：全部源码</li><li>Resoure：全部可用（有用）资源（例如特殊的软件安装包/破解，学习资料等）</li><li>Backup：非本地文件的备份（例如我云盘中的资源）</li><li>Photos：相册</li></ol><p>可以发现有些是存在包含关系的（比如 Resoure 可以包含 Photos），我没有包含是因为我对于顶层目录的看法是：动静分离，习惯大于包含</p><br><p><strong>动静分离</strong>：这样做动态的资源备份或迁移打包即可</p><p><strong>习惯大于包含</strong>：常常使用到的不必要非得包含在某一类中，可以按照使用频率平铺开来，自己习惯才最重要</p><h2 id="对于软件的管理" tabindex="-1"><a class="header-anchor" href="#对于软件的管理" aria-hidden="true">#</a> 对于软件的管理</h2><blockquote><p>首先就是安装包与程序本身及其数据分离，程序本身及其数据集中管理</p></blockquote><p>例如对虚拟机的管理：</p><ol><li>Software：软件本体</li><li>Data：软件数据</li><li>Cache：缓存</li><li>VirtualMachines：不同虚拟机</li></ol><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//文件管理/20230310/软件管理1.png" alt="image-20230310003140802" tabindex="0" loading="lazy"><figcaption>image-20230310003140802</figcaption></figure><p>此外，超过三层后直接采用平铺，避免层级太深不好寻找</p><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//文件管理/20230310/软件管理2.png" alt="image-20230310003521564" tabindex="0" loading="lazy"><figcaption>image-20230310003521564</figcaption></figure><blockquote><p>TODO 待补充……</p></blockquote>',32);function f(m,_){const i=c("router-link");return e(),l("div",null,[p,g,o("nav",h,[o("ul",null,[o("li",null,[n(i,{to:"#windows-文件管理"},{default:a(()=>[t("Windows 文件管理")]),_:1}),o("ul",null,[o("li",null,[n(i,{to:"#为什么会考虑文件管理"},{default:a(()=>[t("为什么会考虑文件管理？")]),_:1})]),o("li",null,[n(i,{to:"#当前管理模式"},{default:a(()=>[t("当前管理模式")]),_:1})]),o("li",null,[n(i,{to:"#对于软件的管理"},{default:a(()=>[t("对于软件的管理")]),_:1})])])])])]),u])}const w=s(d,[["render",f],["__file","Windows 文件管理.html.vue"]]);export{w as default};
