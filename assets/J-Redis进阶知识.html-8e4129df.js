import{_ as p,Q as r,S as o,U as s,W as e,X as i,a8 as n,a9 as c,H as t}from"./framework-d7e1aa10.js";const d={},m=s("h1",{id:"redis-进阶知识",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#redis-进阶知识","aria-hidden":"true"},"#"),n(" Redis 进阶知识")],-1),k={class:"table-of-contents"},u=c(`<h2 id="对象机制" tabindex="-1"><a class="header-anchor" href="#对象机制" aria-hidden="true">#</a> 对象机制</h2><p>Redis 对键的处理占了大部分，Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</p><p>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理，为此<strong>Redis 构建了自己的类型系统：</strong></p><ul><li>redisObject 对象.</li><li>基于 redisObject 对象的类型检查.</li><li>基于 redisObject 对象的显式多态函数.</li><li>对 redisObject 进行分配、共享和销毁的机制.</li></ul><p>redis使用自己实现的对象机制（redisObject)来实现类型判断、命令多态和基于引用次数的垃圾回收；</p><p>redis会预分配一些常用的数据对象，并通过共享这些对象来减少内存占用，和避免频繁的为小对象分配内存。</p><h3 id="redisobject" tabindex="-1"><a class="header-anchor" href="#redisobject" aria-hidden="true">#</a> RedisObject</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * Redis 对象
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类型</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 编码方式</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">// LRU_BITS: 24</span>
    <span class="token comment">// 引用计数</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token comment">// 指向底层数据结构实例</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></p><ul><li><p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p></li><li><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存</p></li></ul><br><p><strong>type 常量如下：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
* 对象类型
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_STRING</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">// 字符串</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_LIST</span> <span class="token expression"><span class="token number">1</span> </span><span class="token comment">// 列表</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_SET</span> <span class="token expression"><span class="token number">2</span> </span><span class="token comment">// 集合</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ZSET</span> <span class="token expression"><span class="token number">3</span> </span><span class="token comment">// 有序集</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_HASH</span> <span class="token expression"><span class="token number">4</span> </span><span class="token comment">// 哈希表</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>对象保存的值的编码：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
* 对象编码
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_RAW</span> <span class="token expression"><span class="token number">0</span>     </span><span class="token comment">/* Raw representation */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_INT</span> <span class="token expression"><span class="token number">1</span>     </span><span class="token comment">/* Encoded as integer */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_HT</span> <span class="token expression"><span class="token number">2</span>      </span><span class="token comment">/* Encoded as hash table */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_ZIPMAP</span> <span class="token expression"><span class="token number">3</span>  </span><span class="token comment">/* 注意：版本2.6后不再使用. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_LINKEDLIST</span> <span class="token expression"><span class="token number">4</span> </span><span class="token comment">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_ZIPLIST</span> <span class="token expression"><span class="token number">5</span> </span><span class="token comment">/* Encoded as ziplist */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_INTSET</span> <span class="token expression"><span class="token number">6</span>  </span><span class="token comment">/* Encoded as intset */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_SKIPLIST</span> <span class="token expression"><span class="token number">7</span>  </span><span class="token comment">/* Encoded as skiplist */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_EMBSTR</span> <span class="token expression"><span class="token number">8</span>  </span><span class="token comment">/* Embedded sds string encoding */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_QUICKLIST</span> <span class="token expression"><span class="token number">9</span> </span><span class="token comment">/* Encoded as linked list of ziplists */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OBJ_ENCODING_STREAM</span> <span class="token expression"><span class="token number">10</span> </span><span class="token comment">/* Encoded as a radix tree of listpacks */</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="对象共享" tabindex="-1"><a class="header-anchor" href="#对象共享" aria-hidden="true">#</a> 对象共享</h3><blockquote><p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间</p></blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等自勉之的内存数据结构</p><p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p><ul><li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li><li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li><li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li></ul><p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的</p><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><ol><li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li><li>当新创建一个对象时，它的refcount属性被设置为1；</li><li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li><li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放</li></ol><h2 id="底层数据结构" tabindex="-1"><a class="header-anchor" href="#底层数据结构" aria-hidden="true">#</a> 底层数据结构</h2><ul><li>简单动态字符串 - sds（Redis 自己实现的动态字符串）</li><li>压缩列表 - ZipList（双向链表，元素大小自适应）</li><li>快表 - QuickList（以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist）</li><li>字典/哈希表 - Dict（本质上就是哈希表）</li><li>整数集 - IntSet（集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现）</li><li>跳表 - ZSkipList（跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。占用空间较大，属于空间换时间）</li></ul><h2 id="基础类型与底层结构的对应" tabindex="-1"><a class="header-anchor" href="#基础类型与底层结构的对应" aria-hidden="true">#</a> 基础类型与底层结构的对应</h2><h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h3><p>字符串对象的编码可以是<mark>int，raw或者embstr</mark></p><ul><li><code>int 编码</code>：保存的是可以用 long 类型表示的整数值</li><li><code>embstr 编码</code>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节，使用redisObject和sds保存数据）</li><li><code>raw 编码</code>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节，使用redisObject和sds保存数据）</li></ul><p><mark>区别</mark>：embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</p><p>注意：</p><ul><li>Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型</li><li>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw</li><li>对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节</li></ul><h3 id="列表对象" tabindex="-1"><a class="header-anchor" href="#列表对象" aria-hidden="true">#</a> 列表对象</h3><p>list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构</p><p>列表对象的编码是 <mark>quicklist</mark>（ (之前版本中有 linked 和 ziplist 这两种编码）</p><h3 id="哈希对象" tabindex="-1"><a class="header-anchor" href="#哈希对象" aria-hidden="true">#</a> 哈希对象</h3><p>哈希对象的键是一个字符串类型，值是一个键值对集合</p><p>哈希对象的编码可以是 <mark>ziplist 或者 hashtable</mark>；对应的底层实现有两种, 一种是 ziplist, 一种是 dict</p><p>注意：当采用HT编码，即使用dict作为哈希对象的底层数据结构时，键与值均是以sds的形式存储的</p><br><p><strong>编码转换：</strong></p><p>和上面列表对象使用 ziplist 编码一样，当同时满足下面两个条件时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节</li></ol><p>不能满足这两个条件的时候使用 hashtable 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改</p><h3 id="集合对象" tabindex="-1"><a class="header-anchor" href="#集合对象" aria-hidden="true">#</a> 集合对象</h3><p>集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合</p><p>注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复</p><p>集合对象的编码可以是 <mark>intset 或者 hashtable</mark>， 底层实现有两种, 分别是 intset 和 dict</p><p><strong>编码转换</strong></p><p>当集合同时满足以下两个条件时，使用 intset 编码：</p><ol><li><p>集合对象中所有元素都是整数</p></li><li><p>集合对象所有元素数量不超过512</p></li></ol><p>不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置</p><h3 id="有序集合对象" tabindex="-1"><a class="header-anchor" href="#有序集合对象" aria-hidden="true">#</a> 有序集合对象</h3><p>与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据</p><p>有序集合的底层实现依然有两种, 一种是使用 <mark>ziplist</mark> 作为底层实现, 另外一种比较特殊, 底层使用了两种数据结构: <mark>dict 与 skiplist</mark>. 前者对应的编码值宏为ZIPLIST, 后者对应的编码值宏为SKIPLIST</p><p><mark>注意：</mark></p><p>其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合</p><p><strong>编码转换：</strong></p><p>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><p>1、保存的元素数量小于128；</p><p>2、保存的所有元素长度都小于64字节。</p><p>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改</p><h2 id="redis-的事件机制" tabindex="-1"><a class="header-anchor" href="#redis-的事件机制" aria-hidden="true">#</a> Redis 的事件机制</h2><p>用于处理两类事件：</p><ol><li><p><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</p></li><li><p><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</p></li></ol><h3 id="文件事件" tabindex="-1"><a class="header-anchor" href="#文件事件" aria-hidden="true">#</a> 文件事件</h3><div class="hint-container info"><p class="hint-container-title">网络事件处理器</p><p>Redis基于<strong>Reactor模式</strong>开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p></div><p>基于多路复用的Redis高性能IO模型为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。那么，回调机制是怎么工作的呢？</p><p>其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p><h3 id="时间事件" tabindex="-1"><a class="header-anchor" href="#时间事件" aria-hidden="true">#</a> 时间事件</h3><p>Redis 的时间事件分为以下两类：</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>服务器所有的时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件，所以不影响事件执行的性能。</p>`,73),h={class:"hint-container info"},v=s("p",{class:"hint-container-title"},"文章出处",-1),b={href:"https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html",target:"_blank",rel:"noopener noreferrer"};function _(f,g){const a=t("router-link"),l=t("ExternalLinkIcon");return r(),o("div",null,[m,s("nav",k,[s("ul",null,[s("li",null,[e(a,{to:"#redis-进阶知识"},{default:i(()=>[n("Redis 进阶知识")]),_:1}),s("ul",null,[s("li",null,[e(a,{to:"#对象机制"},{default:i(()=>[n("对象机制")]),_:1}),s("ul",null,[s("li",null,[e(a,{to:"#redisobject"},{default:i(()=>[n("RedisObject")]),_:1})]),s("li",null,[e(a,{to:"#对象共享"},{default:i(()=>[n("对象共享")]),_:1})]),s("li",null,[e(a,{to:"#引用计数"},{default:i(()=>[n("引用计数")]),_:1})])])]),s("li",null,[e(a,{to:"#底层数据结构"},{default:i(()=>[n("底层数据结构")]),_:1})]),s("li",null,[e(a,{to:"#基础类型与底层结构的对应"},{default:i(()=>[n("基础类型与底层结构的对应")]),_:1}),s("ul",null,[s("li",null,[e(a,{to:"#字符串"},{default:i(()=>[n("字符串")]),_:1})]),s("li",null,[e(a,{to:"#列表对象"},{default:i(()=>[n("列表对象")]),_:1})]),s("li",null,[e(a,{to:"#哈希对象"},{default:i(()=>[n("哈希对象")]),_:1})]),s("li",null,[e(a,{to:"#集合对象"},{default:i(()=>[n("集合对象")]),_:1})]),s("li",null,[e(a,{to:"#有序集合对象"},{default:i(()=>[n("有序集合对象")]),_:1})])])]),s("li",null,[e(a,{to:"#redis-的事件机制"},{default:i(()=>[n("Redis 的事件机制")]),_:1}),s("ul",null,[s("li",null,[e(a,{to:"#文件事件"},{default:i(()=>[n("文件事件")]),_:1})]),s("li",null,[e(a,{to:"#时间事件"},{default:i(()=>[n("时间事件")]),_:1})])])])])])])]),u,s("div",h,[v,s("p",null,[n("出自「Java 全栈知识体系」，原文链接："),s("a",b,[n("https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-object.html"),e(l)])])])])}const O=p(d,[["render",_],["__file","J-Redis进阶知识.html.vue"]]);export{O as default};
