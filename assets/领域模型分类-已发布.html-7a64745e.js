import{_ as o,Q as n,S as r,U as e,W as i,X as a,a8 as t,a9 as s,H as c}from"./framework-d7e1aa10.js";const d={},u=e("h1",{id:"领域模型分类",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#领域模型分类","aria-hidden":"true"},"#"),t(" 领域模型分类")],-1),O={class:"table-of-contents"},b=s('<h1 id="写在前面" tabindex="-1"><a class="header-anchor" href="#写在前面" aria-hidden="true">#</a> 写在前面</h1><blockquote><p>以下探讨的不是 DDD 领域驱动设计的内容，而是 MVC 架构中的 Model 一层；虽然概念比较多，一开始可能也比较摸不着头脑（会有疑问：为什么要弄得这么复杂），但是有一定的开发经验后再回过头来理解，就会发现其中的好处，所以这里就先放下疑问，先了解完再思考</p></blockquote><p><strong>领域模型大致有五类：</strong></p><ul><li>VO</li><li>DTO</li><li>DO</li><li>BO</li><li>PO</li></ul><p><strong>此外，还有一些关联的概念：</strong></p><ul><li>Entity</li><li>Domain</li><li>POJO</li></ul><br><h1 id="vo-view-object" tabindex="-1"><a class="header-anchor" href="#vo-view-object" aria-hidden="true">#</a> VO (View Object)</h1><blockquote><p><strong>门面</strong>：出去见人前要先把自己收拾好，让别人看到想看的；对接<strong>搬运工</strong>，拿到自己想要的东西再收拾自己</p></blockquote><ul><li>视图对象</li><li>用于展示层</li><li>用于把某个指定页面或者组件的所有数据封装起来</li><li>VO 对象中的数据一般是 DTO 经过一定的业务逻辑转化而来的（值或者字段可能都不一样）</li></ul><p>注：还用一种 VO 是指 Value Object，是只有状态而没有行为的对象，相关概念有贫血模型，这里就不展开叙述了</p><br><h1 id="dto-data-transfer-object" tabindex="-1"><a class="header-anchor" href="#dto-data-transfer-object" aria-hidden="true">#</a> DTO (Data Transfer Object)</h1><blockquote><p><strong>搬运工</strong>：搬运前要将物品（数据）搬上车整理好；对接<strong>门面</strong>，交付物品</p></blockquote><ul><li>数据传输对象</li><li>原本来源于 J2EE 的设计模式，旨在提供粗粒度的数据实体，减少分布式调用的次数，降低网络负载，提高性能</li><li>另一层是泛指展示层和服务层之间用于数据传输的对象</li></ul><p><strong>两种存在形式：</strong></p><ul><li>前端：DTO 存在形式通常是 JS 中的（JSON） 对象，是通过异步请求获取到的数据对象</li><li>后端：上述提到的传输对象，不需要考虑前后端对象的转换，使用的框架一般都会解决这个问题</li></ul><br><h1 id="po-persistent-object" tabindex="-1"><a class="header-anchor" href="#po-persistent-object" aria-hidden="true">#</a> PO (Persistent Object)</h1><blockquote><p><strong>记录员</strong>：负责把数据原原本本地记录到库中；对接主管，把数据悉数上交</p></blockquote><ul><li>持久化对象，与 Entity 实体的概念是一致的</li><li>跟持久层的数据形成一一对应的映射关系</li><li>对于现在的开发而言，一般来说 PO 对象就是上文所说的贫血模型（Value Object），行为只有 setter/getter（这里涉及到了 DDD，不展开叙述）</li><li>对于简单的业务来说，PO 有时也可以充当 DTO</li></ul><br><h1 id="bo-business-object" tabindex="-1"><a class="header-anchor" href="#bo-business-object" aria-hidden="true">#</a> BO (Business Object)</h1><blockquote><p><strong>主管</strong>：管记录员；对接搬运工，将记录员的全部数据交给搬运工运输</p></blockquote><ul><li><p>BO 简单来说就是 PO 的组合</p></li><li><p>如果 PO 是一条数据记录对象，那么 BO 就是全部数据记录的集合对象</p></li><li><p>不难发现 BO 其实就是一个业务对象，BO 中会有很多跟业务有关的行为或操作</p></li><li><p>BO 这个概念在许多框架中可能不易察觉，因为这些框架自身就带有数据组合的功能，因此 PO 拼接成 BO 这个操作可能在业务层完成（在实现业务逻辑中完成）；也有可能是在数据访问层由框架直接生成 BO</p></li><li><p>BO 与 DTO 的区别主要就是字段数量不同，一般 BO 的字段会比 DTO 多，因为处理业务过程中需要额外的数据，而交到 DTO 手中之后，DTO 就只需要选择自己需要的即可</p></li></ul><br><h1 id="do-domain-object" tabindex="-1"><a class="header-anchor" href="#do-domain-object" aria-hidden="true">#</a> DO (Domain Object)</h1><blockquote><p>实际含义比较抽象，就不拟人了</p></blockquote><ul><li>领域对象</li><li>指从现实世界抽象出来的业务实体（这里其实与 DDD 的关联更大，但是并非重点，不赘述）</li><li>当 DO 的含义为 Data Object 时，其实就等同于上面的 PO（阿里巴巴手册中的定义）</li><li>当 DO 的含义为 Domain Object 时，其实就等于上面的 BO</li></ul><br><h1 id="pojo-plain-ordinary-java-object" tabindex="-1"><a class="header-anchor" href="#pojo-plain-ordinary-java-object" aria-hidden="true">#</a> POJO (Plain ordinary java object)</h1><blockquote><p>无规则简单 Java 对象，也叫 Pure old java object，实际上就是普通的 JavaBean</p></blockquote><ul><li><p>POJO 其实是一个中间对象，可以转化为上述的 VO/PO/DTO</p></li><li><p>或者换种说法更为直接：POJO 持久化后就是 PO；POJO 在传输过程中就是 DTO；POJO 用作表示层时就是 VO</p></li><li><p>但是在一般的开发中，PO 对象所在的包一般以 pojo 命名（或者使用 entity/domain），而这只是为了区分不同的对象，不必太过纠结</p></li></ul><br><h1 id="entity-domain" tabindex="-1"><a class="header-anchor" href="#entity-domain" aria-hidden="true">#</a> Entity/Domain</h1><blockquote><p>可以理解成 pojo 的别名，虽然概念和范围上不太相同，但是并不会有影响</p></blockquote><ul><li>Entity：实体类，属性严格对应数据库表的字段，类似 PO</li><li>Domain：封装了数据库字段的 JavaBean 对象，其中可以封装多个表格数据，范围比较大，类似 BO</li><li>但是实际开发中，pojo/entity/domain 包下的对象一般都是 PO，这里不必纠结</li></ul><br><h1 id="写在最后" tabindex="-1"><a class="header-anchor" href="#写在最后" aria-hidden="true">#</a> 写在最后</h1><ul><li>其实有这么多概念只是为了做出<strong>层次划分</strong>和<strong>规范</strong>；划分层次其实是提供了类似防腐层的作用，使得项目结构清晰的同时有着更多的容错性，规范则是让团队协作开发更加容易</li><li>诚然，如果不考虑项目的实际情况就全部套用，可能会让项目变得复杂繁琐，而实际开发中，确实不会全部套用，更多的是开发小组内讨论决定使用怎么样的规范，最终目的其实是为了项目的<strong>开发效率</strong>和<strong>可维护性</strong></li><li>对于这些概念其实也不必太过纠结，更重要的是理解其背后的含义，如何称呼或者划分只是一个表现形式，实际落地要懂得变通，只要形成了组内的规范并且达到了其含义背后想要的结果即可</li></ul><p><br><br></p>',41);function h(p,j){const l=c("router-link");return n(),r("div",null,[u,e("nav",O,[e("ul",null,[e("li",null,[i(l,{to:"#领域模型分类"},{default:a(()=>[t("领域模型分类")]),_:1})]),e("li",null,[i(l,{to:"#写在前面"},{default:a(()=>[t("写在前面")]),_:1})]),e("li",null,[i(l,{to:"#vo-view-object"},{default:a(()=>[t("VO (View Object)")]),_:1})]),e("li",null,[i(l,{to:"#dto-data-transfer-object"},{default:a(()=>[t("DTO (Data Transfer Object)")]),_:1})]),e("li",null,[i(l,{to:"#po-persistent-object"},{default:a(()=>[t("PO (Persistent Object)")]),_:1})]),e("li",null,[i(l,{to:"#bo-business-object"},{default:a(()=>[t("BO (Business Object)")]),_:1})]),e("li",null,[i(l,{to:"#do-domain-object"},{default:a(()=>[t("DO (Domain Object)")]),_:1})]),e("li",null,[i(l,{to:"#pojo-plain-ordinary-java-object"},{default:a(()=>[t("POJO (Plain ordinary java object)")]),_:1})]),e("li",null,[i(l,{to:"#entity-domain"},{default:a(()=>[t("Entity/Domain")]),_:1})]),e("li",null,[i(l,{to:"#写在最后"},{default:a(()=>[t("写在最后")]),_:1})])])]),b])}const D=o(d,[["render",h],["__file","领域模型分类-已发布.html.vue"]]);export{D as default};
