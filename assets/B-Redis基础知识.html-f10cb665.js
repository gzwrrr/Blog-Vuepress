import{_ as s,Q as a,S as l,U as t,W as r,X as o,a8 as d,a9 as i,H as c}from"./framework-d7e1aa10.js";const h={},n=t("h1",{id:"redis-基础知识",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#redis-基础知识","aria-hidden":"true"},"#"),d(" Redis 基础知识")],-1),p={class:"table-of-contents"},u=i('<blockquote><p>redis默认有16个数据库，默认使用第0个</p></blockquote><h2 id="_1-基础语法" tabindex="-1"><a class="header-anchor" href="#_1-基础语法" aria-hidden="true">#</a> 1.基础语法</h2><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>select 0~15</code></td><td>切换数据库</td></tr><tr><td>2</td><td><code>dbsize</code></td><td>查看当前数据库的空间大小</td></tr><tr><td>3</td><td><code>set 键 值</code></td><td>储存数据</td></tr><tr><td>4</td><td><code>get 键</code></td><td>获取键对应的值</td></tr><tr><td>5</td><td><code>keys *</code></td><td>查看当前数据库中所有的键</td></tr><tr><td>6</td><td><code>flushdb</code></td><td>清空当前数据库</td></tr><tr><td>7</td><td><code>flushall</code></td><td>清空所有数据库</td></tr><tr><td>8</td><td><code>exists 键</code></td><td>查看当前数据库是否存在这个键</td></tr><tr><td>9</td><td><code>move 键 值</code></td><td>移除当前数据库中的指定键值对</td></tr><tr><td>10</td><td><code>expire 键 时间</code></td><td>指定时间结束后过期，即删除该键值对</td></tr><tr><td>11</td><td><code>ttl 键</code></td><td>查看指定键值对剩余存活时间</td></tr><tr><td>12</td><td><code>append 键 追加的值</code></td><td>向指定键的值后追加值</td></tr></tbody></table></div><h2 id="_2-基本类型" tabindex="-1"><a class="header-anchor" href="#_2-基本类型" aria-hidden="true">#</a> 2.基本类型</h2><h3 id="_2-1-string" tabindex="-1"><a class="header-anchor" href="#_2-1-string" aria-hidden="true">#</a> 2.1 String</h3><ul><li>相关的用法</li></ul><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>strlen 键</code></td><td>查看对应值的长度</td></tr><tr><td>2</td><td><code>incr 键</code></td><td>让指定键的值自动加1，并显示</td></tr><tr><td>3</td><td><code>decr 键</code></td><td>让指定键的值自动减1，并显示</td></tr><tr><td>4</td><td><code>incrby 键 增量</code></td><td>让指定键的值增加指定的增量</td></tr><tr><td>5</td><td><code>decrby 键 减量</code></td><td>让指定键的值减少指定的减量</td></tr><tr><td>6</td><td><code>getrange 键 起始下标 结束下标</code></td><td>得到指定键中指定范围的值</td></tr><tr><td>7</td><td><code>setrange 键 起始下标 修改的值</code></td><td>替换指定键中起始下标及往后的值为指定修改的值</td></tr><tr><td>8</td><td><code>setex 键 过期时间 值</code></td><td>setex : set with expire，存入键值对并指定过期时间</td></tr><tr><td>9</td><td><code>setnx 键 值</code></td><td>setnx : set if not exist，如果不存在再添加（分布式锁中常用）</td></tr><tr><td>10</td><td><code>mset 键1 值1 键2 值2 ...</code></td><td>同时设置多个键值对</td></tr><tr><td>11</td><td><code>mget 键1 键2 ...</code></td><td>同时获取多个值</td></tr><tr><td>12</td><td><code>msetnx 键1 值1 键2 值2</code></td><td>不存在才添加，原子性操作，只有全部不存在才能成功</td></tr><tr><td>13</td><td><code>getset 键 新值</code></td><td>如果存在值才获取对应的值，然后再设置新的值</td></tr></tbody></table></div><p><strong>实战场景：</strong></p><ul><li><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li><li><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li><li><strong>session</strong>：常见方案spring session + redis实现session共享</li></ul><h3 id="_2-2-list" tabindex="-1"><a class="header-anchor" href="#_2-2-list" aria-hidden="true">#</a> 2.2 List</h3><p>注：在list中，值是可以重复的，左与前对应，右与后对应，带字母 “ l ” 的命令中的 “ l ” 含义有时是list，有时是left</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>lpush list名 值</code></td><td>从左侧添加值（头部）</td></tr><tr><td>2</td><td><code>rpush list名 值</code></td><td>从右侧添加值（尾部）</td></tr><tr><td>3</td><td><code>lrange list名 起始下标 结束下标</code></td><td>查看一定范围内list的值</td></tr><tr><td>4</td><td><code>lpop list名</code></td><td>移除list左侧第一个值</td></tr><tr><td>5</td><td><code>rpop list名</code></td><td>移除list右侧第一个值</td></tr><tr><td>6</td><td><code>lindex list名 index</code></td><td>获取index索引对应的值</td></tr><tr><td>7</td><td><code>llen list名</code></td><td>获取list的长度</td></tr><tr><td>8</td><td><code>lrem list名 数量 需要移除的值</code></td><td>移除指定的值</td></tr><tr><td>9</td><td><code>ltrim list名 起始下标 结束下标</code></td><td>只保留范围内的值（删除其余的值）</td></tr><tr><td>10</td><td><code>rpoplpush 被pop的list1名 被push的list2名</code></td><td>将list1最右边值移除并添加到list2的最左边（这是一个组合命令 ）</td></tr><tr><td>11</td><td><code>lset list名 index 新值</code></td><td>更新list里index索引对应的值为新值</td></tr><tr><td>12</td><td>`linsert list名 before</td><td>after 指定值 插入值`</td></tr></tbody></table></div><p><strong>使用列表的技巧：</strong></p><ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul><p><strong>实战场景：</strong></p><ul><li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li><li><strong>消息队列</strong></li></ul><h3 id="_2-3-set" tabindex="-1"><a class="header-anchor" href="#_2-3-set" aria-hidden="true">#</a> 2.3 Set</h3><p>注：set中的值是不可以重复的，也是无序的</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>sadd set名 值</code></td><td>添加值</td></tr><tr><td>2</td><td><code>smembers set名</code></td><td>查看值</td></tr><tr><td>3</td><td><code>sismember set名 被判断的值</code></td><td>判断set中是否有被判断的值，有则返回，否则返回0</td></tr><tr><td>4</td><td><code>scard set名</code></td><td>获取set集合中的元素个数</td></tr><tr><td>5</td><td><code>srem set名 指定值</code></td><td>移除set中指定的值</td></tr><tr><td>6</td><td><code>srandmember set名</code></td><td>从set中随机取出一个值</td></tr><tr><td>7</td><td><code>spop set名</code></td><td>从set中随机移除一个值</td></tr><tr><td>8</td><td><code>smove 被移除的set1名 被移入的set2名 指定值</code></td><td>将set1中指定的值移入到set2中</td></tr><tr><td>9</td><td><code>sdiff set1名 set2名</code></td><td>获得两个set的差集</td></tr><tr><td>10</td><td><code>sinter set1名 set2名</code></td><td>获得两个set的交集</td></tr><tr><td>11</td><td><code>sunion set1名 set2名</code></td><td>获得两个set的并集</td></tr></tbody></table></div><p><strong>实战场景：</strong></p><ul><li><strong>标签</strong>（tag），给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li></ul><h3 id="_2-4-hash" tabindex="-1"><a class="header-anchor" href="#_2-4-hash" aria-hidden="true">#</a> 2.4 Hash</h3><p>注：是一个Map集合（键值对key-value），本质和String没有太大区别，只不过hash更适合存储对象</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>hset hash名 键 值</code></td><td>添加键值对</td></tr><tr><td>2</td><td><code>hget hash名 指定键</code></td><td>根据指定键得到值</td></tr><tr><td>3</td><td><code>hmset hash名 键1 值1 键2 值2 ...</code></td><td>同时设置多个键值对</td></tr><tr><td>4</td><td><code>hmget hash名 键1 键2 ...</code></td><td>同时获取多个值</td></tr><tr><td>5</td><td><code>hgetall hash名</code></td><td>获取全部的键值对</td></tr><tr><td>6</td><td><code>hdel hash名 指定键</code></td><td>删除指定键的键值对</td></tr><tr><td>7</td><td><code>hlen hash名</code></td><td>获取hash的字段数量</td></tr><tr><td>8</td><td><code>hexists hash名 指定键</code></td><td>判断指定键对应的键值对是否存在</td></tr><tr><td>9</td><td><code>hkeys hash名</code></td><td>获取hash所有的键</td></tr><tr><td>10</td><td><code>hvals hash名</code></td><td>获取hash所有的值</td></tr><tr><td>11</td><td><code>hincrby hash名 指定键 增量</code></td><td>将指定键的值增加对应增量（增量也可以是负的）</td></tr><tr><td>12</td><td><code>hsetnx hash 键 值</code></td><td>不存在则添加，否则不添加</td></tr></tbody></table></div><p><strong>实战场景：</strong></p><ul><li><strong>缓存</strong>： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等</li></ul><h3 id="_2-5-zset" tabindex="-1"><a class="header-anchor" href="#_2-5-zset" aria-hidden="true">#</a> 2.5 Zset</h3><p>注：在set的基础上增加了一个score，zset是有序的</p><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>zadd zset名 score 值</code></td><td>添加值</td></tr><tr><td>2</td><td><code>zadd zset名 score1 值1 score2 值2 ...</code></td><td>同时添加多个值</td></tr><tr><td>3</td><td><code>zrangebyscore zset名 -inf +inf withscores</code></td><td>根据score的大小从小到大排序排序查询，查询结果的score范围无穷小到无穷大</td></tr><tr><td>4</td><td><code>zrevrange zset 0 -1</code></td><td>同上类似，由大到小排序查询</td></tr><tr><td>5</td><td><code>zrange zset名 起始下标结束下标</code></td><td>查看范围内的值</td></tr><tr><td>6</td><td><code>zrem zset名 指定值</code></td><td>删除指定的值</td></tr><tr><td>7</td><td><code>zcard zset名</code></td><td>获取元素个数</td></tr><tr><td>8</td><td><code>zcount zset名 起始下标 结束下标</code></td><td>统计符合范围的score对应的值的总数</td></tr></tbody></table></div><p>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：</p><ol><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))</li></ol><p><strong>实战场景：</strong></p><ul><li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行</li></ul><h2 id="_3-特殊类型" tabindex="-1"><a class="header-anchor" href="#_3-特殊类型" aria-hidden="true">#</a> 3.特殊类型</h2><p><strong>三种特殊类型</strong></p><ul><li>geospatial</li><li>hyperloglog</li><li>bitmaps</li></ul><h3 id="_3-1-geospatial" tabindex="-1"><a class="header-anchor" href="#_3-1-geospatial" aria-hidden="true">#</a> 3.1 geospatial</h3><p>注：底层实现原理是zset，所以能用zset的命令操作</p><p>可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>geoadd 键 值（经度 纬度 名称）</code></td><td>添加地理位置</td></tr><tr><td>2</td><td><code>geopos 键 值的名称</code></td><td>获取经纬度</td></tr><tr><td>3</td><td><code>geodist 键 名称1 名称2 单位</code></td><td>获取两地之间的直线距离</td></tr><tr><td>4</td><td><code>georadius 键 值（经度 纬度） 半径 单位 ...</code></td><td>查询出在半径内的所有已存储的地理位置</td></tr><tr><td>5</td><td><code>georadiusbymember 键 名称 半径 单位 ...</code></td><td>以地理位置为中心搜寻半径内的其他地理位置</td></tr><tr><td>6</td><td><code>geohash 键 名称1 名称2 ...</code></td><td>将地理位置转换成11位的 <code>geohash</code> 字符串</td></tr></tbody></table></div><h3 id="_3-2-hyperloglog" tabindex="-1"><a class="header-anchor" href="#_3-2-hyperloglog" aria-hidden="true">#</a> 3.2 hyperloglog</h3><p>注：这是一个基数统计（相同元素只记作一个）算法，相较于set的优点事hyperloglog占用的内存是固定的且较小的，2^64的不同元素只占 12 KB，且这种统计法是允许误差的</p><p>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>pfadd 键 值1 值2 ...</code></td><td>创建集合</td></tr><tr><td>2</td><td><code>pfcount 键</code></td><td>统计集合里的基数</td></tr><tr><td>3</td><td><code>pfmerge 键1 键2</code></td><td>合并两个集合</td></tr></tbody></table></div><h3 id="_3-3-bitmaps" tabindex="-1"><a class="header-anchor" href="#_3-3-bitmaps" aria-hidden="true">#</a> 3.3 bitmaps</h3><p>注：位存储，位图，也是一种数据结构</p><p>可以统计用户信息，如活跃与否、登录与否、打卡天数等</p><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>setbit 键 当前序号 值</code></td><td>添加元素</td></tr><tr><td>2</td><td><code>getbit 键 序号</code></td><td>获取值</td></tr><tr><td>3</td><td><code>bitcount 键</code></td><td>统计值</td></tr></tbody></table></div><h3 id="_3-4-stream" tabindex="-1"><a class="header-anchor" href="#_3-4-stream" aria-hidden="true">#</a> 3.4 Stream</h3><p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现，至此使用 Redis 实现消息队列就有三种方式：</p><ol><li>发布/订阅模式，但是这样不能持久化，如果遇到网络断开、Redis 宕机等，消息就会被丢弃</li><li>基于 List LPUSH + BRPOP 或者 基于 Sorted-Set 的实现，支持持久化，但是不支持多播以及分组消费等</li><li>使用 Stream</li></ol><div class="table-wrapper"><table><thead><tr><th>序号</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td><code>xadd key * field1 value1 [field2 value2]</code></td><td>添加元素</td></tr><tr><td>2</td><td><code>xrange key start end [COUNT count]</code></td><td>按区间返回stream中的元素</td></tr><tr><td>3</td><td><code>xrevrange key end start [COUNT count]</code></td><td>按区间返回stream中的元素，倒序</td></tr><tr><td>4</td><td><code>xread COUNT count STREAMS key [key ...] [IDLE ms]</code></td><td>从一个或多个stream中读取消息</td></tr><tr><td>5</td><td><code>xlen key</code></td><td>返回stream的长度</td></tr><tr><td>6</td><td><code>xdel key id [id ...]</code></td><td>删除一个或多个元素</td></tr><tr><td>7</td><td><code>xtrim key MAXLEN [~] count</code></td><td>删除stream中多余的元素</td></tr><tr><td>8</td><td><code>xgroup CREATE key group-name id-or-$</code></td><td>创建一个消费者组</td></tr><tr><td>9</td><td><code>xgroup SETID key group-name id-or-$</code></td><td>为消费者组设置上一个被读取消息ID</td></tr><tr><td>10</td><td><code>xreadgroup GROUP group consumer COUNT count STREAMS key [key ...] [BLOCK ms] [NOACK]</code></td><td>从一个或多个stream中读取消息，带有消费者组信息</td></tr></tbody></table></div><p>此外，Stream还支持以下两个特殊的数据结构：</p><ul><li><code>$</code>表示当前最大的消息ID；</li><li><code>&gt;</code>表示当前最小的未处理的消息ID。</li></ul><p><strong>使用场景：</strong></p><ol><li>可用作时通信等，大数据分析，异地数据备份等</li><li>消息队列：Stream可以作为一种简单的消息队列，生产者可以使用XADD将消息发送到Stream中，而消费者可以使用XREAD命令以阻塞或非阻塞模式读取消息并对其进行处理</li><li>日志存储：Stream可以用于存储和检索日志消息。例如，可以使用XADD将日志消息写入Stream中，然后使用XREAD命令检索和分析这些消息</li><li>时间序列数据：由于Stream支持基于时间戳的检索，因此它可以用于存储和分析时间序列数据。例如，可以将股票市场价格写入Stream中，并使用XREAD命令检索特定时间段内的价格数据进行分析</li><li>事件驱动的应用程序：Stream可以用于在事件驱动的应用程序中处理事件。例如，可以使用XADD将事件写入Stream中，而应用程序可以使用XREAD命令以非阻塞模式获取并处理这些事件</li></ol><p>总之，Redis的Stream是一种非常灵活的数据结构，可以用于多种用途，例如消息队列、日志存储、时间序列数据和事件驱动的应用程序等</p><h2 id="_4-过期键的删除" tabindex="-1"><a class="header-anchor" href="#_4-过期键的删除" aria-hidden="true">#</a> 4.过期键的删除</h2><div class="hint-container info"><p class="hint-container-title">过期信息</p><p>expires 字典会保存所有设置了过期时间的 key 的过期数据。其中 key 是指向键空间（Redis 集群中保存的所有键）中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间</p><p>Redis 同时使用了下面两种过期策略</p></div><p>**惰性过期：**只有当访问一个 key 时，才会判断该 key 是否过期，过期则清理。该策略可以最大化地节省 CPU 的资源占用，但是对内存不友好。极端情况下可能出现大量的过期 key 没有被访问，从而不会清理，占用大量内存</p><p>**定期过期：**每间隔一定时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已经过期的 key。该策略是一个这种的方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以再不同情况下使得 CPU 和内存资源达到最优的平衡效果</p>',63);function g(b,_){const e=c("router-link");return a(),l("div",null,[n,t("nav",p,[t("ul",null,[t("li",null,[r(e,{to:"#redis-基础知识"},{default:o(()=>[d("Redis 基础知识")]),_:1}),t("ul",null,[t("li",null,[r(e,{to:"#_1-基础语法"},{default:o(()=>[d("1.基础语法")]),_:1})]),t("li",null,[r(e,{to:"#_2-基本类型"},{default:o(()=>[d("2.基本类型")]),_:1}),t("ul",null,[t("li",null,[r(e,{to:"#_2-1-string"},{default:o(()=>[d("2.1 String")]),_:1})]),t("li",null,[r(e,{to:"#_2-2-list"},{default:o(()=>[d("2.2 List")]),_:1})]),t("li",null,[r(e,{to:"#_2-3-set"},{default:o(()=>[d("2.3 Set")]),_:1})]),t("li",null,[r(e,{to:"#_2-4-hash"},{default:o(()=>[d("2.4 Hash")]),_:1})]),t("li",null,[r(e,{to:"#_2-5-zset"},{default:o(()=>[d("2.5 Zset")]),_:1})])])]),t("li",null,[r(e,{to:"#_3-特殊类型"},{default:o(()=>[d("3.特殊类型")]),_:1}),t("ul",null,[t("li",null,[r(e,{to:"#_3-1-geospatial"},{default:o(()=>[d("3.1 geospatial")]),_:1})]),t("li",null,[r(e,{to:"#_3-2-hyperloglog"},{default:o(()=>[d("3.2 hyperloglog")]),_:1})]),t("li",null,[r(e,{to:"#_3-3-bitmaps"},{default:o(()=>[d("3.3 bitmaps")]),_:1})]),t("li",null,[r(e,{to:"#_3-4-stream"},{default:o(()=>[d("3.4 Stream")]),_:1})])])]),t("li",null,[r(e,{to:"#_4-过期键的删除"},{default:o(()=>[d("4.过期键的删除")]),_:1})])])])])]),u])}const y=s(h,[["render",g],["__file","B-Redis基础知识.html.vue"]]);export{y as default};
