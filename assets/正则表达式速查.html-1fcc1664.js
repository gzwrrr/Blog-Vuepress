import{_ as a,Q as h,S as p,U as l,a8 as n,W as u,X as e,a9 as _,H as c}from"./framework-d7e1aa10.js";const b={},g=l("h1",{id:"正则表达式速查",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#正则表达式速查","aria-hidden":"true"},"#"),n(" 正则表达式速查")],-1),m={class:"hint-container info"},C=l("p",{class:"hint-container-title"},"Info",-1),S=l("br",null,null,-1),f={href:"https://space.bilibili.com/384068749?spm_id_from=333.337.0.0",target:"_blank",rel:"noopener noreferrer"},A={href:"https://r2coding.com/",target:"_blank",rel:"noopener noreferrer"},v=l("h2",{id:"基本知识",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#基本知识","aria-hidden":"true"},"#"),n(" 基本知识")],-1),F=l("div",{class:"table-wrapper"},[l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"表达式")]),l("th",null,[l("strong",null,"描述")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"[abc]")]),l("td",null,"字符集。匹配集合中所含的任一字符。")]),l("tr",null,[l("td",null,[l("code",null,"[^abc]")]),l("td",null,"否定字符集。匹配任何不在集合中的字符。")]),l("tr",null,[l("td",null,[l("code",null,"[a-z]")]),l("td",null,"字符范围。匹配指定范围内的任意字符。")]),l("tr",null,[l("td",null,[l("code",null,".")]),l("td",null,"匹配除换行符以外的任何单个字符。")]),l("tr",null,[l("td",null,[l("code",null,"\\")]),l("td",null,"转义字符。")]),l("tr",null,[l("td",null,[l("code",null,"\\w")]),l("td",null,[n("匹配任何字母数字，包括下划线（等价于"),l("code",null,"[A-Za-z0-9_]"),n("）。")])]),l("tr",null,[l("td",null,[l("code",null,"\\W")]),l("td",null,[n("匹配任何非字母数字（等价于"),l("code",null,"[^A-Za-z0-9_]"),n("）。")])]),l("tr",null,[l("td",null,[l("code",null,"\\d")]),l("td",null,"数字。匹配任何数字。")]),l("tr",null,[l("td",null,[l("code",null,"\\D")]),l("td",null,"非数字。匹配任何非数字字符。")]),l("tr",null,[l("td",null,[l("code",null,"\\s")]),l("td",null,"空白。匹配任何空白字符，包括空格、制表符等。")]),l("tr",null,[l("td",null,[l("code",null,"\\S")]),l("td",null,"非空白。匹配任何非空白字符。")])])])],-1),N=l("div",{class:"table-wrapper"},[l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"表达式")]),l("th",null,[l("strong",null,"描述")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"(expression)")]),l("td",null,"分组。匹配括号里的整个表达式。")]),l("tr",null,[l("td",null,[l("code",null,"(?:expression)")]),l("td",null,"非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。")]),l("tr",null,[l("td",null,[l("code",null,"\\num")]),l("td",null,[n("对前面所匹配分组的引用。比如"),l("code",null,"(\\d)\\1"),n("可以匹配两个相同的数字，"),l("code",null,"(Code)(Sheep)\\1\\2"),n("则可以匹配"),l("code",null,"CodeSheepCodeSheep"),n("。")])])])])],-1),x=l("div",{class:"table-wrapper"},[l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"表达式")]),l("th",null,[l("strong",null,"描述")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"^")]),l("td",null,"匹配字符串或行开头。")]),l("tr",null,[l("td",null,[l("code",null,"$")]),l("td",null,"匹配字符串或行结尾。")]),l("tr",null,[l("td",null,[l("code",null,"\\b")]),l("td",null,[n("匹配单词边界。比如"),l("code",null,"Sheep\\b"),n("可以匹配"),l("code",null,"CodeSheep"),n("末尾的"),l("code",null,"Sheep"),n("，不能匹配"),l("code",null,"CodeSheepCode"),n("中的"),l("code",null,"Sheep")])]),l("tr",null,[l("td",null,[l("code",null,"\\B")]),l("td",null,[n("匹配非单词边界。比如"),l("code",null,"Code\\B"),n("可以匹配"),l("code",null,"HelloCodeSheep"),n("中的"),l("code",null,"Code"),n("，不能匹配"),l("code",null,"HelloCode"),n("中的"),l("code",null,"Code"),n("。")])])])])],-1),w=l("div",{class:"table-wrapper"},[l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"表达式")]),l("th",null,[l("strong",null,"描述")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"?")]),l("td",null,"匹配前面的表达式0个或1个。即表示可选项。")]),l("tr",null,[l("td",null,[l("code",null,"+")]),l("td",null,"匹配前面的表达式至少1个。")]),l("tr",null,[l("td",null,[l("code",null,"*")]),l("td",null,"匹配前面的表达式0个或多个。")]),l("tr",null,[l("td",null,"`"),l("td",null,"`")]),l("tr",null,[l("td",null,[l("code",null,"{m}")]),l("td",null,"匹配前面的表达式m个。")]),l("tr",null,[l("td",null,[l("code",null,"{m,}")]),l("td",null,"匹配前面的表达式最少m个。")]),l("tr",null,[l("td",null,[l("code",null,"{m,n}")]),l("td",null,"匹配前面的表达式最少m个，最多n个。")])])])],-1),k=l("div",{class:"table-wrapper"},[l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"表达式")]),l("th",null,[l("strong",null,"描述")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"(?=)")]),l("td",null,[n("正向预查。比如"),l("code",null,"Code(?=Sheep)"),n("能匹配"),l("code",null,"CodeSheep"),n("中的"),l("code",null,"Code"),n("，但不能匹配"),l("code",null,"CodePig"),n("中的"),l("code",null,"Code"),n("。")])]),l("tr",null,[l("td",null,[l("code",null,"(?!)")]),l("td",null,[n("正向否定预查。比如"),l("code",null,"Code(?!Sheep)"),n("不能匹配"),l("code",null,"CodeSheep"),n("中的"),l("code",null,"Code"),n("，但能匹配"),l("code",null,"CodePig"),n("中的"),l("code",null,"Code"),n("。")])]),l("tr",null,[l("td",null,[l("code",null,"(?<=)")]),l("td",null,[n("反向预查。比如"),l("code",null,"(?<=Code)Sheep"),n("能匹配"),l("code",null,"CodeSheep"),n("中的"),l("code",null,"Sheep"),n("，但不能匹配"),l("code",null,"ReadSheep"),n("中的"),l("code",null,"Sheep"),n("。")])]),l("tr",null,[l("td",null,[l("code",null,"(?<!)")]),l("td",null,[n("反向否定预查。比如"),l("code",null,"(?<!Code)Sheep"),n("不能匹配"),l("code",null,"CodeSheep"),n("中的"),l("code",null,"Sheep"),n("，但能匹配"),l("code",null,"ReadSheep"),n("中的"),l("code",null,"Sheep"),n("。")])])])])],-1),D=l("div",{class:"table-wrapper"},[l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"表达式")]),l("th",null,[l("strong",null,"描述")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"/.../i")]),l("td",null,"忽略大小写。")]),l("tr",null,[l("td",null,[l("code",null,"/.../g")]),l("td",null,"全局匹配。")]),l("tr",null,[l("td",null,[l("code",null,"/.../m")]),l("td",null,"多行修饰符。用于多行匹配。")])])])],-1),P=_('<h2 id="正则原理" tabindex="-1"><a class="header-anchor" href="#正则原理" aria-hidden="true">#</a> 正则原理</h2><p>正则引擎主要可以分为基本不同的两大类：</p><ol><li>DFA (Deterministic finite automaton) 确定型有穷自动机</li><li>NFA (Non-deterministic finite automaton) 非确定型有穷自动机</li></ol><p><strong>DFA引擎 和 NFA引擎 的区别就在于</strong>：在没有编写正则表达式的前提下，是否能确定字符执行顺序</p><br><blockquote><p>DFA（是电动机） 和NFA（汽油机） 都有很长的历史，不过，正如汽油机一样，NFA 的历史更长一些。也有些系统采用了混合引擎，它们会根据任务的不同选择合适的引擎（甚至对同一表达式中的不同部分采用不同的引擎，以求得功能与速度之间的最佳平衡）。 ——《精通正则表达式》</p></blockquote><p>DFA引擎的特点：</p><ol><li><strong>文本主导</strong>：按照文本的顺序执行，这也就能说明为什么DFA引擎是确定型(deterministic)了，稳定</li><li><strong>记录当前有效的所有可能</strong>：我们看到当执行到<code>(d|b)</code>时，同时比较表达式中的<code>d</code>和<code>b</code>，所以会需要更多的内存</li><li><strong>每个字符只检查一次</strong>：这提高了执行效率，而且速度与正则表达式无关</li><li><strong>不能使用反向引用等功能</strong>：因为每个字符只检查一次，文本零宽度（位置）只记录当前比较值，所以不能使用反向引用、环视等一些功能</li></ol><br><p>NFA引擎的一些特点：</p><ol><li><strong>文表达式主导</strong>：按照表达式的一部分执行，如果不匹配换其他部分继续匹配，直到表达式匹配完成。</li><li><strong>会记录某个位置</strong>：我们看到当执行到<code>(d|b)</code>时，NFA引擎会记录字符的位置（零宽度），然后选择其中一个先匹配。</li><li><strong>单个字符可能检查多次</strong>：我们看到当执行到<code>(d|b)</code>时，比较<code>d</code>后发现不匹配，于是NFA引擎换表达式的另一个分支<code>b</code>，同时文本位置<strong>回退</strong>，重新匹配字符&#39;b&#39;。这也是NFA引擎是非确定型的原因，同时带来另一个问题效率可能没有DFA引擎高。</li><li><strong>可实现反向引用等功能</strong>：因为具有<strong>回退</strong>这一步，所以可以很容易的实现反向引用、环视等一些功能！</li></ol><p>绝大多数的变成语言采用的都是 NFA 引擎，NFA引擎的特点是：<strong>功能强大</strong>、但有回溯机制所以<strong>效率慢</strong></p><p>需要特别注意的是：NFA 由于有回溯所以可能出现 <strong>回溯陷阱</strong>，这个严重情况可能会让 CPU 到达 100%</p>',13),y={class:"hint-container note"},B=l("p",{class:"hint-container-title"},"原文",-1),z={href:"https://zhuanlan.zhihu.com/p/107836267",target:"_blank",rel:"noopener noreferrer"};function V(E,H){const r=c("ExternalLinkIcon"),s=c("Tabs"),i=c("ShowPdf");return h(),p("div",null,[g,l("div",m,[C,l("p",null,[n("本文档出自 Codesheep 羊哥，这里只是为了方便就直接把 PDF 放上来了"),S,l("a",f,[n("羊哥 B 站主页戳这里"),u(r)]),n("，另外，极力推荐羊哥的网站："),l("a",A,[n("r2coding 编程自学之路"),u(r)])])]),v,u(s,{id:"11",data:[{title:"字符"},{title:"分组和引用"},{title:"锚点/边界"},{title:"数量"},{title:"预查断言"},{title:"特殊标志"}],active:0,"tab-id":"fruit"},{tab0:e(({title:t,value:o,isActive:d})=>[F]),tab1:e(({title:t,value:o,isActive:d})=>[N]),tab2:e(({title:t,value:o,isActive:d})=>[x]),tab3:e(({title:t,value:o,isActive:d})=>[w]),tab4:e(({title:t,value:o,isActive:d})=>[k]),tab5:e(({title:t,value:o,isActive:d})=>[D]),_:1}),u(i,{filePath:"其他",fileName:"正则表达式速查备忘手册"}),P,l("div",y,[B,l("p",null,[l("a",z,[n("原文戳这里"),u(r)])])])])}const T=a(b,[["render",V],["__file","正则表达式速查.html.vue"]]);export{T as default};
