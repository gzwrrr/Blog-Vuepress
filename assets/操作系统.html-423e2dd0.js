import{_ as o,Q as a,S as t,U as i,a8 as l,W as r,a9 as n,H as s}from"./framework-d7e1aa10.js";const c={},d=i("h1",{id:"操作系统",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#操作系统","aria-hidden":"true"},"#"),l(" 操作系统")],-1),h={class:"hint-container info"},p=i("p",{class:"hint-container-title"},"参考",-1),_={href:"https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8",target:"_blank",rel:"noopener noreferrer"},g=n('<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><p>操作系统的作用：</p><ol><li>进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等</li><li>文件管理：内存的分配和管理、外存（磁盘等）的分配和管理等</li><li>存储管理：文件的读、写、创建及删除等</li><li>设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能</li><li>网络管理：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务</li><li>安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作</li></ol><p>用户态和内核态：</p><ol><li>用户态切换到内核态的方式： <ol><li>系统调用：用户程序调用系统接口，例如进程管理、文件管理、存储管理、设备管理。一般过程是发起系统调用 -&gt; trap 中断 -&gt; 内核执行系统调用 -&gt; trap 中断 -&gt; 返回</li><li>中断</li><li>异常</li></ol></li></ol><h2 id="进程与线程" tabindex="-1"><a class="header-anchor" href="#进程与线程" aria-hidden="true">#</a> 进程与线程</h2><p><strong>进程（Process）</strong> 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。</p><p><strong>线程（Thread）</strong> 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</p><p>区别：</p><ol><li>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反</li></ol><p>使用线程的好处：</p><ol><li>成本低：进程切换是一个开销很大的操作，线程切换的成本较低</li><li>轻量：线程更轻量，一个进程可以创建多个线程</li><li>高并发：多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回</li><li>资源共享：同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li></ol><p>为什么使用线程：</p><ol><li>计算机层面：线程切换和调度的开销更小。单核 CPU 下假如一个线程发生阻塞，其他线程也还可以使用 CPU，多核 CPU 下可以实现并行操作，可以减少线程上下文切换的开发</li><li>互联网发展趋势：多线程并发编程是高并发的基础，可以提高系统整体的并发能力以及性能</li></ol><p>线程同步方式：</p><ol><li><strong>互斥锁(Mutex)</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> 都是这种机制。</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li><li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>屏障（Barrier）</strong> ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 <code>CyclicBarrier</code> 是这种机制。</li><li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><h2 id="pcb" tabindex="-1"><a class="header-anchor" href="#pcb" aria-hidden="true">#</a> PCB</h2><ol><li>进程控制块，OS 用于监控和追踪进程的数据结构，每个进程都对应一个独立的 PCB</li><li>创建一个进程是会为进程分配一个唯一 ID 并且创建相应的 PCB，PCB 中的信息在进程运行过程中不断变化，OS 根据这些信息来管理和调度进程</li></ol><h2 id="进程" tabindex="-1"><a class="header-anchor" href="#进程" aria-hidden="true">#</a> 进程</h2><p>进程的状态：</p><ol><li>NEW 创建状态</li><li>READY 就绪状态</li><li>RUNNING 运行状态</li><li>WAITING 等待状态或者阻塞状态</li><li>TERMINATED 结束状态</li></ol><p>进程通信方式：</p><ol><li>管道：匿名管道、有名管道</li><li>信号：接收事件</li><li>信号量：计数器</li><li>消息队列</li><li>共享内存</li><li>套接字</li></ol><p>进程常见的调度算法：</p><ol><li>先来先服务</li><li>短作业优先</li><li>时间片轮转</li><li>优先级队列</li></ol><p>其他：</p><ol><li><strong>僵尸进程</strong> ：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程</li><li><strong>孤儿进程</strong> ：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源</li></ol><h2 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h2><blockquote><p>死锁（Deadlock）描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p></blockquote><p>发生死锁的条件：</p><ol><li>资源互斥</li><li>非抢占调度</li><li>占有资源并等待另一资源</li><li>循环等待</li></ol><p>解决死锁的方法：</p><ol><li>预防：限制资源使得上述条件不能成立（例如银行家算法）</li><li>避免：分配资源时提前预测</li><li>检测：系统有特定的机构能够定位死锁</li><li>解除：配合检测机构接触进程的死锁状态</li></ol>',33);function u(f,B){const e=s("ExternalLinkIcon");return a(),t("div",null,[d,i("div",h,[p,i("p",null,[i("a",_,[l("JavaGuide 操作系统常见面试题总结"),r(e)])])]),g])}const x=o(c,[["render",u],["__file","操作系统.html.vue"]]);export{x as default};
