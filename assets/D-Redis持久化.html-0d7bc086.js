import{_ as d,Q as s,S as t,U as l,W as r,X as a,a8 as i,a9 as n,H as o}from"./framework-d7e1aa10.js";const p={},u=l("h1",{id:"redis-持久化",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#redis-持久化","aria-hidden":"true"},"#"),i(" Redis 持久化")],-1),c={class:"table-of-contents"},_=n('<div class="hint-container warning"><p class="hint-container-title">Note</p><p>主服务器不进行 <strong>持久化</strong> 时进行复制时是非常危险的，因为没有持久化时 Redis 重启会造成主服务器数据清空，如果使用了哨兵模式且主服务器重启过快没有检测出错误，那么从服务器的数据也会一并清空</p></div><ul><li>rdb 保存的文件是 dump.rdb，aof 保存的文件是 appendonly.aof 文件</li><li>redis 会在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时时将快照文件直接读到内存中</li><li>redis 会单独创建（fork）一个子进程来进行持久化，先将数据写到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上持久化好的文件</li><li>上述过程中，主进程不进行任何 IO 操作，这确保了极高的性能。</li><li>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么 rdb 的方式要比 aof 的方式更加高效，但是 rdb 有可能会将最后一次持久化后的数据丢失</li></ul><h2 id="_1-rdb" tabindex="-1"><a class="header-anchor" href="#_1-rdb" aria-hidden="true">#</a> 1.RDB</h2><p>RDB：Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</p><p><strong>1.rdb 文件保存的触发规则：</strong></p><ul><li>配置文件中 save 的规则满足的情况下会触发</li><li>执行 flushall 命令会触发</li><li>退出 redis 时会触发</li><li>备份会触发</li></ul><p><strong>2.恢复 rdb 文件：</strong></p><ul><li>只需要将 rdb 文件放在 redis 的启动目录即可</li></ul><p><strong>3.优点：</strong></p><ul><li>整个Redis数据库将只包含一个文件 dump.rdb，方便持久化，容灾性好，方便备份</li><li>相对于数据集大时，比 AOF 的启动效率更高，适合大规模的数据恢复，对数据的完整性要求不高</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li></ul><p><strong>4.缺点：</strong></p><ul><li>需要一定时间进行进程操作，如果中途出意外，那么最后一次修改的数据可能丢失</li><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li><li>fork 进行的时候会占用一定的空间</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟</li></ul><h2 id="_2-aof" tabindex="-1"><a class="header-anchor" href="#_2-aof" aria-hidden="true">#</a> 2.AOF</h2><p>AOF：Append Only File，以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录</p><ul><li>将所有命令都记录下来，恢复时会把这个文件的命令全部执行一遍</li><li>以日志的形式记录每个写操作，将 redis 执行过的所有命令都记录下来（读操作不记录）</li><li>只能追加文件，不能改写文件</li><li>默认不开启，开启将 appendonly 改为 yes 即可</li></ul><p><strong>1.优点：</strong></p><ul><li>数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中</li><li>每次修改都会同步，文件完整性更好</li><li>通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题</li><li>AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</li></ul><p><strong>2.缺点：</strong></p><ul><li>默认每秒同步一次，可能丢失数据</li><li>不同步效率更高</li><li>相对于数据文件来说，aof 远远大于 rdb，修复的速度也比 rdb 慢</li><li>aof 的运行效率也比 rdb 低</li></ul><h2 id="_3-小结" tabindex="-1"><a class="header-anchor" href="#_3-小结" aria-hidden="true">#</a> 3.小结</h2><ul><li><p>AOF文件比RDB更新频率高，优先使用AOF还原数据。</p></li><li><p>AOF比RDB更安全也更大</p></li><li><p>RDB性能比AOF好</p></li><li><p>如果两个都配了优先加载AOF</p></li></ul>',21);function h(f,b){const e=o("router-link");return s(),t("div",null,[u,l("nav",c,[l("ul",null,[l("li",null,[r(e,{to:"#redis-持久化"},{default:a(()=>[i("Redis 持久化")]),_:1}),l("ul",null,[l("li",null,[r(e,{to:"#_1-rdb"},{default:a(()=>[i("1.RDB")]),_:1})]),l("li",null,[r(e,{to:"#_2-aof"},{default:a(()=>[i("2.AOF")]),_:1})]),l("li",null,[r(e,{to:"#_3-小结"},{default:a(()=>[i("3.小结")]),_:1})])])])])]),_])}const g=d(p,[["render",h],["__file","D-Redis持久化.html.vue"]]);export{g as default};
