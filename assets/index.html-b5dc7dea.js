import{_ as s,Q as c,S as h,U as t,W as e,X as i,a8 as d,a9 as a,H as r}from"./framework-d7e1aa10.js";const p={},u=t("h1",{id:"redis",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#redis","aria-hidden":"true"},"#"),d(" Redis")],-1),m={class:"table-of-contents"},f=t("div",{class:"hint-container info"},[t("p",{class:"hint-container-title"},"什么是 Redis"),t("p",null,[d("Redis，"),t("strong",null,"Remote Dictionary Server（远程数据服务）"),d("，是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。")]),t("p",null,"Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。")],-1),_=["src"],g=t("p",null,"Redis 相关的内容大部分内容来自狂神的 B 站视频",-1),b={href:"https://pdai.tech/md/db/nosql-redis/db-redis-introduce.html",target:"_blank",rel:"noopener noreferrer"},y=a('<p>:::</p><h2 id="redis-io-模型" tabindex="-1"><a class="header-anchor" href="#redis-io-模型" aria-hidden="true">#</a> Redis IO 模型</h2><blockquote><p>redis 3.0 之前是单线程模型</p></blockquote><ol><li>redis 单线程每秒可以处理 8w - 11w 的读写请求</li></ol><h3 id="单线程模型" tabindex="-1"><a class="header-anchor" href="#单线程模型" aria-hidden="true">#</a> 单线程模型</h3><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//redis/20230504/redis单线程模型.png" alt="单线程模型" tabindex="0" loading="lazy"><figcaption>单线程模型</figcaption></figure><ol><li>可维护性高</li><li>不存在并发读写问题</li><li>不存在线程切换的开销问题</li><li>不存在加锁、解锁、死锁的问题</li></ol><h3 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型" aria-hidden="true">#</a> 多线程模型</h3><blockquote><p>混合模型，只是在接收请求时使用多线程，处理命令时还是单线程</p></blockquote><figure><img src="https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//redis/20230504/redis多线程模型.png" alt="多线程模型" tabindex="0" loading="lazy"><figcaption>多线程模型</figcaption></figure><h2 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件" aria-hidden="true">#</a> 配置文件</h2>',11),k={class:"hint-container info"},v=t("p",{class:"hint-container-title"},"相关文章",-1),N={href:"https://detail.youzan.com/show/goods/newest?kdt_id=104340304",target:"_blank",rel:"noopener noreferrer"},I=a('<h3 id="redis-conf" tabindex="-1"><a class="header-anchor" href="#redis-conf" aria-hidden="true">#</a> redis.conf</h3><p>模块划分：</p><ol><li>INCLUDES</li><li>MODULES</li><li>NETWORK</li><li>GENERAL</li><li>SNAPSHOTTING</li><li>REPLICATION</li><li>SECURITY</li><li>LAZY FREEING</li><li>APPEND ONLY MODE</li><li>LUA SCRIPTING</li><li>SLOW LOG</li><li>LATENCY MONITOR</li><li>EVENT NOTIFICATION</li><li>ADVANCED CONFIG</li><li>ACTIVE DEFRAGMENTATION</li></ol><div class="table-wrapper"><table><thead><tr><th>序号</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td></td><td><code>bind &lt;IP&gt;</code></td><td>绑定的 IP</td></tr><tr><td></td><td><code>protected-mode yes</code></td><td>开启保护模式</td></tr><tr><td></td><td><code>port &lt;port&gt;</code></td><td>启动端口，默认为 6379</td></tr><tr><td></td><td><code>daemonize yes</code></td><td>以守护线程的方式启动</td></tr><tr><td></td><td><code>timeout &lt;time&gt;</code></td><td>空闲超时断开，默认不断开</td></tr><tr><td></td><td><code>tcp-keepalive &lt;time&gt;</code></td><td>检测是否存活</td></tr><tr><td></td><td><code>tcp-backlog &lt;queuelength&gt;</code></td><td>tcp 连接队列，解决并发场景下的慢连接问题</td></tr><tr><td></td><td><code>pidfile &lt;path&gt;/redis_6379.pid</code></td><td>以后台方式启动需要指定 PID 文件</td></tr><tr><td></td><td><code>loglevel notice</code></td><td>日志等级为 notice</td></tr><tr><td></td><td><code>logfile &lt;path&gt;</code></td><td>日志文件的位置</td></tr><tr><td></td><td><code>databases &lt;num&gt;</code></td><td>数据库的数量，默认为 16</td></tr><tr><td></td><td><code>always-show-logo yes</code></td><td>是否总是显示 LOGO</td></tr><tr><td></td><td><code>stop-writes-on-bgsave-error yes</code></td><td>持久化操作出错还是继续操作</td></tr><tr><td></td><td><code>appendonly no</code></td><td>关闭 aof 模式，即默认使用 rdb 持久化</td></tr><tr><td></td><td><code>appendfilename &lt;filename&gt;</code></td><td>aof 持久化文件名</td></tr><tr><td></td><td><code>rdbcompression yes</code></td><td>启用压缩 rdb 文件</td></tr><tr><td></td><td><code>appendfsync everysec</code></td><td>每一秒持久化一次</td></tr><tr><td></td><td><code>no-appendfsync-on-rewrite no</code></td><td>默认不开启重写</td></tr><tr><td></td><td><code>rdbchecksum yes</code></td><td>保存 rdb 文件时进行错误校验</td></tr><tr><td></td><td><code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></td><td>主从的主节点 IP 和 Port</td></tr><tr><td></td><td><code>masterauth &lt;masterpassword&gt;</code></td><td>主机密码</td></tr><tr><td></td><td><code>requirepass &lt;password&gt;</code></td><td>设置密码</td></tr><tr><td></td><td><code>maxclients &lt;num&gt;</code></td><td>客户端连接数最大数量</td></tr><tr><td></td><td><code>maxmemory &lt;bytes&gt;</code></td><td>最大内存容量</td></tr><tr><td></td><td><code>maxmemory-policy &lt;policy&gt;</code></td><td>内存达到上限之后的处理策略</td></tr></tbody></table></div><p>补充（policy）：</p><ol><li>volatile-lru：只对设置了过期时间的key进行LRU（默认值）</li><li>allkeys-lru ： 删除lru算法的key</li><li>volatile-random：随机删除即将过期key</li><li>allkeys-random：随机删除</li><li>volatile-ttl ： 删除即将过期的</li><li>noeviction ： 永不过期，返回错误</li></ol><h3 id="sentinel-conf" tabindex="-1"><a class="header-anchor" href="#sentinel-conf" aria-hidden="true">#</a> sentinel.conf</h3><div class="table-wrapper"><table><thead><tr><th></th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td></td><td><code>sentinel down-after-milliseconds mymaster 30000</code></td><td>sentinel 认为 master 主观下线需要经历的时间，注意这个对于 sentinel 之间也有作用</td></tr><tr><td></td><td><code>sentinel parallel-syncs mymaster 1</code></td><td>能够与 master 节点同步的 slave 数量，这里体现了 redis 是保证 AP 的</td></tr><tr><td></td><td><code>sentinel failover-timeout mymaster 180000</code></td><td>故障转移失败后重试的时长，注意，如果前一次对一个节点的尝试超时了，那么对下一个节点的尝试时长会翻倍</td></tr><tr><td></td><td><code>sentinel deny-scripts-reconfig yes</code></td><td>运行期间不能修改用于故障转移的脚本</td></tr></tbody></table></div><p>注意：可以通过 <code>sentinel set</code> 命令来动态修改配置信息</p><h2 id="java-客户端" tabindex="-1"><a class="header-anchor" href="#java-客户端" aria-hidden="true">#</a> Java 客户端</h2><blockquote><p>一般使用 Lettuce + Redission</p></blockquote><ol><li>Jedis：使用阻塞 IO，方法都是同步的（不支持异步），客户端实例不是线程安全的，需要通过连接池来管理</li><li>Lettuce：底层基于 Netty，可扩展、线程安全、支持异步</li><li>Redission：关注分离，提供许多分布式相关操作</li></ol>',12);function x(n,E){const o=r("router-link"),l=r("ExternalLinkIcon");return c(),h("div",null,[u,t("nav",m,[t("ul",null,[t("li",null,[e(o,{to:"#redis"},{default:i(()=>[d("Redis")]),_:1}),t("ul",null,[t("li",null,[e(o,{to:"#redis-io-模型"},{default:i(()=>[d("Redis IO 模型")]),_:1}),t("ul",null,[t("li",null,[e(o,{to:"#单线程模型"},{default:i(()=>[d("单线程模型")]),_:1})]),t("li",null,[e(o,{to:"#多线程模型"},{default:i(()=>[d("多线程模型")]),_:1})])])]),t("li",null,[e(o,{to:"#配置文件"},{default:i(()=>[d("配置文件")]),_:1}),t("ul",null,[t("li",null,[e(o,{to:"#redis-conf"},{default:i(()=>[d("redis.conf")]),_:1})]),t("li",null,[e(o,{to:"#sentinel-conf"},{default:i(()=>[d("sentinel.conf")]),_:1})])])]),t("li",null,[e(o,{to:"#java-客户端"},{default:i(()=>[d("Java 客户端")]),_:1})])])])])]),f,t("iframe",{src:n.$withBase("/markmap/html/redis/Redis知识图谱.html"),width:"100%",height:"400",frameborder:"0",scrolling:"No",leftmargin:"0",topmargin:"0"},null,8,_),d(" :::info 文章出处 "),g,t("p",null,[d("另外部分源自于「Java 全栈知识体系」，原文链接："),t("a",b,[d("https://pdai.tech/md/db/nosql-redis/db-redis-introduce.html"),e(l)])]),y,t("div",k,[v,t("ol",null,[t("li",null,[t("a",N,[d("https://detail.youzan.com/show/goods/newest?kdt_id=104340304"),e(l)])])])]),I])}const w=s(p,[["render",x],["__file","index.html.vue"]]);export{w as default};
