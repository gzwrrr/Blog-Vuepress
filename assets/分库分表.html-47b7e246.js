import{_ as t,Q as n,S as r,U as l,W as e,X as a,a8 as o,a9 as s,H as d}from"./framework-d7e1aa10.js";const h={},f=l("h1",{id:"分库分表",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#分库分表","aria-hidden":"true"},"#"),o(" 分库分表")],-1),p={class:"table-of-contents"},c=s('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>传统数据库难以支撑一些高并发的互联网场景，此时 SQL 优化指标不治本</p><p>数据体量大、产生速度快、访问态频繁</p><p>数据库集群化一般有两种方案：</p><ol><li>水平扩展，分库分表</li><li>NewSQL（ClickHouse、voltdb、tidb等）</li></ol><p>分库分表的作用：提升数据库性能</p><p>分表分为：</p><ol><li>水平切分：又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力</li><li>垂直切分：将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等</li></ol><p>优劣：</p><ol><li>垂直分片：按照业务拆分，专用性提升，能够分担数据库压力，但是不能解决性能问题</li><li>水平分片：按照某种规则将单表数据分到多张表中，可以突破单机数据量的瓶颈</li></ol><p>选型：分库分表的产品很多，但是目前影响力最大的还是 ShardingSphere</p><p>问题：</p><ol><li>未来业务量是否能够预估？</li><li>分片的策略怎么选择</li><li>主键唯一性问题</li><li>分布式事务</li><li>SQL 路由</li><li>结果归并</li></ol><p>什么时候分库分表：</p><ol><li>预估数据量：三年内单表数据量大于 500 W 或者单表数据文件大于 2 G</li><li>预估数据趋势：订单类的数据会持续告诉增长，需要尽早考虑分库分表，并且要预留空间</li><li>预估应用场景：读多写少比较适合分库分表，对于分片键变化频繁且需要做迁移的的数据则不适合</li><li>预估业务复杂度：业务逻辑与分片逻辑是绑定的，会给 SQL 执行带来很多限制，如果数据查询逻辑变化非常大，那么就不适合分库分表</li></ol><p>分库分表与多数据源：</p><ol><li>分库分表需要管理多个数据源，但是重点一般放在 SQL 的优化、改写、归并等一系列解决方案</li><li>如果只是需要简单的切换多个数据源，对于 SQL 逻辑没有要求，此时就不需要分库分表，直接选择多数据源的切换方案</li></ol><br><p>知识点：</p><ol><li>数据库水平扩展原理和技术：包括分库分表、数据分片、数据拆分、数据复制等技术，可以通过横向扩展来增加数据库的处理能力和存储容量。</li><li>数据库读写分离原理和技术：将读和写请求分别发送到不同的节点上处理，提高数据库的并发能力和吞吐量。</li><li>分布式事务管理原理和技术：在分布式环境中管理事务的一致性和隔离性，避免因分库分表而导致的数据不一致问题。</li><li>数据库优化和调优：包括SQL语句优化、索引优化、表结构优化等技术，可以提高数据库的查询性能和响应速度。</li><li>数据库安全和备份恢复：包括数据库安全设置、备份和恢复策略、数据加密等技术，可以保障数据库的安全性和可靠性。</li></ol><br><p>工具：</p><ol><li>数据库中间件：如MyCat、ShardingSphere等，可以提供分库分表、读写分离、分布式事务等功能，简化应用程序对数据库的访问。</li><li>数据库管理工具：如Navicat、SQLyog等，可以管理和监控多个数据库节点，并进行SQL语句的执行和优化。</li><li>数据库备份和恢复工具：如mysqldump、xtrabackup等，可以进行数据库的备份和恢复。</li><li>性能测试和负载测试工具：如JMeter、LoadRunner等，可以对数据库进行性能和负载测试，评估数据库的性能和可靠性。</li><li>数据库监控和报警工具：如Zabbix、Nagios等，可以监控数据库的性能和运行状况，并进行报警和告警。</li></ol><h2 id="水平切分" tabindex="-1"><a class="header-anchor" href="#水平切分" aria-hidden="true">#</a> 水平切分</h2><h3 id="切分策略" tabindex="-1"><a class="header-anchor" href="#切分策略" aria-hidden="true">#</a> 切分策略</h3><p>美团的分库分表策略（哈希取模）：</p><blockquote><p>数据水平切分后我们希望是一劳永逸或者是易于水平扩展的，所以推荐采用mod 2^n这种一致性Hash。</p><p>以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024张表。线上部署情况为8个集群(主从)，每个集群4个库。</p></blockquote><p>哈希取模: hash(key) % NUM_DB</p><ol><li>优点：数据存储比较均匀</li><li>缺点：扩容需要大量数据迁移</li></ol><p>范围: 可以是 ID 范围也可以是时间范围</p><ol><li>优点：扩容不需要迁移数据</li><li>缺点：数据存放不均匀，容易产生数据倾斜</li></ol><p>映射表（查询切分）: 使用单独的一个数据库来存储映射关系</p><h3 id="id-生成策略" tabindex="-1"><a class="header-anchor" href="#id-生成策略" aria-hidden="true">#</a> ID 生成策略</h3><p>在分库分表的场景下，常用的ID生成策略包括：</p><ol><li>自增ID：在单库场景下，可以使用自增ID来作为主键，但在分库分表场景下，多个库中自增ID会有重复，需要进行特殊处理。</li><li>UUID：UUID是一种通用唯一识别码，可以在不同机器上生成全局唯一的ID。在分库分表场景下，可以使用UUID作为主键，但是UUID本身较长，不利于索引。</li><li>基于时间戳的ID（例如 Snowflake<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>、Flickr<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>）：根据时间戳生成的ID，可以保证ID的有序性，但是在分布式场景下需要解决时间戳回拨的问题。</li></ol><p>美团的 ID 生成策略：</p><blockquote><p>为了减少运营成本并减少额外的风险我们排除了所有需要独立集群的方案，采用了带有业务属性的方案： &gt; 时间戳+用户标识码+随机数</p><p>有下面几个好处：</p><ul><li>方便、成本低。</li><li>基本无重复的可能。</li><li>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。</li><li>可排序，因为时间戳在最前面。</li></ul><p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p></blockquote><h3 id="sharding-存在的问题" tabindex="-1"><a class="header-anchor" href="#sharding-存在的问题" aria-hidden="true">#</a> Sharding 存在的问题</h3><ol><li><p>事务问题：使用分布式事务来解决，比如 XA 接口<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup></p></li><li><p>链接：需要将原本的 JOIN 分解成多个单表查询，然后在用户程序中进行连接</p></li><li><p>ID 唯一性：</p><ul><li>可以使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>使用分布式 ID 生成器（例如 Snowflake 算法）</li></ul></li></ol><h2 id="数据迁移" tabindex="-1"><a class="header-anchor" href="#数据迁移" aria-hidden="true">#</a> 数据迁移</h2><blockquote><p>一旦水平拆分，那么就不可避免地要进行数据清洗，并且查询条件也必须受到一定的限制</p><p>一旦垂直拆分，那么基本也和 join 说再见了</p></blockquote><ol><li>数据迁移未完成前都需要进行 <strong>数据库双写</strong></li><li>需要每日进行数据对账（例如通过 ETL<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>、DW<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup> 进行 job 数据对账），将差异补齐</li></ol><div class="hint-container note"><p class="hint-container-title">说明</p><p>通过DW进行每日job数据对账的流程包括：导入数据、比较数据、更新数据和记录异常数据。这个过程需要定期执行，以确保数据的准确性和完整性</p></div><p><mark>补充：</mark></p><p>数据对账的一般步骤：</p><ol><li>将源数据和目标数据导入DW中，可以使用ETL工具来完成这个过程。</li><li>在DW中创建一个存储过程，用于比较源数据和目标数据之间的差异，并将差异数据记录到一个临时表中。</li><li>编写SQL语句，将临时表中的差异数据更新到目标数据中，以补平差异。在更新数据之前，应该先备份目标数据，以防止出现错误。</li><li>在存储过程中，对于无法补平的差异数据，可以记录到一个异常表中，以供进一步的分析和处理。</li><li>在每日job数据对账完成后，应该及时通知相关人员，以便他们进行确认和审核。</li></ol><p>总的来说，通过DW进行每日job数据对账的流程包括：导入数据、比较数据、更新数据和记录异常数据。这个过程需要定期执行，以确保数据的准确性和完整性</p><br><h2 id="shardingsphere" tabindex="-1"><a class="header-anchor" href="#shardingsphere" aria-hidden="true">#</a> ShardingSphere</h2><p>新版：</p><ol><li>可插拔</li><li>可扩展</li></ol><p>核心：</p><ol><li>虚拟表</li><li>分片键</li><li>分片算法</li></ol><h3 id="分片策略" tabindex="-1"><a class="header-anchor" href="#分片策略" aria-hidden="true">#</a> 分片策略</h3><ol><li>Inline 策略：配置文件中直接写入分片算法，较为简单，不支持范围查询等复杂操作</li><li>Standard 策略：根据单一分片键进行精确或者范围分片</li><li>Complex 策略：根据多个分片键进行精确或者范围分片</li><li>Hint 策略：使用与 SQL 无关的方式进行分片</li></ol><h3 id="读写分离" tabindex="-1"><a class="header-anchor" href="#读写分离" aria-hidden="true">#</a> 读写分离</h3><blockquote><p>TODO</p></blockquote><h2 id="相关问题" tabindex="-1"><a class="header-anchor" href="#相关问题" aria-hidden="true">#</a> 相关问题</h2><h3 id="如何设计零迁移数据扩容分片方案" tabindex="-1"><a class="header-anchor" href="#如何设计零迁移数据扩容分片方案" aria-hidden="true">#</a> 如何设计零迁移数据扩容分片方案？</h3><blockquote><p>问题核心：如何不迁移数据，实现集群动态扩缩容，同时还能够保证数据分布相对均匀？</p></blockquote><ol><li>可以按范围分片，然后绑定一些节点，负载均衡策略使用哈希取模的方式</li></ol><h3 id="分片查询问题" tabindex="-1"><a class="header-anchor" href="#分片查询问题" aria-hidden="true">#</a> 分片查询问题</h3><ol><li>基因法多分片查询</li></ol><br><br><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>Snowflake 是一种基于时间戳的ID生成算法，属于基于时间戳的ID生成策略。Snowflake算法生成64位的ID，其中第一位是符号位，后面41位是时间戳（精确到毫秒），接着10位是工作机器ID，最后12位是序列号。Snowflake算法的优点是生成的ID有序性较好，而且可以支持高并发场景。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>Flickr方案是一种利用数据库集群生成分布式ID的解决方案，其主要思想是将ID的生成分散到不同的数据库节点上，避免单点瓶颈和单点故障，并通过设置步长来减少数据库的压力。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>XA 接口：分布式事务是指跨多个独立计算机或进程的事务，XA接口是一种支持分布式事务的编程接口。XA接口规范定义了在分布式事务环境中，事务管理器和资源管理器之间的通信接口。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>ETL（Extract, Transform, Load）：数据抽取、转换、加载，是一种将数据从不同的数据源中抽取出来，然后进行处理和转换，最后加载到目标系统中的过程，常用于数据仓库中 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>DW（Data Warehouse）：数据仓库，是一种用于存储和分析企业数据的系统，通过把不同数据源的数据整合到一起，并进行清洗、加工、转换等处理，使得数据更易于理解和使用 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li></ol></section>',68);function u(b,D){const i=d("router-link");return n(),r("div",null,[f,l("nav",p,[l("ul",null,[l("li",null,[e(i,{to:"#分库分表"},{default:a(()=>[o("分库分表")]),_:1}),l("ul",null,[l("li",null,[e(i,{to:"#概述"},{default:a(()=>[o("概述")]),_:1})]),l("li",null,[e(i,{to:"#水平切分"},{default:a(()=>[o("水平切分")]),_:1}),l("ul",null,[l("li",null,[e(i,{to:"#切分策略"},{default:a(()=>[o("切分策略")]),_:1})]),l("li",null,[e(i,{to:"#id-生成策略"},{default:a(()=>[o("ID 生成策略")]),_:1})]),l("li",null,[e(i,{to:"#sharding-存在的问题"},{default:a(()=>[o("Sharding 存在的问题")]),_:1})])])]),l("li",null,[e(i,{to:"#数据迁移"},{default:a(()=>[o("数据迁移")]),_:1})]),l("li",null,[e(i,{to:"#shardingsphere"},{default:a(()=>[o("ShardingSphere")]),_:1}),l("ul",null,[l("li",null,[e(i,{to:"#分片策略"},{default:a(()=>[o("分片策略")]),_:1})]),l("li",null,[e(i,{to:"#读写分离"},{default:a(()=>[o("读写分离")]),_:1})])])]),l("li",null,[e(i,{to:"#相关问题"},{default:a(()=>[o("相关问题")]),_:1}),l("ul",null,[l("li",null,[e(i,{to:"#如何设计零迁移数据扩容分片方案"},{default:a(()=>[o("如何设计零迁移数据扩容分片方案？")]),_:1})]),l("li",null,[e(i,{to:"#分片查询问题"},{default:a(()=>[o("分片查询问题")]),_:1})])])])])])])]),c])}const I=t(h,[["render",u],["__file","分库分表.html.vue"]]);export{I as default};
